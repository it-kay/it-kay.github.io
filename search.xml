<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度优先搜索</title>
    <url>/Algorithm/DFS/</url>
    <content><![CDATA[<h1 id="depth-first-search-DFS-深度优先搜索"><a href="#depth-first-search-DFS-深度优先搜索" class="headerlink" title="depth first search ( DFS) 深度优先搜索"></a>depth first search ( DFS) 深度优先搜索</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的安装与配置</title>
    <url>/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;kay.wang&#x27;</span><br><span class="line"></span><br><span class="line">git config --global user.email &#x27;kay@tooupper.com&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="生成本地密钥"><a href="#生成本地密钥" class="headerlink" title="生成本地密钥"></a>生成本地密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;kay@tooupper.com&#x27;</span><br></pre></td></tr></table></figure>

<p>下面一路回车即可</p>
<h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><h3 id="bash-ssh-keygen-command-not-found"><a href="#bash-ssh-keygen-command-not-found" class="headerlink" title="-bash: ssh-keygen: command not found"></a>-bash: ssh-keygen: command not found</h3><p>未安装SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单用法</title>
    <url>/Git/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="首次创建-推送"><a href="#首次创建-推送" class="headerlink" title="首次创建 &#x2F; 推送"></a>首次创建 &#x2F; 推送</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首次创建新的存储库</span></span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main # 与远程仓库中的分支对应</span><br><span class="line">git remote add origin https://github.com/it-kay/234324.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从命令行中推送到现有的存储库</span></span><br><span class="line">git remote add origin https://github.com/it-kay/234324.git</span><br><span class="line">git branch -M main # 与远程仓库中的分支对应</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



<h3 id="删除远程库中指定文件"><a href="#删除远程库中指定文件" class="headerlink" title="删除远程库中指定文件"></a>删除远程库中指定文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached a/2.txt //删除a目录下的2.txt文件   删除a目录git rm -r --cached a</span><br><span class="line">git commit -m &quot;删除a目录下的2.txt文件&quot; </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><img src="/public/image/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/weiyunsuan.png" alt="weiyunsuan"></p>
<p><strong>位运算时需要明确知道的事</strong></p>
<ul>
<li>操作数的大小（占用的内存大小）</li>
<li>操作数是正数还是负数（符号位，数据表示）</li>
<li>不同类型的操作数先自动对齐再进行位运算（补符号位）</li>
</ul>
<blockquote>
<p>对于无符号整数，右侧新增的位将用0填充；而对于有符号整数，这取决于编译器和机器的实现（大多数现代编译器在有符号整数右移时，会在左侧新增的位填充符号位，即正数填充0，负数填充1，这被称为算术右移）。</p>
</blockquote>
<ul>
<li>正数符号位为0，右移运算时，高位补0，低位移除</li>
<li>负数符号位为1，右移运算时，高位补1，低位移除</li>
<li>左移运算时，最高为移除，低位补0</li>
<li>最高位的具体位置，由数据类型决定</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="应用程序的运行"><a href="#应用程序的运行" class="headerlink" title="应用程序的运行"></a>应用程序的运行</h2><p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/yinyongcxu%E7%9A%84yunxing.png" alt="yinyongcxu的yunxing"></p>
<blockquote>
<p>用户双击 App 这一操作会被 os 所感知到；os 会根据文件名，将对应的 App 加载到内存中；加载到内存之后便会寻找去 main() 函数并将其调用；当 main() 函数运行完成之后 return 会向操作系统返回一个值；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Word\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">122</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Press any key to continue . . .</span></span><br><span class="line"><span class="comment">// Word</span></span><br><span class="line"><span class="comment">// Press any key to continue . . .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，system 函数是用来执行外部命令的，如 Linux 下的 ls 等等</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Word\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">122</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C:\Users\kay\Desktop\workspace&gt;a.exe</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">Word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C:\Users\kay\Desktop\workspace&gt;echo %ERRORLEVEL%</span></span><br><span class="line"><span class="comment">122</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>powershell 下可以通过 %ERRORLEVEL% 环境变量来获取上一个执行命令的退出状态。这是我们看上当前返回的数值确实是 return 中返回的数值，这则可证明：在 C 语言程序中，main 函数是程序的入口点，当程序执行完毕时，它会通过 return 语句返回一个值给操作系统。这个返回值通常用于表示程序的执行状态或结果。</p>
</blockquote>
<h2 id="函数定义与函数调用"><a href="#函数定义与函数调用" class="headerlink" title="函数定义与函数调用"></a>函数定义与函数调用</h2><ul>
<li>函数在被调用前必须完整定义</li>
<li>函数可以先被声明，再被定义<ul>
<li>声明时，必须给出函数三要素（函数名，参数列表，返回值类型）</li>
<li>定义时，必须完整给出函数体定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> || i % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到n之间所有能被7或者被9整除的数字的和: %d&quot;</span>, sum);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一题：键入长度 n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    sum(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时在 main 函数中使用 sum 函数并不需要显示的进行函数声明；</p>
<p>因为在同一个源文件中，如果函数的定义（即函数体）出现在对该函数的调用之前，那么编译器在编译到调用点时已经知道函数的存在和签名，因此不需要额外的函数声明。</p>
<p>当 C 文件被加载到内存中时候，他会从上往下去找 main 函数，再找到 main 函数之前他会先加载到 sum 函数，所以在 main 函数中进行使用时无需再次进行声明；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一题：键入长度 n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>; <span class="comment">//	void sum(int);</span></span><br><span class="line">    sum(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> || i % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到n之间所有能被7或者被9整除的数字的和: %d&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在同一个源文件中，如果你的函数调用出现在函数定义之前，你也需要在使用函数之前提供函数的声明，以便编译器知道函数的存在、返回类型以及它接受的参数。</p>
</blockquote>
<blockquote>
<p>声明时 void sum(int); 与 void sum(int a); 二者的区别</p>
<p>在C语言中，函数声明的<code>void sum(int);</code>和<code>void sum(int a);</code>在大多数情况下被视为等价的，二者并无区别；但它们在上下文和用途上略有不同，主要区别在于它们是如何被解释的。</p>
<p>void sum(int);</p>
<p>这是C语言中标准的函数声明方式。它声明了一个名为<code>sum</code>的函数，该函数接受一个<code>int</code>类型的参数，但在这个声明中并没有为这个参数命名。这种声明方式通常用于头文件中，或者在你只想声明函数的存在而不关心参数具体名称时。由于参数没有具体名称，这个声明不会为参数分配存储空间或进行任何操作，它仅仅是告诉编译器<code>sum</code>是一个函数，接受一个<code>int</code>类型的参数，并返回一个<code>void</code>（即不返回任何值）。</p>
<p>void sum(int a); </p>
<p>它同样声明了一个名为<code>sum</code>的函数，该函数接受一个<code>int</code>类型的参数，并将其命名为<code>a</code>。然而，这种命名方式主要出现在函数定义中，即你实际编写函数体时。在函数声明中（特别是头文件中），虽然可以这样做，但它实际上并不为外部代码提供关于参数名称的任何有用信息，因为外部代码调用这个函数时不会使用到参数名<code>a</code>。此外，如果这个函数声明出现在多个地方（如头文件中），而每个声明中参数的名称不同，这可能会引起混淆，尽管从技术上讲这是合法的;<code>a</code>仅仅是一个占位符，用于说明函数接收一个<code>int</code>类型的参数。它本身并不在栈上分配空间或执行任何操作。</p>
</blockquote>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在 C 语言如果想要定义无参函数则需要以下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">==========================================================</span><br><span class="line"><span class="type">void</span> sum() &#123;	<span class="comment">// 这种定义表示可接受任意类型、任意多个的参数</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这三种这种调用在编译时不会进行报错</span></span><br><span class="line">    sum(<span class="number">1</span>);</span><br><span class="line">    sum();</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><ul>
<li>可以在定义函数时使用数组形参（如：int f(int a [5])）<ul>
<li>数组形参需要使用<strong>同类型数组</strong>作为参数</li>
<li>在 C 语言中，<strong>数组作为函数参数传递时大小信息丢失</strong></li>
<li>在函数内部修改数组形参，将影响数组实参</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>])</span> &#123;	<span class="comment">// 也可以写成 int a[]</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(a); <span class="comment">// &#x27;strlen&#x27; makes pointer from integer without a cast [-Wint-conversion]</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arry1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arry2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 此处并不会报错，因为数组作为函数参数传递时大小信息丢失，他不关心数组参数的个数；</span></span><br><span class="line">    <span class="comment">// 对于数组参数来说，是将数组本身传递到了函数内部；</span></span><br><span class="line">    demo(arry1);</span><br><span class="line">    demo(arry2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arry1[0] = %d\n&quot;</span>, arry1[<span class="number">0</span>]); <span class="comment">// arry1[0] = 50</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arry2[0] = %d&quot;</span>, arry2[<span class="number">0</span>]); <span class="comment">// arry2[0] = 50</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数组参数时如何获取<strong>数组的大小</strong>信息? 将数组的大小也作为参数，传递给函数;</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归函数</strong></p>
<ul>
<li>函数体中存在<strong>自我调用的函数</strong></li>
<li>递归函数<strong>必须有递归出口</strong>（边界条件）</li>
<li>函数的无限递归将导致程序崩溃</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多文件程序设计</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="多文件之间的互相访问"><a href="#多文件之间的互相访问" class="headerlink" title="多文件之间的互相访问"></a>多文件之间的互相访问</h2><ul>
<li><p>每个文件可以定义功能接口（可被其他文件访问的函数或数据）</p>
<ul>
<li>源文件：代码实现文件，后缀 .c</li>
<li>头文件：源文件的接口定义文件，后缀为 .h</li>
</ul>
</li>
<li><p>当需要使用其他文件提供的功能时，包含对应的头文件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;header.h&gt;</span> <span class="comment">// 在编译系统文件中查找头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;header.h&quot;</span> <span class="comment">// 先查找当前工程文件夹，再查找编译系统文件夹</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>a.c 如果想要访问 b.c 中的代码：</p>
<p>b.c 将对应的代码声明在 b.h 头文件中</p>
<p>a.c 引入 b.h 头文件，即可使用对应的代码</p>
</blockquote>
<p><strong>多文件程序设计的一些原则</strong></p>
<ul>
<li>头文件中只做函数声明和变量声明（<strong>不做具体定义</strong>）</li>
<li>头文件中可以定义数据类型（typedef，struct，union，enum）</li>
<li>根据具体实现，一个头文件可以对应多个源文件（多数情况一对一）</li>
<li>不要使用 #include 语句包含源文件</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p><strong>普通全局变量</strong></p>
<ul>
<li>源文件中定义的全局变量可在所有其他源文件中使用</li>
<li>可使用 extern 关键字在头文件中进行声明，并在其他文件中使用</li>
</ul>
<p><strong>静态全局变量</strong></p>
<ul>
<li>static 修饰的全局变量只能在当前源文件中使用</li>
<li>无法通过 extern 关键字声明，在其他文件中使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> f_var; <span class="comment">// 只会有 WARNING 因为语法上是合法的，但记住 f_var 被 static 所修饰只能在本身所在的源文件中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// head.c</span></span><br><span class="line"><span class="type">int</span> g_var = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f_var = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>函数声明语句默认自带 extern 关键字修饰</li>
<li>类型定义必须在头文件中，<strong>仅类型声明无法创建变量</strong></li>
<li>静态全局变量<ul>
<li>生命期为程序运行期</li>
<li>作用域仅在定义的文件中</li>
<li>无法直接在其他文件中使用</li>
</ul>
</li>
<li>static 关键字可使函数具备<strong>文件作用域</strong>（静态函数）</li>
<li>静态函数<strong>无法</strong>在其它文件中被调用</li>
<li>函数设计时需要考虑是否在其他文件中使用</li>
</ul>
<h2 id="多个-c-文件互相调用再不通过-h-文件的情况下"><a href="#多个-c-文件互相调用再不通过-h-文件的情况下" class="headerlink" title="多个 c 文件互相调用再不通过 .h 文件的情况下"></a>多个 c 文件互相调用再不通过 .h 文件的情况下</h2><p>在 C 语言中，两个 <code>.c</code> 文件之间可以互相调用对方的函数或变量，但这通常是通过<strong>声明</strong>的方式来实现的。在不使用 <code>.h</code> 头文件的情况下，可以在一个 <code>.c</code> 文件中通过使用 <code>extern</code> 关键字声明另一个 <code>.c</code> 文件中的函数或变量。<code>extern</code> 告诉编译器某个函数或变量是在其他文件中定义的，链接器在链接时会找到对应的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量和函数</span></span><br><span class="line"><span class="type">int</span> global_variable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function_in_file1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function in file1.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">    </span><br><span class="line">file2</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1.c 中的变量和函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_variable;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">function_in_file1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function_in_file2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function in file2.c\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_variable from file1.c: %d\n&quot;</span>, global_variable);</span><br><span class="line">    function_in_file1();  <span class="comment">// 调用 file1.c 中的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，**<code>extern</code>** 关键字的作用是告诉编译器某个变量或函数的定义在别的文件中，但它并不需要知道这个变量具体在哪个文件定义。真正把两个 <code>.c</code> 文件关联起来的过程发生在<strong>链接阶段</strong>，而不是编译阶段。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>字符数组与字符串</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="字符串中的-0-元素"><a href="#字符串中的-0-元素" class="headerlink" title="字符串中的 0 元素"></a>字符串中的 0 元素</h2><ul>
<li>整数 0 即字符串中的 0 元素（char 是最小的整形）</li>
<li>0 元素对应的字符为 ‘\0’（转义字符）</li>
<li>‘0’ 与 ‘\0’ 不同，表示一个非 0 值，对应的整数为 48</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\0&#x27;</span>);	<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;0&#x27;</span>);	<span class="comment">// 48</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串变量-字符数组"><a href="#字符串变量-字符数组" class="headerlink" title="字符串变量-字符数组"></a>字符串变量-字符数组</h2><ul>
<li>C语言中通过字符数组定义字符串</li>
<li>当字符串中存在 0 元素时，可当作字符串使用</li>
<li>字符数组中的 0 元素表示了一个字符串的结束</li>
<li>字符数组中的元素，不一定是字符串中的元素<ul>
<li>这里指的是 ‘\0’</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ss[] = &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 此处 ss 是一个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);	<span class="comment">// D.T.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用字符串常量进行初始化</li>
<li>字符串长度 小于 字符数组大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> dt[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> name[] = &#123;<span class="string">&quot;D.T.Software&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> ds = <span class="keyword">sizeof</span>(dt);</span><br><span class="line"><span class="type">int</span> ns = <span class="keyword">sizeof</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dt = %s\n&quot;</span>, dt);	<span class="comment">// abcd</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, name);	<span class="comment">// D.T.SoftWare</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dt size = %s\n&quot;</span>, ds);	<span class="comment">// 5	字符串长度比字符数组少了一个 \0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name size = %s\n&quot;</span>, ns);	<span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ds; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dt[i]);	<span class="comment">// 97 98 99 100 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个字符数组不一定是一个字符串</li>
<li>而一个字符串一定是一个字符数组</li>
</ul>
<h2 id="string-h-字符串工具包"><a href="#string-h-字符串工具包" class="headerlink" title="string.h 字符串工具包"></a>string.h 字符串工具包</h2><ul>
<li>strlen(s) -&gt; 获取字符串的长度</li>
<li>strcpy(s1, s2) -&gt; 将 s2 中的字符复制到 s1，s1 &lt;- s2</li>
<li>strcat(s1, s2) -&gt; 将 s2 追加到 s1 后面，s1 &lt;- s1 + s2</li>
<li>strcmp(s1, s2) -&gt; 比较 s1 和 s2 是否相等，相等为 0</li>
</ul>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><ul>
<li>字符串常量的本质是字符数组，字符数组大小为 字符串长度 + 1</li>
<li>使用字符串工具进行字符串赋值时<ul>
<li>必须保证存储赋值结果的字符串足够大（防止越界）</li>
<li>必须保证参与赋值的字符串必须合法（字符数组存在 0 元素）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常量</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>常量是相对变量而言的一种程序元素</li>
<li>其特点为：<ul>
<li>在<strong>编辑时</strong>确定其值，一旦确定无法改变</li>
</ul>
</li>
</ul>
<h3 id="C语言中的常量类型"><a href="#C语言中的常量类型" class="headerlink" title="C语言中的常量类型"></a>C语言中的常量类型</h3><ul>
<li>字面量<ul>
<li>直接表示值含义的符号，如：5, ‘a’, “kay”</li>
</ul>
</li>
<li>宏常量（符号化的字面量）<ul>
<li>通过 #define 定义，间接表示值的符号，如：#defiine FIV -&gt; 5.5</li>
</ul>
</li>
<li>枚举常量<ul>
<li>通过 enum 定义，间接表示值的符号，如：First -&gt; 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;Kay&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MyValue 0.05f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举常量：</span></span><br><span class="line"><span class="comment">// 枚举常量只能是整数</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ThirdValue = <span class="number">333</span>,</span><br><span class="line">    FourthValue = <span class="number">444</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ThirdValue = %d\n&quot;</span>, ThirdValue);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常量无法作为左值使用：</p>
<p>ThirdValue &#x3D; 100; &#x2F;&#x2F; Error</p>
</blockquote>
<h3 id="C语言中的只读变量"><a href="#C语言中的只读变量" class="headerlink" title="C语言中的只读变量"></a>C语言中的只读变量</h3><ul>
<li>C 语言中提供 const 关键字，<strong>用于修饰一个变量</strong></li>
<li>被 const 修饰的变量<strong>只能作为右值使用</strong><ul>
<li>无法直接通过赋值操作符改变 const 变量的值</li>
<li>const 修饰的变量并不是真正意义上的常量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">222</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>宏</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AE%8F/</url>
    <content><![CDATA[<h2 id="C-语言中函数的”缺陷”"><a href="#C-语言中函数的”缺陷”" class="headerlink" title="C 语言中函数的”缺陷”"></a>C 语言中函数的”缺陷”</h2><p>实参和形参之间仅仅是值传递，因此，函数中无法直接改变实参。</p>
<h2 id="函数”缺陷“的补充"><a href="#函数”缺陷“的补充" class="headerlink" title="函数”缺陷“的补充"></a>函数”缺陷“的补充</h2><ul>
<li>宏是 C 语言中代码复用的补充方式</li>
<li>宏定义语法：#define MACRO(param) code_segment</li>
<li>宏使用语法：MARCRO(num);</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(a, b) a += b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> a, b;</span><br><span class="line">   a = <span class="number">5</span>;</span><br><span class="line">   b = <span class="number">6</span>;</span><br><span class="line">   sum(a, b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b); <span class="comment">// a = 11, b = 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宏可以直接改变传入的参数的值；</p>
</blockquote>
<h2 id="宏与函数的不同"><a href="#宏与函数的不同" class="headerlink" title="宏与函数的不同"></a>宏与函数的不同</h2><ul>
<li>宏不是函数，使用宏没有函数调用的过程(没有函数的跳转、函数体的执行、函数的返回)</li>
<li>函数调用先传递参数值，然后跳转指定函数体，最后返回</li>
<li><strong>使用宏只是单纯”单纯复制粘贴“</strong>（也可以叫宏展开），然后替换参数</li>
<li>同一个宏，无论调用多少次，都执行相同的函数体代码</li>
<li>同一个宏，<strong>每次使用都会”复制粘贴“相同的代码</strong></li>
</ul>
<h2 id="编译器组成简介"><a href="#编译器组成简介" class="headerlink" title="编译器组成简介"></a>编译器组成简介</h2><ol>
<li>预处理模块：处理所有宏以及 # 开头的语句（复制粘贴替换）</li>
<li>编译模块：将 C 程序翻译成二进制程序</li>
<li>链接模块：将二进制程序组合成可执行程序</li>
</ol>
<h2 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h2><p><strong>#define NAME Value</strong></p>
<ul>
<li>预处理模块将代码中出现的 NAME 标识符替换为 Value</li>
<li>宏常量的本质就是字面量</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针：一种特殊的变量"><a href="#指针：一种特殊的变量" class="headerlink" title="指针：一种特殊的变量"></a>指针：一种特殊的变量</h2><p><strong>指针是 C 语言中的变量</strong></p>
<ul>
<li>因为是变量，所以用于保存具体值</li>
<li>特殊之处，指针保存的值是内存中的地址</li>
<li>内存地址是什么？<ul>
<li>内存是计算机中的存储部件，每个存储单元都有固定唯一的编号</li>
<li>内存中存储单元的编号即内存地址</li>
</ul>
</li>
</ul>
<h2 id="内存示例"><a href="#内存示例" class="headerlink" title="内存示例"></a>内存示例</h2><p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/neicunshili.png" alt="neicunshili"></p>
<h2 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h2><ul>
<li>C 语言中通过 &amp; 操作符获取程序元素的地址</li>
<li>&amp; 可获取变量，数组，函数的起始地址</li>
<li>内存地址的本质是一个无符号整数（4 &#x2F; 8 个字节）</li>
</ul>
<blockquote>
<p>注意：只有通过 内存地址 + 长度 才能确定一个变量中保存的值</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>指针定义语法：type * pointer;</strong></p>
<ul>
<li>type-数据类型，决定访问内存时的长度</li>
<li>*-标志，意味着定义一个指针变量</li>
<li>point-变量名，遵循 C 语言命名规则</li>
</ul>
<p><em><em>指针内存访问：</em> pointer</em>*</p>
<ul>
<li>指针访问操作符（*）作用于指针变量即可访问内存数据（解引用）</li>
<li>指针的类型决定通过地址访问内存时的长度范围</li>
<li>指针的类型统一占用 4 字节或 8 字节<ul>
<li>sizeof(type *) &#x3D;&#x3D; 4 or sizeof(type *) &#x3D;&#x3D; 8</li>
</ul>
</li>
</ul>
<h2 id="指针定义的规定"><a href="#指针定义的规定" class="headerlink" title="指针定义的规定"></a>指针定义的规定</h2><ul>
<li>Type * 类型的指针只能保存 Type 类型变量的地址</li>
<li>禁止不同类型的指针相互赋值</li>
<li>禁止将普通数值当作地址赋值给指针</li>
</ul>
<blockquote>
<p>指针保存的地址必须是有效地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* pi = &amp;f; <span class="comment">// warning</span></span><br><span class="line">    <span class="type">float</span>* pf = &amp;f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi = %p, pf = %p\n&quot;</span>, pi, pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pi = %d, *pf = %f\n&quot;</span>, *pi, *pf);</span><br><span class="line"></span><br><span class="line">    pi = i; <span class="comment">//  warning</span></span><br><span class="line"></span><br><span class="line">    *pi = <span class="number">1000</span>; <span class="comment">// OOPS 程序会崩溃掉</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi = %p, *pi = %d\n&quot;</span>, pi, *pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pi = 00000026B29FF7E4, pf = 00000026B29FF7E4</span></span><br><span class="line"><span class="comment">*pi = 1092616192, *pf = 10.000000</span></span><br><span class="line"><span class="comment">崩溃了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行指针赋值时，一定要注意类型的区别，不如会造成各种奇快的错误，这些错误编译器可能并不会进行提示或者警告；</p>
</blockquote>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul>
<li>数组名可以看作一个指针，代表数组中 0 元素的地址</li>
<li>当指针指向数组元素时，可进行指针运算（指针移动）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line">p = p + <span class="number">1</span> <span class="comment">//指向数组中第二个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="深入理解指针数组"><a href="#深入理解指针数组" class="headerlink" title="深入理解指针数组"></a>深入理解指针数组</h3><ul>
<li>&amp;a 与 a 在数值上是相同的，但是意义上不同(int a[] &#x3D; {1, 2, 3, 4, 5};)</li>
<li>&amp;a 代表数组地址，类型为：int (*) [5]</li>
<li>a 代表数组 0 号元素地址，类型为：int *</li>
<li>指向数组的指针：int (*pName) [5] &#x3D; &a;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa) [<span class="number">5</span>] = &amp;a; <span class="comment">// int (*pa) [] = &amp;a;</span></span><br><span class="line">    <span class="type">int</span>* p = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, pa, p); <span class="comment">//00000061F43FFDA0, 00000061F43FFDA0</span></span><br><span class="line">    </span><br><span class="line">    pa = p <span class="comment">// WARNING 类型不一致不能相互赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组名不是指针，只是代表了 0 号元素的地址，因此，可以当作指针使用</p>
<p>int* p &#x3D; a; 是一个声明，其中 p 是一个指向整数的指针。由于数组名 a 在这个上下文中会衰减为指向其首元素（即 a[0]）的指针，因此这个赋值是合法的，并且 p 现在存储了 &#96;a[0] 的地址。</p>
</blockquote>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><ul>
<li>C 语言中的<strong>字符串常量</strong>是 char * 类型，一种指针类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;kay.wang&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;kay.wang&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00007FF67FE74000</span></span><br><span class="line"><span class="comment">00007FF67FE74000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针移动"><a href="#指针移动" class="headerlink" title="指针移动"></a>指针移动</h2><p>*<em>int v &#x3D; <em>p++</em></em></p>
<ul>
<li>指针访问操作符（*）和自增运算操作符（++）优先级相同</li>
<li>所以，先从 p 指向内存中取值，然后 p 在进行移动<ul>
<li>int v &#x3D; *p; p++;</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first = %c\n&quot;</span>, *<span class="string">&quot;D.T.software&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;D.T.software&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) <span class="comment">// 字符串转为 char 数组后最有一个元素为 \0 也就是 0 元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *s++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first = D</span></span><br><span class="line"><span class="comment">D.T.software</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><ul>
<li>函数的本质是一段内存中的代码（占用一片连续内存）</li>
<li>函数拥有类型，函数类型由<strong>返回类型</strong>和<strong>参数类型列表</strong>组成</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int sum(int n);</td>
<td align="center">int(int)</td>
</tr>
<tr>
<td align="center">void swap(int* pa, int* pb);</td>
<td align="center">void(int*, int*)</td>
</tr>
<tr>
<td align="center">void g(void);</td>
<td align="center">void(v0id)</td>
</tr>
</tbody></table>
<ul>
<li>函数名就是函数体代码的起始地址（函数入口地址）</li>
<li>通过函数名调用函数，本质为指定具体地址的跳转执行（跳转到指定地址处执行）</li>
<li>因此，可定义指针，保存函数入口地址</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>(Type func(Type1 a, Type2 b))</p>
<ul>
<li>函数名即函数入口地址，类型为 Type (*) (type1, type2)</li>
<li>对于 func 函数，&amp;func 与 func 数值相同，意义相同</li>
<li>指向函数的指针：Type (*pFunc)  （Type1, Type2) &#x3D; func<ul>
<li>对于函数来说，函数名就是地址，所以加不加 &amp; 都是一样的，可以直接写 func</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a * b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*pFunc)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pFunc(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pFunc)(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    pFunc = &amp;mul;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pFunc(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pFunc)(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将函数指针作为参数</strong></p>
<ul>
<li>函数指针本质还是指针（变量，保存内存地址）</li>
<li>可定义函数指针参数，<strong>使用相同的代码实现不同的功能</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span>(*cal) (<span class="type">int</span>, <span class="type">int</span>))</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ret = cal(ret, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>函数指针只是单纯的保存函数的入口地址</li>
<li>因此，<ul>
<li>只能通过函数指针调用目标函数</li>
<li>不能进行指针移动（指针运算）</li>
</ul>
</li>
</ul>
<h2 id="为什么数组作为参数时，无法拿到长度信息"><a href="#为什么数组作为参数时，无法拿到长度信息" class="headerlink" title="为什么数组作为参数时，无法拿到长度信息"></a>为什么数组作为参数时，无法拿到长度信息</h2><p>当数组作为参数时，函数的数组形参退化为指针！，因此，不包含数组实参的长度信息；</p>
<p>使用数组名调用时，传递的是 0 号元素的地址；</p>
<p>void func (int a[]) &lt;–&gt; void func(int* a)</p>
<p>void func (int a[1]) &lt;–&gt;</p>
<p>void func (int a[10]) &lt;–&gt;</p>
<p>void func (int a[100]) &lt;–&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;demo: sizeof(arr) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));    <span class="comment">// 32位系统为 4 64位系统为 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += *arr++;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int v = *a++; // Error</span></span><br><span class="line">    </span><br><span class="line">    demo(a, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么 int v &#x3D; *a++; 而 demo 函数中却可以呢，因为当数组作为参数时，函数的数组形参退化为指针！</p>
<p>让我们详细分析一下：</p>
<ol>
<li><strong>数组名的性质</strong>：数组名在 C 语言中是一个常量表达式，表示数组的首元素地址。尽管它经常被当作指针来使用，但它本身并不是指针变量。你不能改变一个数组名来指向数组的下一个元素或另一个数组。</li>
<li><strong>++ 操作符的用途</strong>：<code>++</code> 操作符用于将变量的值增加 1。对于整数类型，它简单地增加变量的值；对于指针，它增加指针所指向地址的偏移量（通常是增加指针指向类型的大小）。然而，这两种情况都要求操作数是一个可修改的左值。</li>
<li><strong>数组名不是左值</strong>：在 C 语言中，左值是指可以出现在赋值语句左边的表达式，意味着它可以被赋值。数组名虽然在某种程度上可以表示地址，但它并不是一个可修改的左值。你不能将一个新的值赋给数组名来改变它的地址。</li>
<li><strong>类型不匹配</strong>：即使我们忽略了数组名不是左值的事实，<code>a++</code> 在类型上也是不合法的。因为 <code>a</code>（在表达式中）被视为指向其首元素的指针，但 <code>a++</code> 的结果（即递增后的值）将不再是一个数组类型，而是一个指向下一个元素的指针。然而，由于 <code>a</code> 本身不是左值，这种递增操作在语法上就是不允许的。</li>
</ol>
<p>综上所述，<code>int</code> 类型的数组 <code>a</code> 不能执行 <code>a++</code> 这样的操作，因为数组名不是一个可修改的左值，而且 <code>++</code> 操作符不适用于数组名。如果你想要遍历数组中的元素，你应该使用指针或数组索引来访问每个元素。例如：</p>
</blockquote>
<h2 id="指针与堆空间"><a href="#指针与堆空间" class="headerlink" title="指针与堆空间"></a>指针与堆空间</h2><p><strong>堆空间的本质</strong></p>
<ul>
<li>备用的”内存仓库”，以字节为单位预留的可用内存</li>
<li>程序可在需要时，从”仓库“中申请使用内存(动态的借用)</li>
<li>当不需要再使用申请的内存时，需要及时归还（动态的归还）</li>
</ul>
<p><strong>void</strong>*</p>
<ul>
<li>void 类型是<strong>基础类型</strong>，对应的指针类型为 void*</li>
<li>void* 是指针类型，其指针变量能够保存地址（可以保存任意类型的内存地址,也可以转化为其他任意类型的指针）</li>
<li>通过 void* 的指针<strong>无法获取内存长中的数据</strong>（无长度信息）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> f= <span class="number">2.0f</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p = &amp;i;</span><br><span class="line">    p = &amp;f;</span><br><span class="line">    p = &amp;d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%f\n&quot;, *p); // Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆空间的使用"><a href="#堆空间的使用" class="headerlink" title="堆空间的使用"></a>堆空间的使用</h3><ul>
<li>工具箱：stdlib.h</li>
<li>申请：void* malloc(unsigned bytes)</li>
<li>归还：void free(void* p)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆空间中申请 4 个字节用来当作 int 类型的变量使用</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 判断是否申请到了堆空间</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果申请失败 p 为 0； 即：空值</span></span><br><span class="line">        *p = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 100</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>用于保存指向指针的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Type v;</span><br><span class="line">Type* pv = &amp;v;</span><br><span class="line">Type** ppv = &amp;pv;</span><br><span class="line">Type*** pppv = &amp;ppv;</span><br><span class="line">==========================</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 多级数组的指针该如何表示</span></span><br><span class="line"><span class="comment"> C 语言中没有多级数组，所谓二级数组，就是一维数组的数组，即：数组中的元素是一维数组！！;以此类推</span></span><br><span class="line"><span class="comment"> /*</span></span><br></pre></td></tr></table></figure>

<p>因此：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/erweishuzuzhizhen.png" alt="erweishuzuzhizhen"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流程语句</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li>switch 仅能用于离散变量或值（整数值）</li>
<li>case 是分支入口，匹配成功后执行 case下的语句</li>
<li>当语句全部执行后，需要使用 break跳出执行分支</li>
<li>default 分支不是必须的（类似于 else 不是必须的）</li>
</ul>
<blockquote>
<p><strong>离散变量</strong>是指其取值限定在某个特定、可数的集合中的变量；这些取值通常是整数。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>辅助语句</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E8%BE%85%E5%8A%A9%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="C语言中的注释"><a href="#C语言中的注释" class="headerlink" title="C语言中的注释"></a>C语言中的注释</h2><ul>
<li>注释是<strong>帮助理解程序</strong>而编写的文本</li>
<li>注释本身对程序功能无任何贡献</li>
<li>注释分为<strong>单行注释</strong>和<strong>多行注释</strong><ul>
<li>注意：单行注释不一定被编译器支持</li>
</ul>
</li>
</ul>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul>
<li>逗号（,）优先级最低，逗号表达式可以配合括号使用</li>
<li>逗号表达式的意义是<strong>将多个语句连接为一个语句</strong></li>
<li>逗号表达式<strong>从左向右</strong>开始执行语句</li>
<li>逗号表达式的值就是<strong>最右边语句的值</strong></li>
</ul>
<h2 id="，–"><a href="#，–" class="headerlink" title="++，–"></a>++，–</h2><ul>
<li>不要在一个表达式中混合四则运算与自增（自减）运算<ul>
<li>i &#x3D; i++ * ++i;</li>
</ul>
</li>
</ul>
<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>程序世界的“破坏者”</p>
<ul>
<li>goto 是 C 语言中的一个关键字，用于无条件暴力跳转</li>
<li>goto 的跳转位置由标签指定（具体指定某行代码）</li>
<li>标签就是一个 C 语言中的合法命名，并以（:）结束</li>
<li>语法：goto LABEL;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> LABEL;</span><br><span class="line">c = <span class="number">2</span>;</span><br><span class="line">LABEL:</span><br><span class="line">	print(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">===========================================</span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a + c &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, c = %d\n&quot;</span>, a, c);</span><br><span class="line">        <span class="keyword">goto</span> ELSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ELSE: <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, c, a + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以称为破坏者是因为他破坏了程序的三大基本结构：</p>
<p>顺序、选择、循环</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与变量</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="打印语句"><a href="#打印语句" class="headerlink" title="打印语句"></a>打印语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span>);		<span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">2</span>);		<span class="comment">// 0.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;2;);	// 50</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用了%f来输出一个浮点数，但传入的是一个整数  2。在大多数实现中，整数会被隐式转换为浮点数（即 2.000000）；但是，由于 <code>printf</code> 的行为可能依赖于具体的编译器和运行时环境，有时可能看到不同的输出（比如由于浮点数表示的精度问题）。</p>
<p>字符 ‘2’ 的 ASCII 值是 50</p>
</blockquote>
<h2 id="字面量的类型"><a href="#字面量的类型" class="headerlink" title="字面量的类型"></a>字面量的类型</h2><p>程序中的数值（字面量）也有类型：默认类型或者指定类型</p>
<ul>
<li>默认类型：2 为 int，0.2 为 double， ‘c’ 为 char</li>
<li>指定类型：0.2f 为 float（后缀 f 表示 float）</li>
</ul>
<blockquote>
<p>C 语言是类型严格的语言，字面量也有类型，使用字面量时需要考虑类型；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">2</span>; <span class="comment">// 字面量 2 的类型被转换为 short</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">2</span>; <span class="comment">// 字面量 2 的类型会被转为 double</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> n = <span class="number">-1l</span>; <span class="comment">// 表示该字面量为 lang 类型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nl = <span class="number">2147483648u</span>; <span class="comment">// 表示该字面量为无符号类型</span></span><br></pre></td></tr></table></figure>

<h2 id="变量之间的赋值"><a href="#变量之间的赋值" class="headerlink" title="变量之间的赋值"></a>变量之间的赋值</h2><ul>
<li><p>大类型赋值给小类型时：可能会发生<strong>溢出</strong></p>
<ul>
<li>当数值在小类型范围内 -&gt; 赋值成功</li>
<li>当数值超过小类型的范围 -&gt; 发生溢出</li>
</ul>
</li>
<li><p>小类型可以安全的赋值给大类型</p>
</li>
<li><p>浮点类型赋值给整形，会发生<strong>截断</strong>（小数部分丢失）</p>
</li>
<li><p>整数赋值给浮点类型，能够完成（会在后面补 0）</p>
</li>
</ul>
<h2 id="signed-与-unsigned"><a href="#signed-与-unsigned" class="headerlink" title="signed 与 unsigned"></a>signed 与 unsigned</h2><p><strong>有符号与无符号</strong></p>
<ul>
<li>signed int<ul>
<li>范围：-2147483648 ～ 2147483647</li>
</ul>
</li>
<li>unsigned int<ul>
<li>范围：0 ～ 4294967295</li>
</ul>
</li>
</ul>
<p><strong>扩展</strong></p>
<ul>
<li>signed 和 unsigned 可与 char 和 short 组合使用<ul>
<li>signed char，unsigned char</li>
<li>signed short，unsigned short</li>
</ul>
</li>
<li>程序中可能出现的关于 int 的缩写<ul>
<li>signed &lt;-&gt; signed int</li>
<li>unsigned &lt;-&gt; unsigned int</li>
</ul>
</li>
</ul>
<blockquote>
<p>打印无符号整形时候要使用 %u 而不是%d，%d 会依旧按照有符号进行操作；</p>
</blockquote>
<p><strong>类型本身是不会占用内存的，只有变量才会占用内存</strong></p>
<h2 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h2><p>功能：用于获取类型或者变量所占用的内存大小（字节）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="keyword">sizeof</span>(<span class="type">short</span>); <span class="comment">// 使用 shrot 类型所表示的字节大小来初始化 s</span></span><br><span class="line">    <span class="type">int</span> t = <span class="keyword">sizeof</span> s; <span class="comment">// 使用变量 s 所作占用的字节大小来初始化 t</span></span><br><span class="line">    <span class="type">int</span> u = <span class="keyword">sizeof</span>(s); <span class="comment">// 同上：使用变量 s 所作占用的字节大小来初始化 t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><ul>
<li>long 在使用不同编译器时，<strong>可能占用的内存不同</strong></li>
<li>long 通常占用 4 个字节，也可能占用 8 个字节</li>
<li>long long 表示整形，<strong>固定占用 8 个字节</strong></li>
<li>long long 是 long long int 的缩写形式</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><ul>
<li>浮点类型（float &amp; double）对数据的表示是不准确的</li>
<li>整数类型（char，short，int，long）对数据的表示是准确的</li>
<li>浮点类型与整数类型在内存中对数据的表示法完全不同</li>
</ul>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><strong>C 语言中变量的分类</strong></p>
<ul>
<li>局部变量<ul>
<li>函数内部定义的变量（隶属于当前函数）</li>
<li>只能在当前函数中进行使用</li>
</ul>
</li>
<li>全局变量<ul>
<li>全局范围内的函数（不特定隶属于任意一个函数）</li>
<li>可以在任意函数中访问使用</li>
</ul>
</li>
</ul>
<p><strong>同名变量的问题</strong></p>
<ul>
<li>不同函数中的局部变量可以同名（不会产生冲突）</li>
<li>全局变量不能同名（会产生冲突）</li>
<li>当局部变量和全局变量同名时，优先使用局部变量</li>
</ul>
<p><strong>全局变量的作用域</strong></p>
<ul>
<li><p>全局作用域：可以在程序的各个角落访问并使用（不限于当前文件中）</p>
</li>
<li><p>文件作用域：只能在当前代码文件中访问并使用</p>
</li>
<li><p>全局变量的作用域可能被局部变量覆盖（同名局部变量）</p>
</li>
<li><p>工程开发中，全局变量通常以 g_ 作为前缀命名（工程约定）</p>
</li>
</ul>
<h2 id="不同变量的物理存储区域"><a href="#不同变量的物理存储区域" class="headerlink" title="不同变量的物理存储区域"></a>不同变量的物理存储区域</h2><ul>
<li>在现代计算机系统中，物理内存被分为不同区域</li>
<li>区域不同，用途不同，不同种类的变量位于不同区域<ul>
<li>全局数据区域：存放全局变量，静态变量，<strong>其中的变量默认初始化为0</strong></li>
<li>栈空间：存储函数参数，局部变量</li>
<li>堆空间：用于动态创建变量</li>
</ul>
</li>
<li>不同变量的生命期<ul>
<li>全局数据区中的变量<ul>
<li>程序开始运行时创建，程序结束时被销毁，整个程序运行期合法可用</li>
</ul>
</li>
<li>栈空间中的变量<ul>
<li>进入作用域时创建，离开作用域时销毁（自动销毁）<ul>
<li>函数中的局部变量在函数调用返回后销毁</li>
</ul>
</li>
</ul>
</li>
<li>作用域和生命周期二者并无本质联系，只是语法层面(作用域)和二进制层面(生命周期)的两个说法</li>
</ul>
</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>static 是 C 语言中的关键字</li>
<li>static 修饰的<strong>局部变量</strong>创建于全局数据区（拥有程序生命周期）</li>
<li>static 修饰的<strong>全局变量</strong>只有文件作用域（超出对应文件外无法访问，作用域被缩小了）</li>
<li>static <strong>局部变量只会初始化一次</strong>，作用域与普通变量无异</li>
</ul>
<blockquote>
<p>对于局部变量而言，static 只是改变了它的生命周期，其本身的作用域不变</p>
</blockquote>
<h2 id="变量的声明周期"><a href="#变量的声明周期" class="headerlink" title="变量的声明周期"></a>变量的声明周期</h2><p><strong>变量的生命周期由变量的存储位置决定</strong></p>
<ul>
<li>static 将变量存储于全局数据区，默认初始化为 0</li>
<li>auto 将变量存储于栈空间，默认初始化为随机值</li>
<li>register 将变量存储于寄存器，默认初始化随机值(因为寄存器太少了，所以存储不一定成功，故实际中基本不用)</li>
</ul>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><strong>类型命名关键字(typedef)</strong></p>
<ul>
<li>C 语言中可以对类型赋予新名字</li>
<li>语法 typedef Type NewTypeName;<ul>
<li>注意：typedef 并没有创建新类型，只是创建了类型别名</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>typedef 可在函数中定义”局部类型名“</li>
<li>typedef 常用于简化类型名（如：unsigned long long）</li>
<li>typedef 定义类型名，能够以<strong>统一方式</strong>创建变量（Type var;）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float [5] 起个新名字为： FArr5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">float</span><span class="params">(FArr5)</span>[5];</span><br><span class="line"><span class="comment">// 为 int()(int, int) 起个新名字为： FArr5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(IFuncII)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef float(*FArr5)[5];</span></span><br><span class="line"><span class="comment">typedef int(*IFuncII)(int, int);</span></span><br><span class="line"><span class="comment">如何这么写的话，则：</span></span><br><span class="line"><span class="comment">FArr5 pa = &amp;g_arr;</span></span><br><span class="line"><span class="comment">IFuncII pf = add;</span></span><br><span class="line"><span class="comment">须这样写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> g_arr[<span class="number">5</span>] = &#123;<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    FArr5* pa = &amp;g_arr;</span><br><span class="line">    IFuncII* pf = add;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pf(i, i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.100000</span></span><br><span class="line"><span class="comment">0.200000</span></span><br><span class="line"><span class="comment">0.300000</span></span><br><span class="line"><span class="comment">0.000000</span></span><br><span class="line"><span class="comment">0.000000</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>是能够定义不同数据类型变量的集合类型</p>
<ul>
<li>struct 结构体变量的本质是<strong>变量的集合</strong></li>
<li>struct 结构体变量中的<strong>成员占用独立的内存</strong></li>
<li>struct 结构体可以用 typedef 赋予新类型名</li>
<li>可定义 struct 结构体类型的指针，并指向对应类型的变量</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/jiegoutiyongfa.png" alt="jiegoutiyongfa"></p>
<p><strong>深入 struct 结构体类型</strong></p>
<ul>
<li>struct 结构体类型可以先前置声明，在具体定义；<ul>
<li>struct test;</li>
</ul>
</li>
<li>前置类型声明只能用于定义指针；<ul>
<li>struct test* p</li>
</ul>
</li>
<li>类型完整定义之后才能进行变量定义</li>
<li>struct 结构体类型可以省略类型名<ul>
<li>省略类型名时，每次创建变脸必须给出完整结构体定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">g_pt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 必须先给出类型的完整定义才能创建相应类型的变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span>   </span><br><span class="line">    t.a = <span class="number">1</span>;</span><br><span class="line">    t.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    g_pt = &amp;t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct 结构体类型<strong>可以省略类型名（无名结构体类型）</strong></li>
<li>类型名省略时，<strong>每次创建变量必须给出完整结构体定义</strong></li>
<li><strong>无名结构体类型总是互不相同的类型</strong>（互不兼容）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125; v1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125; v2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125;* pv;</span><br><span class="line">    </span><br><span class="line">    v1.a = <span class="number">1</span>;</span><br><span class="line">    v1.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v2 = v1 // Error 类型不同互不兼容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pv = &amp;v1; // WARNING 类型不同互不兼容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h4><ul>
<li>现代程序设计中，内存使用的最小单位为字节（约定俗成）</li>
<li>在一些特定场合中，可将<strong>比特</strong>作为最小单位使用内存</li>
<li>结构体类型能够<strong>指定成员变量占用内存的比特位宽度</strong>（位域）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BW</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">4</span>; <span class="comment">// a 占用一个字节的 4 位款组 二进制的 1111 即：[0, 15]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>; <span class="comment">// b 占用一个字节的 2 位款组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">2</span>; <span class="comment">// c 占用一个字节的 2 位款组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BW</span> <span class="title">bw</span>;</span></span><br><span class="line">    bw.a = <span class="number">10</span>;</span><br><span class="line">    bw.b = <span class="number">1</span>; <span class="comment">// 因为大小为2bit，所以如果赋值超过2bit则会发生溢出回转</span></span><br><span class="line">    bw.c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct BW) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span>  BW));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.a = %d\n&quot;</span>, bw.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.b = %d\n&quot;</span>, bw.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.c = %d\n&quot;</span>, bw.c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(struct BW) = 1</span></span><br><span class="line"><span class="comment">bw.a = 10</span></span><br><span class="line"><span class="comment">bw.b = 1</span></span><br><span class="line"><span class="comment">bw.c = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>深入位域</strong></p>
<ul>
<li>位域成员必须是整形，默认情况下成员依次排列</li>
<li>位域成员占用的位数<strong>不能超过类型宽度</strong>（错误示例：char c : 9）</li>
<li>当存储位不足时，自动启用新存储单元<ul>
<li>char a : 7; char b : 6; 两个加起来超过了一个字节的大小，那么它将会自动启用一个新的字节来存储当前内容</li>
</ul>
</li>
<li>可以舍弃当前未使用的位，重新启用存储单元</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bits1</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> cahr a : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> cahr   : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> cahr b : <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>unsigned char : 0;</code> 这行代码，其作用主要是<strong>作为填充或对齐</strong>。当你在结构体中声明一个大小为0的位域时，它实际上不占用任何位（即，它不存在于内存布局中），但它可以影响结构体中后续位域的对齐方式。</p>
<p>a占了一个字节的前4位，b正好可以占剩下的后四位，刚刚好一个字节；但<code>unsigned char : 0;</code> 这行代码会将 a 所在字节的后四位进行占位，b 只能重新分配一个新的字节并占前四位；</p>
<ul>
<li><code>unsigned char : 0;</code>：这定义了一个大小为0的位域。在大多数上下文中，这样的位域实际上不占用任何位（即，它不会为结构体增加任何额外的内存负担），并且它的存在主要是为了可能的对齐效果或作为占位符。然而，需要注意的是，编译器如何处理这种0大小的位域可能依赖于编译器的具体实现，并且可能不会产生预期的效果。</li>
<li><code>unsigned char : 4;</code>：这定义了一个大小为4位的位域。这意味着这个位域将占用结构体中的4个位，用于存储数据。在这个例子中，由于使用了 <code>unsigned char</code> 类型（尽管在定义位域时类型主要影响解释方式，而不是实际占用的内存大小），这4个位可以用来存储从0到15（即 <code>0b0000</code> 到 <code>0b1111</code>）的整数值。</li>
</ul>
</blockquote>
<h3 id="联合体-Union"><a href="#联合体-Union" class="headerlink" title="联合体 Union"></a>联合体 Union</h3><p><strong>语法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">TypeName</span> &#123;</span></span><br><span class="line">    Type1 var1;</span><br><span class="line">    Type2 var2;</span><br><span class="line">    ...</span><br><span class="line">    TypeN varn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>union  与 struct 的不同</strong></p>
<ul>
<li>union 类型<strong>所有成员共享一段内存</strong>（所有成员起始地址相同）</li>
<li>union 类型的大小取决于成员的最大类型</li>
<li>union 类型的变量<strong>只能以第一个成员类型的有效值进行初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UT</span> <span class="title">uu</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合体中的所有成员共享一段内存，即：如果 uu.a &#x3D; 1，那么 uu.b 也等于 1；</p>
<p>union 类型的大小取决于成员的最大类型，即：uu 这个联合体的大小为 a 这个字段的大小，也就是 4 字节；</p>
<p>union 类型的变量只能以第一个成员类型的有效值进行初始化，即：union UT uu &#x3D; {0}; 0 是 a 的 int 类型；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UTest</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">UTest</span> <span class="title">t</span> =</span> &#123;<span class="number">987654321</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(union UTest) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> UTest));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t.a = %p\n&quot;</span>, &amp;t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t.f = %p\n&quot;</span>, &amp;t.f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.a = %d\n&quot;</span>, t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.f = %f\n&quot;</span>, t.f);</span><br><span class="line"></span><br><span class="line">    t.f = <span class="number">987654321.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.a = %d\n&quot;</span>, t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.f = %f\n&quot;</span>, t.f);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(union UTest) = 4</span></span><br><span class="line"><span class="comment">&amp;t.a = 0x7ffc28637ea4</span></span><br><span class="line"><span class="comment">&amp;t.f = 0x7ffc28637ea4</span></span><br><span class="line"><span class="comment">t.a = 987654321</span></span><br><span class="line"><span class="comment">t.f = 0.001697</span></span><br><span class="line"><span class="comment">t.a = 1315666339</span></span><br><span class="line"><span class="comment">t.f = 987654336.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>int 与 float 在内存中的存储方式不同，所以二者在对数据进行处理后展示的内容也是不同的；</p>
<p>浮点数的保存是不精确的，是会存在误差的；</p>
</blockquote>
<p><strong>应用-判断系统大小端</strong></p>
<ul>
<li>小端系统：<strong>低位数据</strong>存储在<strong>低地址</strong>内存中</li>
<li>大端系统：<strong>低位数据</strong>存储在<strong>高地址</strong>内存中</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/daxiaoduan.png" alt="daxiaoduan"></p>
<blockquote>
<p>将 1 填入低位，余下补 0，这就是小端系统</p>
<p>将 1 填入高位，余下补 0，这就是大端系统</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLittleEndian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> a[<span class="number">4</span>];</span><br><span class="line">    &#125; test = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    test.i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(test.a[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 返回 1 说明是小端，返回 0 则是大端</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, isLittleEndian());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><ul>
<li>enum 是 C 语言中的自定义类型关键字</li>
<li>enum 能够定义<strong>整形常量</strong>的集合类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TypeName</span> &#123;</span></span><br><span class="line">    IntConst1,</span><br><span class="line">    INtConst2,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    IntConstN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>第一个枚举常量默认值为 0</li>
<li>后续常量的值在前一起常量值的基础上加1</li>
<li>可以任意对枚举常量指定整型值（<strong>只能指定整型值</strong>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span>MON = <span class="number">1</span>, Tue, WED, THU, FRI, SAT, SUN&#125;; <span class="comment">// 1, 2, 3, ,4 ,5, 6, 7</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> &#123;</span>Spring, Summer = <span class="number">3</span>, Autumn, Winter = <span class="number">-1</span>&#125;; <span class="comment">// 0, 3, 4, -1</span></span><br><span class="line"><span class="comment">// enum Day、num Season 大小分别为 4 个字节</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C&#x2F;C++ 中，枚举类型中的每个枚举成员（如 <code>MON</code>, <code>Tue</code>, 等等）是一个<strong>编译期常量</strong>。这些常量并不需要存储在枚举类型中，它们只是用来表示某些具体的数值，通常会被替换为它们的对应值，而不是占用存储空间。</p>
<p>这些常量在编译时是已知的，并且在运行时不需要存储在内存中。<strong>它们只是简单的整数常量，编译器在需要使用这些值时会直接替换它们</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组是<strong>相同数据类型</strong>变量的<strong>有序集合</strong><ul>
<li>数组作为整体需要一个合法的命名（数组名）</li>
<li>数组中的变量没有独立命名，只有在数组中的编号</li>
<li>数组中变量的个数是固定不变的（数组大小固定）</li>
</ul>
</li>
</ul>
<p><strong>数组的内存布局</strong></p>
<ul>
<li>数组在计算机底层是<strong>一片连续的内存</strong>，用于存储数组元素</li>
<li>数组的大小字节数可以用 sizeof 获取（单位：字节）</li>
</ul>
<p><strong>计算数组的大小</strong></p>
<ul>
<li>type Name[] &#x3D; {V<sub>0</sub>, V<sub>1</sub>, V<sub>2</sub>, …, V<sub>n</sub>,} &#x2F;&#x2F; 共 n 个元素</li>
<li>sizeof(Name) &#x2F; sizeof(Name[0]); &#x2F;&#x2F; 计算结果为 n</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>数组名只能当作左值使用（可以看作是常量）</li>
<li>只能使用<strong>整形常量</strong>对数组大小进行定义<ul>
<li>某些编译器可能支持，是因为编译器本身作了优化，c语言本身是不支持的</li>
</ul>
</li>
<li>只能使用整形值作为下标访问数组元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是两个不同类型的数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 类型为：int[10]</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">// 类型为：int[5]</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    a[i] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述操作中，按理说是不符合类型的赋值规则的，因为不同类型之间进行输入传递是有可能出现问题的；</p>
<p>在上述赋值操作中，仅仅改变了 a 数组中的前五个变量，这与赋值操作的定义相违背（赋值操作指的是改变所保存的内容，这个改变是完全的改变）；</p>
<p>因此从严格意义上来说是有问题的，但并没有影响程序的运行；</p>
</blockquote>
<p><strong>二维数组</strong></p>
<ul>
<li>二维数组<strong>能且仅能</strong>让编译器自动确定<strong>第一维</strong>的大小</li>
<li>第二维大小必须显示给定，即：数组元素的类型必须正确合法</li>
<li>第一维大小自动确定的方法：（初始值个数 <strong>除以</strong> 第二维大小）<sub>向上取整</sub></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 第一维确定方法：4 / 3 = 2</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) <span class="comment">// 24 / 12 = 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你声明一个二维数组时，如 <code>int arr[M][N];</code>，这里：</p>
<ul>
<li><code>M</code> 是外层数组的大小，即这个二维数组包含多少个一维数组。</li>
<li><code>N</code> 是内层数组（即每个一维数组）的大小，也就是每个一维数组中有多少个元素。</li>
</ul>
<p>为什么需要指定第二维的大小？</p>
<ol>
<li><strong>内存分配</strong>：编译器需要知道如何为二维数组分配足够的连续内存空间。通过指定 <code>N</code>，编译器可以计算出整个二维数组需要多少字节的内存（<code>M * N * sizeof(int)</code> 对于 <code>int</code> 类型的二维数组）。如果 <code>N</code> 没有被指定，编译器就无法确定每个内部数组的确切大小，进而无法计算整个二维数组所需的总内存量。</li>
<li><strong>索引计算</strong>：在 C 语言中，二维数组的索引是通过 <code>arr[i][j]</code> 这样的形式来访问的。当你知道 <code>N</code> 的值时，编译器可以很容易地计算出 <code>j</code> 索引对应的元素在内存中的偏移量（即 <code>j</code> 乘以每个内部数组的大小，即 <code>N * sizeof(int)</code>）。如果 <code>N</code> 没有被指定，这种索引计算就无法进行。</li>
<li><strong>类型检查</strong>：在编译时，指定 <code>N</code> 还允许编译器对数组索引进行类型检查，确保索引不会超出数组的边界。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>宏</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%AE%8F/</url>
    <content><![CDATA[<p><strong>宏定义</strong></p>
<ul>
<li>#define 是<strong>预处理器</strong>处理的单元实体之一</li>
<li>#define 定义的宏可以出现在程序的<strong>任意位置</strong></li>
<li>#define 定义之后的代码都可使用这个宏</li>
</ul>
<blockquote>
<p> #开头的表示他是预处理处理的单元实体之一</p>
</blockquote>
<p><strong>宏常量</strong></p>
<ul>
<li>#define 定义的宏常量可以直接使用</li>
<li>#define 定义的宏常量本质为<strong>字面量</strong></li>
</ul>
<blockquote>
<p>字面量意味着他不占用任何的内存</p>
<p><strong><code>#define</code> 并不会占用内存</strong>，它只是在编译前做了一个文本替换，不涉及任何存储或运行时的内存分配。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1 <span class="string">&quot;D:\test\test.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2 D:\test\test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH3 D:\test\			<span class="comment">// 类似 D:testtest.c</span></span></span><br><span class="line">					test.c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于预处理器而言，这四个宏定义都是正确的，因为他不会进行语法检查;</p>
<p>对于预处理来说虽然正确，但是替换后的代码是不符合 C 语言语法规范的，因此编译器肯定会报错的（PATH2、PATH3）</p>
</blockquote>
<p><strong>宏定义表达式</strong></p>
<ul>
<li>#define 表达式的使用<strong>类似</strong>函数调用</li>
<li>#define 表达式可以<strong>比函数更强大</strong></li>
<li>#define 表达式<strong>比函数更容易出错</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stcio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUM_(a, b) (a) + (b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MIN_(a, b) ((a), (b)? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DIM_(a) sizeof(a) / sizeof(*a)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    iint b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> s1 = _SUM_(a, b);</span><br><span class="line">    <span class="type">int</span> s2 = _SUM_(a, b) * _SUM_(a, b);</span><br><span class="line">    <span class="type">int</span> m = _MIN_(a++, b);</span><br><span class="line">    <span class="type">int</span> d = _DIM_(c);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %d\n&quot;</span>, s1); <span class="comment">// s1 = 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 = %d\n&quot;</span>, s2); <span class="comment">// s2 = 5	(a) + (b) * (a) + (b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m = %d\n&quot;</span>, m); <span class="comment">// m = 2	 ((a++) &lt; (b)? (a++) : (b));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %d\n&quot;</span>, d); <span class="comment">// d = 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>宏表达式与函数的对比</strong></p>
<ul>
<li><p>宏表达式被<strong>预处理器</strong>处理，编译器不知道宏表达式的存在（编译器阶段已经被预处理器替换掉了）</p>
</li>
<li><p>宏表达式用”实参“完全代替形参，<strong>不进行任何运算</strong></p>
</li>
<li><p>宏表达式**没有任何的”调用“开销</p>
</li>
<li><p>宏表达式中<strong>不能出现递归定义</strong></p>
<p><strong>宏没有作用域的概念或者说限制，因为编译器根本不知道宏的存在</strong></p>
</li>
</ul>
<p><strong>内置宏</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_FILE_: 被编译的文件名</span><br><span class="line">_LINE_: 当前行号</span><br><span class="line">_DATE_: 编译时的日期</span><br><span class="line">_TIME_: 编译时的时间</span><br><span class="line">_STDC_: 编译器是否遵循标准 C 规范</span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>同一份代码产生不同的产品</p>
<ul>
<li>条件编译的行为<strong>类似</strong>于 C 语言中的 if…else…</li>
<li>条件编译是预编译指令命令，用于控制<strong>是否编译</strong>某段代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> C 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>(C == 1)</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is first printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is second printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>#if…#else… 是用来给预编译器执行的 </p>
</blockquote>
<p><strong>条件编译的本质</strong></p>
<ul>
<li><strong>预编译器</strong>根据<strong>条件编译指令</strong>有选择的<strong>删除代码</strong></li>
<li>编译器<strong>不知道</strong>代码分支的存在</li>
<li><strong>if…else…<strong>语句在</strong>运行期进行分支判断</strong></li>
<li>条件编译指令在<strong>预编译期进行分支判断</strong></li>
<li>可以通过<strong>命令行定义宏</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -Dmacro=value file.c <span class="comment">// -D 表示宏定义，等价于 #define macro value</span></span><br><span class="line">		   或</span><br><span class="line">gcc -Dmacro file.c  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> C	<span class="comment">// 检测后面这个宏是否存在，存在就执行后面的代码 This is first printf...</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is first printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is second printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>#include的本质</strong></p>
<ul>
<li>#include 的本质是将已经存在的文件内容嵌入到当前文件中</li>
<li>#include 的间接包含，同样会产生嵌入文件内容的操作</li>
</ul>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20240920210642075.png" alt="image-20240920210642075"> </p>
<blockquote>
<p>包含同样的 #include 可能会产生重复定义的问题，在编译期会导致报错</p>
<p>使用 #ifdef 可以解决这样的问题</p>
</blockquote>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Clianjieqi.png" alt="Clianjieqi"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>C编译和链接过程</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>C 语言的编译器是将 <strong>C 源代码</strong> 转换为 <strong>机器可执行代码</strong> 的工具。编译器通过几个阶段的处理，把人类可读的高级编程语言代码（如 C 语言）转换为计算机可以直接理解和运行的机器代码。常见的 C 语言编译器有 <strong>GCC</strong>、<strong>Clang</strong>、<strong>MSVC</strong> 等。</p>
<p>一个 C 语言编译器包括：预处理器、编译器、汇编器、链接器等，几个子模块。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><strong>C 编译器的主要功能和工作流程：</strong></p>
<ol>
<li><strong>预处理（Preprocessing）</strong>：</li>
</ol>
<ul>
<li><p>处理所有的注释，以空格代替</p>
</li>
<li><p>将所有的 #define 删除，并且展开所有的宏定义</p>
</li>
<li><p>处理条件编译指令 #if、#ifdef、#elif、#else、#endif</p>
</li>
<li><p>处理 #include，展开被包含的文件</p>
</li>
<li><p>保留编译器需要使用的 #pragma 指令</p>
<p>预处理指令示例：gcc -E file.c -o file.i</p>
</li>
</ul>
<ol start="2">
<li><strong>编译（Compilation）</strong>：</li>
</ol>
<ul>
<li><p>对预处理文件进行<strong>词法分析</strong>、<strong>语法分析</strong>和<strong>语义分析</strong></p>
<ul>
<li>词法分析：分析关键字、标识符、立即数等是否合法</li>
<li>语法分析：分析表达式是否遵循语法规则</li>
<li>语义分析：在语法分析的基础上进一步分析表达式是否合法</li>
</ul>
</li>
<li><p>分析结束后进行<strong>代码优化生成相应的汇编代码文件</strong></p>
<p>编译指令示例：gcc -S file.i -o file.s</p>
</li>
</ul>
<ol start="3">
<li><strong>汇编（Assembly）</strong>：</li>
</ol>
<ul>
<li><p>汇编器将汇编代码代码转为 <strong>机器指令</strong>（即目标代码，通常是 <code>.obj</code> 或 <code>.o</code> 文件）。</p>
</li>
<li><p>每条汇编语句几乎都对应一条机器指令</p>
<p>汇编指令示例：gcc -c file.s -o file.o</p>
</li>
</ul>
<ol start="4">
<li><strong>链接（Linking）</strong>：</li>
</ol>
<ul>
<li>链接器负责将不同的目标文件（包括库文件、外部依赖）合并到一起，生成最终的可执行文件（如 <code>.exe</code> 或 <code>.out</code> 文件）。</li>
<li>链接器还会处理符号解析，确保函数和变量在整个程序中正确引用。</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Clianjieqi.png" alt="Clianjieqi"></p>
<h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>连接器的主要作用是把各个模块之间相互引|用的部分处理好,使得各个模块之间能够正确的衔接。</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/lianjieguoc.png" alt="lianjieguoc"></p>
<p><strong>链接器的两种工作模式</strong></p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a><strong>静态链接</strong></h3><p>将所有的库代码和目标文件合并到最终的可执行文件中。</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cjintailianjie.png" alt="Cjintailianjie"></p>
<p>a.out 可以单独运行，不依赖外部库；运行时无需动态加载库，启动速度快。</p>
<p><strong>Linux 下静态库的创建和使用</strong></p>
<ul>
<li>编译静态库源码：gcc -c lib.c -o lib.o</li>
<li>生成静态库文件：ar -q lib.a lib.o<ul>
<li>（ar 是个打包命令会将后面列出来的的所有文件打包进 lib.a 中）</li>
</ul>
</li>
<li>使用静态库编译：gcc main.c lib.a -o main.out<ul>
<li>此时生成的 main.out 程序可以单独运行，即使你将 main.c、lib.a、lib.c、lib.o这些源文件全部删掉也没有影响。</li>
</ul>
</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><ul>
<li>只在生成可执行文件时记录库的位置，在程序运行时由系统加载动态库（如 <code>.dll</code> 文件或 <code>.so</code> 文件）。</li>
<li>可执行<strong>程序在运行时</strong>才动态加载库进行链接</li>
<li>库的内容不会进行到可执行文件中</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cdongtailianjie.png" alt="Cdongtailianjie"></p>
<p>连接器在最后链接时候不会将 lib1.so、lib2.so 直接打包进 a.out，他只知道可执行程序在执行时需要查找的库在什么位置。</p>
<p>stub1、stub2 就是 liib1.so、lib2.so 分别暴露出来告诉编译器他可以使用的内容只有 stub1、stub2；</p>
<blockquote>
<p>库的更新可能导致不兼容问题（即 “DLL Hell”）。</p>
</blockquote>
<p><strong>Linux 下动态链接的创建和使用</strong></p>
<ul>
<li>编译动态库源码：gcc -shared dlib.c -o dlib.so</li>
<li>使用动态库编译：gcc main.c -ldl -o main.out</li>
<li>关键系统调用<ul>
<li>dlopen：打开动态库文件</li>
<li>dlsym：查找动态库中的函数并返回调用地址</li>
<li>dlclose：关闭动态库文件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><ul>
<li>自动确定数组大小<ul>
<li>type Name[] &#x3D; { V<sub>0</sub> , V<sub>1</sub> , … , V<sub>n</sub> }；</li>
</ul>
</li>
<li>将部分数组元素初始化为 0<ul>
<li>type Name[N] &#x3D; { V<sub>0</sub> , V<sub>1</sub> , … , V<sub>s</sub> }；</li>
<li>S &lt; N，未指定初始值的元素默认为 0</li>
</ul>
</li>
<li>将所有数组元素初始化为 0<ul>
<li>type Name[N] &#x3D; {0};</li>
</ul>
</li>
</ul>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>数组在计算机底层就是<strong>一片连续的内存</strong>，用于存储数组的元素；可以通过<strong>sizeof</strong>获取（字节）；</p>
<p>其大小根据其中内容决定；</p>
<blockquote>
<p>int a[6]; 此数组的大小就是 4 X 6 &#x3D; 24 （字节）</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>数组名只能作为左值使用（可以看作是常量）</li>
<li>只能使用<strong>整形常量</strong>对数组大小进行定义</li>
<li>只能使用<strong>整型值</strong>作为下标对数组值进行访问</li>
</ul>
<p><img src="/public/image/Linux/make/tiaojianpanduanyuju.png" alt="tiaojianpanduanyuju"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul>
<li>char-字符型，一个字节的整数，范围【-128-127】</li>
<li>字符数据（单引号括起来的字符）的本质是整数类型</li>
<li>char 类型的变量可以打印为整数或者字符</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>const 修饰的变量是只读的，本质还是变量</li>
<li>const 修饰的局部变量在<strong>栈</strong>上分配空间</li>
<li>const 修饰的全局变量在<strong>只读存储区</strong>分配空间</li>
<li>const 只在编译器有用，在运行期无用</li>
</ul>
<blockquote>
<p>const 修饰的变量不是真正的变量，他只是告诉编译器该变量不能出现在赋值符号的左边；</p>
</blockquote>
<ul>
<li>在现代 C 语言编译器中，直接修改 const 全局变量将导致程序崩溃</li>
</ul>
<blockquote>
<p>注意：标准 C 语言编译器不会将 const 修饰的全局变量存储与只读存储区中，而是存储与可修改的全局数据区，其值依然可以改变；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_cc = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cc = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* pp = (<span class="type">int</span>*)&amp;cc;</span><br><span class="line">    <span class="type">int</span>* g_pp = (<span class="type">int</span>*)&amp;g_cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cc); <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p = 3 // Error</span></span><br><span class="line">    *pp = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc);<span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc);<span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//g_cc = 2 // Error</span></span><br><span class="line">     </span><br><span class="line">    *g_pp = <span class="number">3</span>; <span class="comment">// oops! Segmentation fault </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc);<span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gcc 将全局 cosnt 存储与只读存储区，当我们试图修改其中的内容时候，就会报 Segmentation fault 错误（这也是标准 C 语言的定义）</p>
<p>其他编译器可能就没问题</p>
</blockquote>
<ul>
<li>C 语言中的 const 使得变量具有只读属性</li>
<li>现代 C 编译器中的 const 将具有全局生命周期的变量存储与只读存储区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_array[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    *p = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;i, <span class="number">1</span>);    <span class="comment">// ok</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;j, <span class="number">1</span>);    <span class="comment">// Error</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;<span class="built_in">array</span>[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// ok</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;g_array[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arrya[0] = %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_arrya[0] = %d\n&quot;</span>, g_array[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>modify((int*)&amp;j, 1);    &#x2F;&#x2F; Error</p>
<p>被 static 修饰的变量被存储在全局存储区，const 修饰的全局变量将被存放在只读存储区</p>
<p>modify((int*)&amp;g_array[0], 1); &#x2F;&#x2F; Error</p>
<p>g_array[0] 是全局变量，被 const 修饰的全局变量将存储区只读存储区</p>
</blockquote>
<ul>
<li>const 修饰函数参数表示在函数体内不希望改变参数的值</li>
<li>const 修饰函数返回值表示返回值不可改变，多用于返回指针的情形</li>
</ul>
<blockquote>
<p>C 语言中的字符串字面量存储与只读存储区中，在程序中需要使用 const char* 指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i )</span> &#123;</span><br><span class="line">    <span class="comment">// i = 5;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kay wang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pc = f(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pc[3] = &quot;_&quot;; // Error 因为是只读的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pc);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p><strong>在 C 语言中可以定义 void 类型的指针</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> var; <span class="comment">// Eroor</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// Err</span></span><br><span class="line">    <span class="type">void</span>* pv; <span class="comment">// C 语言允许定义 void 类型的指针 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不存在 void 类型的变量</strong></p>
<ul>
<li><p>C 语言中没有定义 void 究竟是多大内存的别名，无法在内存中开辟出 void 大小对应的变量</p>
</li>
<li><p>而指针是固定 4 或 8 个字节大小的，所以可以开辟指针类型的 void 变量</p>
</li>
</ul>
<blockquote>
<p>注意：在非标准 C 语言编译器中有的对 void 规定了大小，比如 gcc 编译器就规定了 void 大小为 1 个字节</p>
<p>printf(“%ld\n”, sizeof(void)); &#x2F;&#x2F; 1</p>
</blockquote>
<p><strong>意义</strong></p>
<ul>
<li>C 语言规定只有相同类型的指针才可以互相赋值</li>
<li>void* 指针作为左值用于 “接收” 任意类型的指针</li>
<li>void* 指针作为右值使用时需要进行强制类型转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc() 函数是 C 语言标准库中的一个函数，用于动态地分配内存。</span></span><br><span class="line"><span class="type">int</span>* pI = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">char</span>* pC = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* pni = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* pnc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = pI; <span class="comment">// ok</span></span><br><span class="line">============</span><br><span class="line">pni = P; <span class="comment">// Error oops! pni = (int*)p</span></span><br><span class="line"></span><br><span class="line">p = pC <span class="comment">// ok</span></span><br><span class="line">==================</span><br><span class="line">pnc = P; <span class="comment">// Error oops! pnc = (void*)p</span></span><br></pre></td></tr></table></figure>

<ul>
<li>void 是一种抽象的数据类型</li>
<li>void 类型不能用于定义变量</li>
<li>void 类型用于声明函数无参数</li>
<li>void 类型用于声明函数无返回值</li>
<li>可以定义 void* 类型的指针</li>
<li>void* 类型的指针可以接收任意类型的指针值</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile 可理解为 “编译器警告关键字”</li>
<li>volatile 告诉编译器必须每次去内存中取变量值</li>
<li>volatile 主要修饰可能被多个线程访问的变量</li>
<li>volatile 也可以修饰可能被未知因数更改的变量</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>C 语言中的常量类型</strong></p>
<ul>
<li>字面量<ul>
<li>直接表示值含义的符号，如：5、’a’、”Ubuntu”</li>
</ul>
</li>
<li>宏常量（字符化的字面量）<ul>
<li>通过 #define 定义，间接表示值的符号，如：FIV &#x3D;&gt; 5.5</li>
</ul>
</li>
<li>枚举常量<ul>
<li>通过 enum 定义，间接表示值的符号，如：First &#x3D;&gt; 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME kay;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举常量只能是整形常量，浮点数都不可以</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ThirdValue = <span class="number">333</span>,</span><br><span class="line">    FourthValue = <span class="number">444</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>常量的类型</strong></p>
<ul>
<li>字面量有其默认的类型，也可通过后缀指定其类型</li>
<li>#define 定义的宏常量可以是任意类型</li>
<li>enum 定义的枚举常量只能是整形</li>
</ul>
<blockquote>
<p>字面量是常量，但是它的默认类型由语言提供，也可通过后缀指定其类型；</p>
</blockquote>
<h2 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h2><p><strong>C 语言中的只读变量</strong></p>
<ul>
<li>C 语言提供了 const 关键字，用于修饰一个变量</li>
<li>被 const 修饰的变量<strong>只能作为右值使用</strong><ul>
<li>无法通过赋值操作改变 const 变量的值</li>
<li>const 修饰</li>
</ul>
</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><strong>同样是4个字节，为什么float却比int的范围大得多呢？</strong></p>
<ul>
<li>float 能表示的具体数字的个数与int相同</li>
<li>float可表示的数字之间不是连续的，存在间隙</li>
<li>float只是一种近似的表示法，不能作为精确使用</li>
<li>由于内存表示法相对复杂，float的运算速度比int慢很多</li>
</ul>
<blockquote>
<p>注意：</p>
<p>double 与 float 具有相同的内存表示法，因此 double 也是不精确的。由于 double 占用的内存较多，所能表示的精度比 float 高；</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>浮点类型与整数类型的内存表示法不同</li>
<li>浮点类型的内存表示更复杂</li>
<li>浮点类型可表示的范围更大</li>
<li>浮点类型是一种不精确的类型</li>
<li>浮点类型的运算速度很慢</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><ul>
<li>long 在使用不同的编译器时，可能占用的内存不同</li>
<li>long 通常占 4 字节内存，也可能占 8 字节内存</li>
<li>long long表示整形，固定占用 8 字节内存</li>
<li>long long 是 long long int 的缩写形式</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>make 和 makefile</title>
    <url>/Linux/Make/make%20%E5%92%8C%20makefile/</url>
    <content><![CDATA[<h2 id="make-与-makefile介绍"><a href="#make-与-makefile介绍" class="headerlink" title="make 与 makefile介绍"></a>make 与 makefile介绍</h2><p>make：是一个工具程序，通过读取”makefile”文件以实现自动化构建软件。</p>
<ul>
<li><strong>解析源程序之间的依赖关系</strong></li>
<li>根据依赖关系<strong>自动维护</strong>编译工作</li>
<li>执行宿主操作系统中的各种命令</li>
</ul>
<p><strong>众多编译辅助工具中的王者</strong></p>
<p>makefile：是一个配置文件，一个描述文件。</p>
<ul>
<li><strong>定义一系列规则</strong>来指定源文件编译的先后顺序</li>
<li><strong>拥有特定的语法规则</strong>，支持函数定义和函数调用</li>
<li>能够<strong>直接集成</strong>操作系统中的各种命令</li>
</ul>
<p><strong>二者关系</strong>：makefile 中的描述用于指导 make 程序如何完成工作；make 根据 makefile 中的规则执行命令，最后完成编译输出。</p>
<p><img src="/public/image/Linux/make/erzheguanxi.png" alt="erzheguanxi"></p>
<p>简单示例</p>
<p>make 程序的使用示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 hello 关键字作为目标查找 mf.txt 文件，并执行 hello 处的命令。</span></span><br><span class="line">make -f mf.txt hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录下以 hello 关键字为目标查找 makefile 或 Makefile 文件，并执行 hello 处的命令。</span></span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录下查找 makefile 或 Makefile 文件中最顶层目标，并执行最顶层目标的命令。</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li>make 只是一个<strong>特殊功能的</strong>应用程序</li>
<li>make 用于根据指定的目标<strong>执行相应的命令</strong></li>
<li>makefile 用于<strong>定义目标</strong>和实现目标所需的命令</li>
<li>makefile 有特定的语法规则，支持函数定义和调用</li>
</ul>
<h2 id="makefile-的结构"><a href="#makefile-的结构" class="headerlink" title="makefile 的结构"></a>makefile 的结构</h2><p><strong>makefile 的意义</strong></p>
<ul>
<li><p>makefile 用于定义源文件之间的依赖关系</p>
</li>
<li><p>makefile 说明如何编译各个源文件并生成可执行文件</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makefile语法</span></span><br><span class="line"><span class="comment"># 第一种写法</span></span><br><span class="line"><span class="section">target(目标文件): 文件1 文件2(依赖文件列表); command(命令) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种写法</span></span><br><span class="line"><span class="section">target(目标文件): 文件1 文件2(依赖文件列表) </span></span><br><span class="line">`\t`command</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<p>target 可以包含多个目标</p>
<ul>
<li>使用空格对多个目标进行分割</li>
</ul>
<p>依赖 可以包含多个依赖</p>
<ul>
<li>使用空格对多个依赖进行分割</li>
</ul>
<p>[Tab]键：<code>\t</code></p>
<ul>
<li>每一个命令必须以[Tab]字符开始</li>
<li>[Tab]字符告诉 make 此行是一个命令行</li>
</ul>
<p>续航符: \</p>
<ul>
<li>可以将内容分开写到下一行，提高可读性</li>
</ul>
<p><strong>makefile的依赖示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: test</span></span><br><span class="line">	echo <span class="string">&quot;make all&quot;</span></span><br><span class="line"><span class="section">test: </span></span><br><span class="line">	echo <span class="string">&quot;make test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： 可使用 @ 进行无回写设置</span></span><br><span class="line"><span class="comment"># echo &quot;make test&quot;</span></span><br><span class="line"><span class="comment"># make test</span></span><br><span class="line"><span class="comment"># echo &quot;make all&quot;</span></span><br><span class="line"><span class="comment"># make all</span></span><br></pre></td></tr></table></figure>

<p>依赖规则</p>
<ul>
<li>当<strong>目标对应的文件不存在时</strong>，执行对应命令</li>
<li><strong>当依赖在时间上比目标更新时</strong>，执行对应命令(要理解下)</li>
<li><strong>当依赖关系连续发生时</strong>，对比依赖链上的每一个目标</li>
</ul>
<p>小技巧</p>
<ul>
<li>makefile 中可以在命令前加上 @ 符，作用为命令无回显。</li>
<li>工程开发中可以将最终可执行文件名和all同时作为 makefile 中第一条规则的目标</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">案例：</span><br><span class="line">hello.out all: main.o func.o</span><br><span class="line">	gcc -o hello.out main.o func.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -o main.o, -c main.c</span><br><span class="line"><span class="section">func.o: func.c</span></span><br><span class="line">	gcc -o func.o -c func.c</span><br></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li><p>makefile 用于定义源文件间的<strong>依赖关系</strong></p>
</li>
<li><p>makefile 说明<strong>如何编译各个源文件</strong>并生成可执行文件</p>
</li>
<li><p>makefile 中的目标之间存在<strong>连续依赖关系</strong></p>
</li>
<li><p><strong>依赖存在</strong>并且<strong>命令执行成功</strong>是目标完成的充要条件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/Linux/Make/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>makefile 中支持函数的概念</p>
<ul>
<li>make 解释器提供了一系列的函数供 makefile 调用</li>
<li>在 makefile 中支持自定义函数实现，并调用执行</li>
<li>通过 define 关键字实现自定义函数</li>
</ul>
<h2 id="自定义函数语法"><a href="#自定义函数语法" class="headerlink" title="自定义函数语法"></a>自定义函数语法</h2><p><img src="/public/image/Linux/make/zidingyihanshuyufa.png" alt="zidingyihanshuyufa"></p>
<blockquote>
<p>$(0) 表示这个函数的第 0 个参数；即这个函数的名字</p>
<p>$(1) 表示i这个函数的第 1 个参数；即 func2 调用时候，后面跟着的第一个参数</p>
</blockquote>
<p><strong>深入理解自定义函数</strong></p>
<ul>
<li>自定义函数是<strong>一个多行变量</strong>，无法直接调用</li>
<li>自定义函数是<strong>一种过程调用</strong>，没有任何返回值</li>
<li>自定义函数<strong>用于定义命令集合</strong>，并应用于规则中</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func2</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Param 1 =&gt; $(1)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Param 2 =&gt; $(2)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">var := <span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">new := <span class="variable">$(func1)</span></span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span>	<span class="comment"># new =&gt; @echo &quot;My name is&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span>	<span class="comment"># var =&gt; @echo &quot;My name is func1&quot;</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func1)</span>  <span class="comment"># My name is func1</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func2, D.T.Software, delphi_tang)</span></span><br><span class="line">	<span class="comment"># My name is func2</span></span><br><span class="line">	<span class="comment"># Param 1 =&gt; D.T.Software</span></span><br><span class="line">	<span class="comment"># Param 2 =&gt; delphi_tang</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么 new &#x3D;&gt; @echo “My name is、var &#x3D;&gt; @echo “My name is func1？</p>
<p>是因为define 关键字是用来定义多行变量的，只不过 call 关键字将它(func1、func2)当作了一个自定义函数进行使用；当这个使用不在规则中的时候，make 解释器就将他当成了一个变量来进行使用，所以输出的是命令的内容；</p>
<p>而为什么 var 多了一个 func1 呢？是因为 call 关键字将实参替换到函数体当中对应的位置；</p>
<p>由上述执行结果可以看出</p>
<p>define 关键字是用来定义多行变量的，只不过在 call 关键字的作用下被当作了一个自定义函数进行使用；只不过这个使用是有限制的，只有在规则中才可以进行使用。</p>
</blockquote>
<h2 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h2><p><strong>make 解释器中的预定义函数</strong></p>
<ul>
<li>make 的函数提供了<strong>处理文件名，变量和命令</strong>的函数</li>
<li>可以在需要的地方<strong>调用函数来处理指定的参数</strong></li>
<li>函数在<strong>调用的地方被替换为处理结果</strong></li>
</ul>
<p><strong>预定义函数的调用</strong></p>
<p><img src="/public/image/Linux/make/yudingyihanshudiaoyong.png" alt="yudingyihanshudiaoyong"></p>
<p><strong>为什么自定义函数与预定义函数的调用形式完全不同？</strong></p>
<ul>
<li>makefile 中<strong>不支持</strong>真正意义上的自定义函数，自定义函数的<strong>本质是多行变量</strong></li>
<li>预定义的 call 函数在调用时将参数传递给多行变量</li>
<li>自定义函数是 call 函数的实参，并在 call 中被执行</li>
</ul>
<blockquote>
<p>call 函数就是将参数传递给多行变量，是用来处理参数值的；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">func2 := @echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># My name is func1</span></span><br><span class="line"><span class="comment"># My name is </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>func1 是个多行变量，使用时 call 将参数传递给了多行变量；</p>
<p>func2 是个普通变量，call 无法处理普通变量，所以这里 $(0) 是空值；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func2</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">var1 := <span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">var2 := <span class="variable">$(<span class="built_in">call</span> func2)</span></span><br><span class="line">var3 := <span class="variable">$(<span class="built_in">abspath</span> ./)</span></span><br><span class="line">var4 := <span class="variable">$(<span class="built_in">abspath</span> tst.app)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;var1 =&gt; <span class="variable">$(var1)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var2 =&gt; <span class="variable">$(var2)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var3 =&gt; <span class="variable">$(var3)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var4 =&gt; <span class="variable">$(var4)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># var1 =&gt; 	@echo &quot;My name is func1&quot; </span></span><br><span class="line"><span class="comment"># var2 =&gt; 	@echo &quot;My name is func2&quot; </span></span><br><span class="line"><span class="comment"># var3 =&gt; /hom/kay</span></span><br><span class="line"><span class="comment"># var4 =&gt; /hom/kay/tst.app</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>make 解释器<strong>提供了一系列的函数</strong>供 makefile 调用</li>
<li>自定义函数是<strong>一个多行变量，无法直接调用</strong></li>
<li>自定义函数用于<strong>定义命令集合</strong>，并应用于规则中</li>
<li>预定义的 call 函数在调用时将参数传递给多行变量</li>
<li><strong>自定义函数是 call 函数的实参</strong>，并在 call 中被执行</li>
</ul>
<h2 id="变量与函数的综合示例"><a href="#变量与函数的综合示例" class="headerlink" title="变量与函数的综合示例"></a>变量与函数的综合示例</h2><p><strong>实战需求</strong></p>
<ul>
<li>自动生成 target 文件夹存放可执行文件</li>
<li>自动生成 objs 文件夹存放编译生成的目标文件（*.o）</li>
<li>支持调试版本的编译选项</li>
<li>考虑代码的扩展性</li>
</ul>
<p><strong>工具原料</strong></p>
<ul>
<li>$(wildcard_pattern)<ul>
<li>获取当前工作目录中满足 _pattern 的文件或者目录列表</li>
</ul>
</li>
<li>$(addprefix _prefix,_names)<ul>
<li>给名字列表 _names 中每一个名字增加前缀 _prefix</li>
</ul>
</li>
</ul>
<p><strong>技巧</strong></p>
<ol>
<li>自动获取当前目录下的源文件列表（函数调用）<ul>
<li>SRCS :&#x3D; $(wildcard *.c)</li>
</ul>
</li>
<li>根据源文件列表生成目标文件列表（文件的值替换）<ul>
<li>OBJS :&#x3D; $(SRCS:.c&#x3D;.o)</li>
</ul>
</li>
<li>对每一个目标文件列表加上路径前缀（函数调用）<ul>
<li>OBJS :&#x3D; $(addprefix path&#x2F;, $(OBJS))</li>
</ul>
</li>
</ol>
<p><strong>规则中的模式替换（目录结构）</strong></p>
<p><img src="/public/image/Linux/make/guizezhongdemoshitihuan.png" alt="guizezhongdemoshitihuan"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>伪目标</title>
    <url>/Linux/Make/%E4%BC%AA%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="makefile-中的目标究竟是什么？"><a href="#makefile-中的目标究竟是什么？" class="headerlink" title="makefile 中的目标究竟是什么？"></a>makefile 中的目标究竟是什么？</h2><p>make 被设计的初衷是用于编译和管理 C 语言源代码的，所以目标在默认情况下：</p>
<ul>
<li>make 认为**目标对应着一个文件 **</li>
<li>make 比较<strong>目标文件和依赖文件的新旧关系</strong>，决定是否执行命令</li>
<li>make 以<strong>文件处理</strong>作为第一优先级</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的代码有何意义：</span></span><br><span class="line"><span class="comment"># hello.out all : func.o main.o</span></span><br><span class="line"><span class="comment"># 	 gcc -o hello.out func.o main.o</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># func.o : func.c</span></span><br><span class="line"><span class="comment"># 	 gcc -o func.o -c func.c</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># main.o : main.c</span></span><br><span class="line"><span class="comment"># 	 gcc -o main.o -c main.c</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	rm *.o hello.out</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 当前目录不存在名为 clean 的文件时，clean会被作为标签进行使用，执行 rm *.o hello.out 命令；</p>
<p>当前目录下存在名为 clean 的文件时，由于 make 以文件处理作为第一优先级，所以他会去检查 clean 这个命令，这时他会发现 clean 文件(目标)所对应的依赖并没有被修改过(clean没有依赖所以也就无法被修改依赖)，那么 make 就会认为 clean 文件是最新的就会不执行下面的命令，并提示”clean 是最新的。”</p>
</blockquote>
<p>为了解决这个问题(我们要执行 clean 下的命令而不是让 make 将 clean 当成成文件进行处理)，我们就引入了”伪代码”这个概念。</p>
<p><strong>makefile 中的伪目标</strong></p>
<ul>
<li>通过 .PHONY 关键字声明一个伪目标</li>
<li>伪目标不对应任何实际文件</li>
<li>不管伪目标的依赖是否更新，命令总是执行</li>
</ul>
<h2 id="伪目标语法"><a href="#伪目标语法" class="headerlink" title="伪目标语法"></a>伪目标语法</h2><p><strong>先声明，后使用；</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean	# 声明</span></span><br><span class="line"><span class="comment">##注释##</span></span><br><span class="line"><span class="section">clean:	# 使用</span></span><br><span class="line">	rm *.o hello.out	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样处理后即使当前目录下存在 clean 文件，make 也只会将 clean 当作一个标签进行处理，而不是文件；</p>
<p>因为此时 clean 就相当于变成了 .PHONY 文件的依赖，而 .PHONY 这样一个文件其实并不存在，所以 clean 文件的创建时间相比  .PHONY 来说永远是新的；这样 clean 下的命令就肯定会被执行； </p>
</blockquote>
<h2 id="妙用"><a href="#妙用" class="headerlink" title="妙用"></a>妙用</h2><p><strong>规则调用（函数调用）</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean rebuild all	# 声明</span></span><br><span class="line"><span class="comment">## oter rules ##</span></span><br><span class="line"><span class="section">rebuild: clean all</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o hello.out</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样当我们执行 make rebuild 时他就会按照先 clean 再 all 的顺序执行下去；</p>
</blockquote>
<p><strong>技巧</strong></p>
<p>当我们使用的不是 GNU 下的标准 make 程序时，可能不存在 .PHONY 这个关键字，那么该如何实现伪目标的效果呢？</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean: FORCE</span></span><br><span class="line">	rm *.o hello.out</span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理：如果一个规则没有命令或者依赖，并且它也不是一个文件名，在执行此规则时，目标(FORCE)总会被认为是最新的</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>默认情况下，make 认为目标对应着一个文件</li>
<li>.PHONY 用于声明一个伪目标，伪目标不对应实际的文件</li>
<li><strong>伪目标的本质是 make 中特殊目标 .PHONY 的依赖</strong></li>
<li>使用伪目标可以模拟”函数调用”</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>变量</title>
    <url>/Linux/Make/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>makefile 中支持程序设计语言中的<strong>变量的概念</strong></li>
<li>makefile 中的变量<strong>只代表文本数据</strong>(字符串)</li>
<li>makefile 中的变量名规则：<ul>
<li>变量名可以包含字符，数字，下划线</li>
<li>不能包含 “:”, “#”, “&#x3D;”, 或 “ “</li>
<li>变量名大小写敏感</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以 makefile 中的变量不需要声明类型；</p>
<p>在 makefile 中使用变量前可以不去定义它，但是这样将会得到一个空值</p>
</blockquote>
<h3 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h3><p><img src="/public/image/Linux/make/bianliangshiyong.png" alt="bianliangshiyong"></p>
<h3 id="makefile-中变量的赋值方式"><a href="#makefile-中变量的赋值方式" class="headerlink" title="makefile 中变量的赋值方式"></a>makefile 中变量的赋值方式</h3><ul>
<li>简单赋值（:&#x3D;）</li>
<li>递归赋值（&#x3D;）</li>
<li>条件赋值（?&#x3D;）</li>
<li>追加赋值（+&#x3D;）</li>
</ul>
<p><strong>:&#x3D; 简单赋值</strong></p>
<p><strong>只对当前语句的变量有效</strong></p>
<p><img src="/public/image/Linux/make/jiandanfuzhi.png" alt="jiandanfuzhi"></p>
<p><strong>&#x3D; 递归赋值</strong></p>
<p><strong>赋值可能影响多个其他变量</strong></p>
<p><strong>所有与目标变量相关的其他变量都将受到影响</strong></p>
<p><img src="/public/image/Linux/make/diguifuzhi.png" alt="diguifuzhi"></p>
<p><strong>?&#x3D; 条件赋值</strong></p>
<p><strong>如果变量未定义，使用赋值符号中的值定义变量</strong></p>
<p><strong>如果变量已经定义，则赋值无效</strong></p>
<p><img src="/public/image/Linux/make/tiaojianfuzhi.png" alt="tiaojianfuzhi.png"></p>
<p><strong>+&#x3D; 追加赋值</strong></p>
<p><strong>原变量值后加上一个新值</strong></p>
<p>原变量值与新值之间由<strong>空格</strong>隔开</p>
<p><img src="/public/image/Linux/make/zhuijiafuzhi.png" alt="zhuijiafuzhi.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>makefile 中支持变量的定义和使用</p>
<p>makefile 中存在四种变量的赋值方式</p>
<ul>
<li>简单赋值（:&#x3D;）</li>
<li>递归赋值（&#x3D;）</li>
<li>条件赋值（?&#x3D;）</li>
<li>追加赋值（+&#x3D;）</li>
</ul>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><ul>
<li><strong>自动变量</strong><ul>
<li>$@，$^，$&lt;</li>
</ul>
</li>
<li><strong>特殊变量</strong><ul>
<li>$(MAKE)， $(MAKECMDGOALS)， $(MAKEFILE_LIST)</li>
<li>$(MAKE_VERSION)，$(CURDIR)，$(.VARIABLES)</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul>
<li><p>$@</p>
<ul>
<li>当前规则中，触发命令被执行的<strong>目标</strong>(即当前规则中的目标);</li>
</ul>
</li>
<li><p>$^</p>
<ul>
<li>当前规则(目标)中的<strong>所有依赖</strong></li>
</ul>
</li>
<li><p>$&lt;</p>
<ul>
<li>当前规则中的<strong>第一个依赖</strong></li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all first second third</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: first second third</span></span><br><span class="line">	@echo <span class="string">&quot;\$<span class="variable">$@</span> =&gt; <span class="variable">$@</span>&quot;</span>	<span class="comment"># $@ =&gt; all</span></span><br><span class="line">	@echo <span class="string">&quot;$<span class="variable">$^</span> =&gt; <span class="variable">$^</span>&quot;</span>	<span class="comment"># $^ =&gt; first second third</span></span><br><span class="line">	@echo <span class="string">&quot;$<span class="variable">$&lt;</span> =&gt; <span class="variable">$&lt;</span>&quot;</span>	<span class="comment"># $&lt; =&gt; first</span></span><br><span class="line"><span class="section">first:</span></span><br><span class="line"><span class="section">second:</span></span><br><span class="line"><span class="section">third:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>“$” 对于 makefile 有特殊含义，输出 “$” 时需要加上一个 “$” 进行转义；</p>
<p>“$@” 对于 Bash shell 有特殊的含义，输出时需要加上 “\“ 进行转义； </p>
</blockquote>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><ul>
<li>$(MAKE)<ul>
<li>当前 make 解释器的文件名</li>
</ul>
</li>
<li>$(MAKECMDGOALS)<ul>
<li>命令行中指定的目标名(make 的命令行参数)</li>
</ul>
</li>
<li>$(MAKEFILE_LIST)<ul>
<li>make 所需要处理的 makefile 文件列表</li>
<li>当前 makefile 的文件名总是位于列表的最后</li>
<li>文件名之间以空格进行分隔</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all first second third</span></span><br><span class="line"></span><br><span class="line">all out: first second third		<span class="comment"># 执行 make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(AMKE)</span>&quot;</span>				<span class="comment"># make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>		<span class="comment"># </span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(MAKEFILE_LIST)</span>&quot;</span>	<span class="comment">#  makefile (前面有个空格)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>$(MAKE_VERSION)<ul>
<li>当前 make 解释器的版本</li>
</ul>
</li>
<li>$(CURDIR)<ul>
<li>当前 make 解释器的工作目录</li>
</ul>
</li>
<li>$(.VARIABLES)<ul>
<li>所有已经定义的变量名列表(预定义变量和自定义变量)</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test1 test2</span></span><br><span class="line"></span><br><span class="line"><span class="section">test1: 						# 执行 make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(AMKE_VERSION)</span>&quot;</span>	<span class="comment"># 3.81</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(CURDIR)</span>&quot;</span>		<span class="comment"># /home/kay</span></span><br><span class="line">	@echo <span class="string">&quot;$(.VSRLABLES)&quot;</span>	<span class="comment">#  (...太多了)</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>maekefile 提供了预定义变量供开发者使用</li>
<li>预定义变量的使用能够使得 makefile 的开发更高效</li>
<li>自动变量是 makefile 中最常见的元素</li>
<li>使用 $(.VSRLABLES) 能够获取所有的特殊变量</li>
</ul>
<h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><h3 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h3><ul>
<li>使用指定字符（串）替换变量值中的后缀字符（串）</li>
<li>语法格式：$(var:a&#x3D;b) 或 ${var:a&#x3D;b}<ul>
<li>替换表达式中不能有任何的空格</li>
<li>make 中支持使用${}对变量进行取值</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">src:= a.cc b.cc c.cc	<span class="comment"># 可以理解为编译语言中的字符串类型 &quot;a.cc b.cc c.cc&quot;</span></span><br><span class="line">obj:= $(src:cc=o)	<span class="comment"># 将src中所有的cc替换为o</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;obj =&gt; <span class="variable">$(obj)</span>&quot;</span>	<span class="comment"># a.o b.o c.o</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的模式替换"><a href="#变量的模式替换" class="headerlink" title="变量的模式替换"></a>变量的模式替换</h3><ul>
<li>使用 % 保留变量值中的指定字符，替换其他字符</li>
<li>语法格式：$(var:a%b&#x3D;x%b) 或 ${var:a%b&#x3D;x&amp;b}<ul>
<li>替换表达式中不能有任何的空格</li>
<li>make 中支持使用${}对变量进行取值</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">src:= a1b.c a2b.c a3b.c</span><br><span class="line">obj:= $(src:a%b.c=x%y)	<span class="comment"># 将src中a替换为x，b替换为y，其余的保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;obj =&gt; <span class="variable">$(obj)</span>&quot;</span>	<span class="comment"># x1y x2y x3y</span></span><br></pre></td></tr></table></figure>

<h3 id="规则中的模式替换"><a href="#规则中的模式替换" class="headerlink" title="规则中的模式替换"></a>规则中的模式替换</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="section">target: target-pattern: prereq-patern</span></span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>作用：通过 target-pattern 从 target 中匹配子目标；再通过 prereq-patern 从子目标生成依赖；进而构成完整的规则。</p>
<p><img src="/public/image/Linux/make/guizezhongmoshitihuan.png" alt="guizezhongmoshitihuan"></p>
<blockquote>
<p>此处，%.o 从 OBJS 中匹配以 .o 结尾的文件，这是就先找到了 func.o 这个文件名；%.o : %.c 表示对于每一个 .o 文件他都依赖于一个同名的 .c 文件(即文件名除了扩展名外完全相同,)；基于以上规则第一个 </p>
<p>func.o : func.c</p>
<p>​	gcc -o $@ -c $^</p>
<p>就被构建出来了，main.o 也是同理。</p>
</blockquote>
<h3 id="变量值的嵌套引用"><a href="#变量值的嵌套引用" class="headerlink" title="变量值的嵌套引用"></a>变量值的嵌套引用</h3><ul>
<li>一个变量名之中可以<strong>包含对其它变量的引用</strong></li>
<li>嵌套引用的本质是<strong>使用一个变量表示另外一个变量</strong></li>
</ul>
<p><img src="/public/image/Linux/make/bianliangzhiqtyy.png" alt="bianliangzhiqtyy"></p>
<h3 id="命令行变量"><a href="#命令行变量" class="headerlink" title="命令行变量"></a>命令行变量</h3><ul>
<li>运行 make 时可以在命令行定义变量，命令行中输入的默认覆盖 makefile 中定义的变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">hm := hello makefile</span><br><span class="line"><span class="section">test: </span></span><br><span class="line">	@echo <span class="string">&quot;hm =&gt; <span class="variable">$(hm)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行输入	make hm=cmd</span></span><br><span class="line"><span class="comment"># 命令行输出	hm =&gt; cmd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实际开发中，可用于零时改变某个变量的值，以得到一个特殊的可执行编译程序(测试程序)</p>
</blockquote>
<h3 id="override-关键字"><a href="#override-关键字" class="headerlink" title="override 关键字"></a>override 关键字</h3><ul>
<li>用于指示 makefile 中定义的变量不能被覆盖</li>
<li><strong>变量的定义和赋值都需要使用 override 关键字</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">override</span> var := test</span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"><span class="comment"># 命令行输入	make var=cmd</span></span><br><span class="line"><span class="comment"># 命令行输出	hvarm =&gt; test</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>override 关键字仅对后续在 Makefile 中定义的变量生效，如果在 Makefile 中先定义了变量，然后在其后使用 override 关键字尝试覆盖它，那么这个 override 指令将不会有任何效果；</p>
<p>在 Makefile 中，即使一个变量被 override 修饰，它仍然可以在 Makefile 的后续部分进行二次赋值；</p>
<p>override 主要影响的是命令行参数（通过 make VAR&#x3D;value 传递的）和通过 -e 选项传递给 make 的环境变量，让其不可被覆盖命令行变量覆盖；</p>
</blockquote>
<h3 id="define-关键字"><a href="#define-关键字" class="headerlink" title="define 关键字"></a>define 关键字</h3><ul>
<li>用于在 makefile 中定义多行变量</li>
<li>多行变量的定义从变量名开始到 endef 结束</li>
<li>可使用 override 关键字防止变量被覆盖</li>
<li>define 定义的变量等价于使用 &#x3D; 定义的变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">define</span> foo</span><br><span class="line">I&#x27;m fool!</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo =&gt; I&#x27;m fool!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> cmd</span><br><span class="line">	@echo <span class="string">&quot;run cmd ls ...&quot;</span></span><br><span class="line">	@ls</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 cmd 的值就是两条命令，当值为命令的时候，前面一定要加[Tab]键</span></span><br></pre></td></tr></table></figure>

<h3 id="环境变量-全局变量"><a href="#环境变量-全局变量" class="headerlink" title="环境变量(全局变量)"></a>环境变量(全局变量)</h3><p>也是操作系统中的环境变量</p>
<ul>
<li>makefile 中能够直接使用操作系统中的环境变量<ul>
<li>当定义的变量与系统环境变量同名时，环境变量将被覆盖</li>
<li>运行 make 时指定 “-e” 选项，优先使用环境变量</li>
</ul>
</li>
</ul>
<p><strong>为什么要在 makefile 中使用环境变量?</strong></p>
<ul>
<li>优势<ul>
<li>环境变量可以在所有 makefile 中使用</li>
</ul>
</li>
<li>劣势<ul>
<li>过多的依赖于环境变量会导致移植性变差</li>
</ul>
</li>
</ul>
<p><strong>变量在不同 makefile 之间的传递方式</strong></p>
<ul>
<li>直接使用外部定义的环境变量（操作系统的环境变量）进行传递<ul>
<li>存在操作系统之间移植性的问题</li>
</ul>
</li>
<li>使用 export 定义变量进行传递（定义临时环境变量）<ul>
<li>因为变量都是在各自 makefile 文件中进行定义，所以不存在移植性的问题</li>
</ul>
</li>
<li>定义 make 命令行变量进行传递（推荐）</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># echo $JAVA_HOME	系统环境变量中的 JAVA_HOME</span></span><br><span class="line"><span class="comment"># /home/kay/...</span></span><br><span class="line"><span class="comment"># make -e</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; /home/kay/...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># makefile.1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line">ver := kay</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;make another file ...&quot;</span></span><br><span class="line">	@(MAKE) -f makefile.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile.2</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># make another file ...</span></span><br><span class="line"><span class="comment"># 正在进入目录 &#x27;/home/xxx&#x27;</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># var =&gt;</span></span><br><span class="line"><span class="comment"># 正在离开目录 &#x27;/home/xxx&#x27;	</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处 makefile.2 中输出的 JAVA_HOME 为何还是 makefile.1 中的值呢？</p>
<p>因为 JAVA_HOME 为系统的环境变量，当我们子啊 makefile.1 中改写了 JAVA_HOME 之后，它的生命周期在整个 make 环境中都是有效的；</p>
<p>为什么在 makefile.2 中 var 是无效的呢？</p>
<p>因为 var 是在 makefile.1 中定义的变量，他的生命周期或者说作用域只在 makefile.1 这个文件中有效；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># makefile.1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line"><span class="keyword">export</span> ver := kay</span><br><span class="line">new := hello</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;make another file ...&quot;</span></span><br><span class="line">	@(MAKE) -f makefile.2</span><br><span class="line">	@(MAKE) -f makefile.2 new:=<span class="variable">$(new)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile.2</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># make another file ...</span></span><br><span class="line"><span class="comment"># 正在进入目录 &#x27;/home/xxx&#x27;</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># var =&gt; kay</span></span><br><span class="line"><span class="comment"># new =&gt; hello</span></span><br><span class="line"><span class="comment"># 正在离开目录 &#x27;/home/xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 export 定义的变量可以进行传递，这个变量将在该 makefile 及其所有通过它直接或间接调用（如使用 -f 参数指定或通过 include 指令包含）的子 makefile 中可用；</p>
<p>使用命令行也可以将变量进行传递，作用域和 exprot 类似；</p>
</blockquote>
<h3 id="目标变量-局部变量"><a href="#目标变量-局部变量" class="headerlink" title="目标变量(局部变量)"></a>目标变量(局部变量)</h3><ul>
<li>作用域只在指定目标及连带规则中<ul>
<li>target : name <assignment> value</li>
<li>target : override name <assignment> value</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">var := kay.wang	<span class="comment"># 在当前整个 makefile 中可用</span></span><br><span class="line">test : var := tset-var	<span class="comment"># 只在 tset 这个目标及其连带规则中可用</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: another</span></span><br><span class="line">	@echo <span class="string">&quot;test:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"><span class="section">another:</span></span><br><span class="line">	@echo <span class="string">&quot;another:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test 和 another 中 tset-var 是可用的</span></span><br></pre></td></tr></table></figure>

<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><ul>
<li>模式变量是<strong>目标变量的扩展</strong></li>
<li>作用域只在<strong>符合模式的</strong>目标及连带规则中<ul>
<li>target : name <assignment> value</li>
<li>target : override name <assignment> value</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">new := kay.wang	<span class="comment"># 在当前整个 makefile 中可用</span></span><br><span class="line">%e : <span class="keyword">override</span> new := test-new	<span class="comment"># 只在符合 %e 这个模式的目标及其连带规则中可用</span></span><br><span class="line"></span><br><span class="line"><span class="section">rule:</span></span><br><span class="line">	@echo <span class="string">&quot;rule:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>全局变量：makefile 外部定义的环境变量</li>
<li>文件变量：makefile 中定义的变量</li>
<li>局部变量：制定目标的变量</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>条件判断语句</title>
    <url>/Linux/Make/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>makefile 中支持条件判断语句</p>
<ul>
<li>可以根据<strong>条件的值</strong>来决定 make 的执行</li>
<li>可以<strong>比较</strong>两个不同变量或者变量值和常量值</li>
</ul>
<p><img src="/public/image/Linux/make/tiaojianpanduanyuju.png" alt="tiaojianpanduanyuju"></p>
<blockquote>
<p>注意事项：</p>
<p>条件判断语句只能用于控制 make 实际执行的语句；不能控制规则中命令的执行过程。</p>
</blockquote>
<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><ul>
<li>常用形式<ul>
<li>ifxxx (arg1, arg2)</li>
</ul>
</li>
<li>其他合法形式<ul>
<li>ifxxx “arg1” “arg2”</li>
<li>ifxxx ‘arg1’ ‘arg2’</li>
<li>ifxxx “arg1” ‘arg2’</li>
<li>ifxxx ‘arg1’ “arg2”</li>
</ul>
</li>
</ul>
<p><img src="/public/image/Linux/make/xiaotieshi.png" alt="xiaotieshi"></p>
<h3 id="条件判断关键字"><a href="#条件判断关键字" class="headerlink" title="条件判断关键字"></a>条件判断关键字</h3><table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifeq</td>
<td align="center">判断参数是否相等，相等为 true，否则为 false</td>
</tr>
<tr>
<td align="center">ifneq</td>
<td align="center">判断参数是否不相等，不相等为 true，相等为 false</td>
</tr>
<tr>
<td align="center">ifdef</td>
<td align="center">判断变量是否有值，有值为 true，否则为 false</td>
</tr>
<tr>
<td align="center">ifndef</td>
<td align="center">判断变量是否没有值，没有值为 true，否则为 false</td>
</tr>
</tbody></table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var1 := A</span><br><span class="line">var2 := <span class="variable">$(var1)</span></span><br><span class="line">var3 :=</span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(var1)</span>,<span class="variable">$(var2)</span>) 	<span class="comment"># # 这里前面是空格而不是一个 [Tab]</span></span><br><span class="line">		@echo <span class="string">&quot;var1 == var2&quot;</span>	</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifneq</span> (<span class="variable">$(var2)</span>,)</span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var2</span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifndef</span> var3</span><br><span class="line">		@echo <span class="string">&quot;var3 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var3 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在使用上述条件判断语句时候，前面就不能使用 [Tab] 了，要改为使用空格</p>
</blockquote>
<h3 id="一些工程经验"><a href="#一些工程经验" class="headerlink" title="一些工程经验"></a>一些工程经验</h3><ul>
<li>条件判断语句之前可以有空格，但<strong>不能有 [Tab] 字符</strong>（’\t’）</li>
<li>在条件语句中<strong>不要使用自动变量</strong>（$@、$^、$&lt;）</li>
<li>一条完整的条件语句<strong>必须</strong>位于同一个 makefile 中</li>
<li>条件判断语句类似 C 语言中的宏，<strong>预处理阶段有效，执行阶段无效</strong></li>
<li>make 在加载 makefile 时<ul>
<li>首先计算表达式的值（赋值方式不同，计算方式不同）</li>
<li>根据判断语句的表达式决定执行的内容</li>
</ul>
</li>
</ul>
<blockquote>
<p>此处的预处理阶段是指 make 解释器加载 makefile 的时候，在加载的时候就对条件判断语句进行处理了；除了完成后才会实际去执行 makefile 中的规则；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var1 :=</span><br><span class="line">var2 := <span class="variable">$(var1)</span></span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(var3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#var3 = 3 </span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="keyword">ifdef</span> var1 </span><br><span class="line">		@echo <span class="string">&quot;var1 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var1 is NOT defined&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var2</span><br><span class="line">		@echo <span class="string">&quot;var2 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT defined&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var3 </span><br><span class="line">		@echo <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var4</span><br><span class="line">		@echo <span class="string">&quot;var4 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var4 is NOT defined&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># make</span></span><br><span class="line"> <span class="comment"># var1 is NOT defined</span></span><br><span class="line"> <span class="comment"># var2 is NOT defined</span></span><br><span class="line"> <span class="comment"># var3 is NOT defined</span></span><br><span class="line"> <span class="comment"># var4 is defined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 make 解释器认为 var4 已经定义了，是为什么呢？</p>
<p>因为在预处理阶段 make 解释器在加载 makefile 的时候，根本就无法判断出 var4 的值应该是什么，此时 make 解释器只能判断出var3 的值是空的，但 var4 的值要延迟到加载 makefile 文件的时候才能够得知，所以他就认为 var4 是有值的。</p>
<p>当 var3 &#x3D; 3 时，二者就都是有值的。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>条件判断根据条件的值来决定 make 的执行</li>
<li>条件判断可以比较两个不同变量或者变量和常量的值</li>
<li>条件判断在预处理阶段有效，执行阶段无效</li>
<li>条件判断不能控制规则中命令的执行过程</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>交叉编译是指在主机平台上生成目标平台上的可执行代码。</p>
<p>参与编译和运行的机器根据其角色可以分成以下三类</p>
<ul>
<li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。(生成编译器的电脑)</li>
<li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。(生成应用程序的电脑)</li>
<li>目标(target)系统：<code>运行应用程序</code>的计算机系统。(执行应用程序的电脑)</li>
</ul>
<p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p>
<ul>
<li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li>
<li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式工具介绍</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>参与编译和运行的机器根据其角色可以分成以下三类</p>
<ul>
<li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。(生成编译器的电脑)</li>
<li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。(生成应用程序的电脑)</li>
<li>目标(target)系统：<code>运行应用程序</code>的计算机系统。(执行应用程序的电脑)</li>
</ul>
<p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p>
<ul>
<li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li>
<li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li>
</ul>
<h2 id="调试器-GDB"><a href="#调试器-GDB" class="headerlink" title="调试器 GDB"></a>调试器 GDB</h2><ul>
<li><a href="https://ww.gnu.org/software/gdb">https://ww.gnu.org/software/gdb</a></li>
<li>GDB(The GNU Project Debugger)，GNU 项目调试器，用于查看另一个程序在执行过程中正在执行的操作，或该程序崩溃时正在执行的操作。</li>
<li>被调试的程序可能与 GDB 在同一台计算机上执行，也可能在另一台计算机(远程)上或者在模拟器上执行。</li>
<li>GDB 支持调试多种语言：如 Rust 等。</li>
</ul>
<p><img src="/public/image/OS/os/GDB.png" alt="GDB"></p>
<blockquote>
<p>当执行<code>gdb a.out</code>后发生了什么</p>
<p>本地调试时</p>
<p>gdb运行起来之后他会在本地先 <em>fork</em> 一个子进程去运行 <code>a.out</code>，然后 <em>gdb</em> 本身也会运行在一个子进程中，二者通过 <em>ptrace</em> 这个系统调用建立连接；当你在 <em>gdb</em> 中运行至<code>a.out</code> 中的断点时，他就会把 <code>a.out</code> 这个所在的进程挂起来进入阻塞状态。</p>
<p>远程调试时</p>
<p>首先会在目标机器上启动一个名叫 <em>gdbServer</em> 的远程服务，本地的 <em>gdb</em> 会与 <em>gdbServer</em> 建立连接，由 <em>gdbServer</em> 来代理我们的调试过程; <code>a.out</code> 和 <em>gdbServer</em> 运行在目标机器上。</p>
<p>调试机器和目标机器通过网络进行连接。</p>
</blockquote>
<h3 id="GDB基本调试流程"><a href="#GDB基本调试流程" class="headerlink" title="GDB基本调试流程"></a>GDB基本调试流程</h3><h2 id="模拟器-QEMU"><a href="#模拟器-QEMU" class="headerlink" title="模拟器 QEMU"></a>模拟器 QEMU</h2><ul>
<li><a href="https://www.qemu.org/">https://www.qemu.org/</a></li>
<li>QEMU是一套由(Fabrice Bellard)编写的以 GPL 许可证分发源代码的计算机系统模拟软件，在 GNU&#x2F;Linux 平台上被广泛使用。</li>
<li>支持多种体系架构。譬如：RISC-V、X86等。</li>
<li>QEMU 有两种主要运行模式<ul>
<li>User mode：直接运行应用程序。</li>
<li>System mode：模拟整个计算机系统，包括中央处理器及其他周边设变。</li>
</ul>
</li>
</ul>
<h2 id="项目构造工具-Make"><a href="#项目构造工具-Make" class="headerlink" title="项目构造工具 Make"></a>项目构造工具 Make</h2><ul>
<li><a href="https://ww.gnu.org/software/make/">https://ww.gnu.org/software/make/</a></li>
<li>Make 是什么<ul>
<li>make 是一种自动化工程管理工具。</li>
</ul>
</li>
<li>Makefile 是什么<ul>
<li>配合 make，用于描述构建过程中所管理的对象以及如何构造工程的过程。</li>
</ul>
</li>
<li>Make 如何找到 Makefile<ul>
<li>隐士查找：当前目录下按顺序查找名为”GNUmakefule”、”makefile”、”Makefile”的文件。</li>
<li>显示查找：-f</li>
</ul>
</li>
</ul>
<h3 id="Makefile-的构成"><a href="#Makefile-的构成" class="headerlink" title="Makefile 的构成"></a>Makefile 的构成</h3><ul>
<li><p>Makefile 由一条或者多条规则(fule)构成。</p>
</li>
<li><p>每条规则由三要素构成</p>
<ul>
<li>target：目标，可以是 obj 文件也可以是可执行文件。</li>
<li>prerequisites：生成 target 所需要的依赖。</li>
<li>command：为了生成 target 需要执行的命令，可以有多条。</li>
</ul>
</li>
<li><p>一个简单的 Makefile 如下</p>
</li>
<li><pre><code class="makefile"># 定义 Makefile 中的一些变量名
# = 为简单赋值 := 为赋值展开，即如果后续更改了用于赋值的变量的值，那么这个改变不会影响已经赋值的变量。
TARGET := riscv64gc-unknown-none-elf
MODE := release
APP_DIR := src/bin
TARGET_DIR := target/$(TARGET)/$(MODE)
APPS := $(wildcard $(APP_DIR)/*.rs)
ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))
BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))

OBJDUMP := rust-objdump --arch-name=riscv64
OBJCOPY := rust-objcopy --binary-architecture=riscv64

elf:
    @cargo build --release --target $(TARGET)

binary: elf
    @$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)

build: binary
</code></pre>
</li>
<li><p>行注释以 # 开头</p>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/Linux/Ubuntu/MySQL/</url>
    <content><![CDATA[<h2 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h2><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="安装并设置密码"><a href="#安装并设置密码" class="headerlink" title="安装并设置密码"></a>安装并设置密码</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>目标：</p>
<ul>
<li>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装配置</title>
    <url>/OS/Ubuntu/MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>添加 MySQL APT 存储库</strong></p>
<p> <a href="https://dev.mysql.com/downloads/repo/apt/">MySQL APT 存储库下载页面</a>。</p>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo dpkg -i mysql-apt-config_0.8.32-1_all.deb</span> </span><br></pre></td></tr></table></figure>

<p><strong>更新存储库</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br></pre></td></tr></table></figure>

<p><strong>安装MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install mysql-server</span></span><br></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>1. 停止MySQL服务</strong></p>
<p>在卸载之前，首先需要确保MySQL服务已经停止运行，以防止卸载过程中出现潜在问题。可以使用以下命令来停止MySQL服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop mysql</span><br></pre></td></tr></table></figure>

<p>或者，如果你使用的是较旧的Ubuntu版本，可能需要使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p><strong>2. 卸载MySQL软件包</strong></p>
<p>使用<code>apt-get</code>命令来卸载MySQL服务器及其相关软件包。通常，除了<code>mysql-server</code>外，可能还需要卸载<code>mysql-client</code>和<code>mysql-common</code>等软件包。使用以下命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove --purge mysql-server mysql-client mysql-common</span><br></pre></td></tr></table></figure>

<p><code>--purge</code>选项会卸载软件包并删除其配置文件。</p>
<p><strong>3. 删除MySQL的配置文件和数据目录</strong></p>
<p>尽管<code>apt-get remove --purge</code>命令会删除大多数配置文件，但为了确保彻底卸载，建议手动删除MySQL的配置文件和数据目录。这些文件通常位于<code>/etc/mysql</code>和<code>/var/lib/mysql</code>目录下。使用以下命令进行删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /etc/mysql /var/lib/mysql</span><br></pre></td></tr></table></figure>

<p>此外，有些MySQL版本可能会在<code>/var/log/mysql</code>目录下生成日志文件，你也可以选择删除这些日志文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/log/mysql</span><br></pre></td></tr></table></figure>

<p><strong>4. 清理残留文件和依赖项</strong></p>
<p>使用<code>apt-get autoremove</code>命令来自动删除不再需要的依赖项。此外，<code>apt-get autoclean</code>命令可以清理下载的软件包缓存，但这一步不是必须的，因为它不会直接删除MySQL的残留文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get autoremove  </span><br><span class="line">$ sudo apt-get autoclean</span><br></pre></td></tr></table></figure>

<p><strong>5. 验证卸载结果</strong></p>
<p>为了验证MySQL是否已完全卸载，可以尝试运行<code>mysql</code>命令查看其版本。如果MySQL已成功卸载，系统将显示一个错误消息，指出找不到<code>mysql</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql --version</span><br></pre></td></tr></table></figure>

<p>如果看到类似“Command ‘mysql’ not found, but can be installed with:”的错误消息，则表示MySQL已成功卸载。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>v2raya安装配置</title>
    <url>/OS/Ubuntu/v2raya%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装-v2ray-core"><a href="#安装-v2ray-core" class="headerlink" title="安装 v2ray-core"></a>安装 v2ray-core</h2><p>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/v2fly/v2ray-core</span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo unzip v2ray-linux-64.zip -d /usr/local/v2ray-core</span><br></pre></td></tr></table></figure>

<p>拷贝geoip.dat和geosite.dat到&#x2F;usr&#x2F;local&#x2F;share&#x2F;v2ray&#x2F;：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/share/v2ray/</span><br><span class="line">sudo mv /usr/local/v2ray-core/*dat  /usr/local/share/v2ray/</span><br></pre></td></tr></table></figure>

<h2 id="安装-v2rayA"><a href="#安装-v2rayA" class="headerlink" title="安装 v2rayA"></a>安装 v2rayA</h2><p>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/v2rayA/v2rayA</span><br></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i installer_debian_x64_*.deb</span><br></pre></td></tr></table></figure>

<h2 id="配置-v2rayA"><a href="#配置-v2rayA" class="headerlink" title="配置 v2rayA"></a>配置 v2rayA</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/default/v2raya</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加如下配置</span></span><br><span class="line"></span><br><span class="line">V2RAYA_V2RAY_BIN=/usr/local/v2ray-core/v2ray</span><br><span class="line">V2RAYA_V2RAY_CONFDIR=/usr/local/v2ray-core</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入<span class="string">&quot;:wq!&quot;</span>后可保存更改</span></span><br></pre></td></tr></table></figure>

<p>设置开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now v2raya</span><br><span class="line">sudo systemctl status v2raya </span><br></pre></td></tr></table></figure>

<p>打开v2rayA：<code>v2rayA Web panel</code></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现批处理系统</title>
    <url>/OS/rCore/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h1><p>管理无需或仅需少量用户交互即可运行的程序，在资源允许的情况下它可以自动安排程序的执行。</p>
<p>核心思想为：将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会 <em>自动</em> 加载下一个程序到内存并开始执行。</p>
<h2 id="特权级机制"><a href="#特权级机制" class="headerlink" title="特权级机制"></a>特权级机制</h2><ul>
<li><p><em>保护</em> 计算机系统不受有意或无意出错的程序破坏的机制被称为 <strong>特权级</strong> (Privilege) 机制。</p>
<ul>
<li>应用程序不能执行某些可能破坏计算机系统的指令</li>
</ul>
</li>
<li><p>它让应用程序运行在<strong>用户态</strong>，而操作系统运行在<strong>内核态</strong>，且实现用户态和内核态的隔离。</p>
<ul>
<li>处理器设置两个不同安全等级的执行环境：<strong>用户态特权级的执行环境</strong>和<strong>内核态特权级的执行环境</strong>。且明确指出可能破坏计算机系统的内核态特权级指令子集，规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行这些内核态特权级指令，会产生异常。</li>
</ul>
</li>
<li><p>软硬件协同工作。</p>
</li>
</ul>
<h2 id="模拟客户端应用程序"><a href="#模拟客户端应用程序" class="headerlink" title="模拟客户端应用程序"></a>模拟客户端应用程序</h2><h3 id="创建应用端库"><a href="#创建应用端库" class="headerlink" title="创建应用端库"></a>创建应用端库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new user -lib</span></span><br><span class="line">    Creating library `user` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<p>修改库名</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuos/user/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;user_lib&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Kay &lt;cn.kay.wang@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 这里要改不然后续执行会报错</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">riscv</span> = &#123; git = <span class="string">&quot;https://github.com/rcore-os/riscv&quot;</span>, features = [<span class="string">&quot;inline-asm&quot;</span>] &#125; </span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span> <span class="comment"># 因qemu9.0.0兼容性文件所以要设置</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>lib.rs</code> 中我们定义了用户库的入口点 <code>_start</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性宏从指定库中导入到当前作用域中</span></span><br><span class="line"><span class="keyword">use</span> user_lib::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不修改符号名</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="comment">// 指定.text.entry段入口</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable after sys_exit!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还在 <code>lib.rs</code> 中看到了另一个 <code>main</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标为弱链接，虽然名叫main但不会作为主函数</span></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持上述这些链接操作，我们需要在 <code>lib.rs</code> 的开头加入</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#![feature(linkage)]</span></span><br></pre></td></tr></table></figure>

<h3 id="设置内存布局"><a href="#设置内存布局" class="headerlink" title="设置内存布局"></a>设置内存布局</h3><p>让操作系统能够把应用加载到内存地址，然后顺利启动并运行应用程序。</p>
<ul>
<li><p>在 <code>user/.cargo/config</code> 中，设置链接时使用链接脚本 <code>user/src/linker.ld</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/.cargo/config</span></span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-args=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置内存布局</p>
<ul>
<li>在<code>user/src/linker.ld</code>中设置程序起始地址为<code>0x80400000</code>；</li>
<li>将 <code>_start</code> 所在的 <code>.text.entry</code> 放在整个程序的开头，使得系统只要跳转到<code>0x80400000</code>就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；</li>
<li>提供了最终生成可执行文件的 <code>.bss</code> 段的起始和终止地址，方便 <code>clear_bss</code> 函数使用；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/src/linker.ld</span></span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">BASE_ADDRESS = 0x80400000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        start_bss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">        end_bss = .;</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">        *(.debug*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用系统ABI"><a href="#调用系统ABI" class="headerlink" title="调用系统ABI"></a>调用系统ABI</h3><p>使用RISC-V 提供的机器指令：执行环境调用指令（Execution Environment Call，简称 <code>ecall</code> ）和一类执行环境返回（Execution Environment Return，简称 <code>eret</code> ）指令。其中：</p>
<ul>
<li><code>ecall</code> 具有用户态到内核态的执行环境切换能力的函数调用指令；</li>
<li><code>sret</code> ：具有内核态到用户态的执行环境切换能力的函数返回指令。</li>
</ul>
<p>这里约定如下两个系统调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 功能：将内存中缓冲区中的数据写入文件。</span></span><br><span class="line"><span class="comment">/// 参数：`fd` 表示待写入文件的文件描述符；</span></span><br><span class="line"><span class="comment">///      `buf` 表示内存中缓冲区的起始地址；</span></span><br><span class="line"><span class="comment">///      `len` 表示内存中缓冲区的长度。</span></span><br><span class="line"><span class="comment">/// 返回值：返回成功写入的长度。</span></span><br><span class="line"><span class="comment">/// syscall ID：64</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：退出应用程序并将返回值告知批处理系统。</span></span><br><span class="line"><span class="comment">/// 参数：`exit_code` 表示应用程序的返回值。</span></span><br><span class="line"><span class="comment">/// 返回值：该系统调用不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：93</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure>

<p>由于rust不直接支持寄存器操作，为此我们需要在代码中使用内嵌汇编来完成参数&#x2F;返回值绑定和 <code>ecall</code> 指令的插入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// asm! 宏可以将汇编代码嵌入到局部的函数上下文中。</span></span><br><span class="line">        <span class="comment">// 相比 global_asm!, asm! 宏可以获取上下文中的变量信息并允许嵌入的汇编代码对这些变量进行操作</span></span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有的系统调用都封装成 <code>syscall</code> 函数。</p>
<blockquote>
<p>在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 <code>a0~a6</code> 保存系统调用的参数， <code>a0</code> 保存系统调用的返回值。有些许不同的是寄存器 <code>a7</code> 用来传递 syscall ID，这是因为所有的 syscall 都是通过 <code>ecall</code> 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。</p>
<p><strong>RISC-V 寄存器编号和别名</strong></p>
<p>RISC-V 寄存器编号从 <code>0~31</code> ，表示为 <code>x0~x31</code> 。 其中：</p>
<ul>
<li><code>x10~x17</code> : 对应 <code>a0~a7</code></li>
<li><code>x1</code> ：对应 <code>ra</code></li>
</ul>
<p>在 <code>ecall</code> 指令中<code>a0~a2</code> 和 <code>a7</code> 作为输入寄存器分别表示系统调用参数和系统调用 ID，当系统调用返回后， <code>a0</code> 作为输出寄存器保存系统调用的返回值。</p>
</blockquote>
<p>于是 <code>sys_write</code> 和 <code>sys_exit</code> 只需将 <code>syscall</code> 进行包装：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述两个系统调用在用户库 <code>user_lib</code> 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>console</code> 子模块中 <code>Stdout::write_str</code> 改成基于 <code>write</code> 的实现，且传入的 <code>fd</code> 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 <code>fd</code> 选取情况。这样，应用程序的 <code>println!</code> 宏借助系统调用变得可用了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/console.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STDOUT: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(STDOUT, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit</code> 接口则在用户库中的 <code>_start</code> 内使用，当应用程序主逻辑 <code>main</code> 返回之后，使用它退出应用程序并将返回值告知 底层的批处理系统。</p>
<h3 id="模拟应用程序执行"><a href="#模拟应用程序执行" class="headerlink" title="模拟应用程序执行"></a>模拟应用程序执行</h3><p>尝试在用户态模拟器 <code>qemu-riscv64</code> 执行这两个应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> target/riscv64gc-unknown-none-elf/release/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认待执行的应用为 ELF 格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file 03priv_inst</span></span><br><span class="line">03priv_inst: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行特权指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./03priv_inst</span></span><br><span class="line">Try to execute privileged instruction in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行访问特权级 CSR 的指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./04priv_csr</span></span><br><span class="line">Try to access privileged CSR in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>user/Cargo.toml</code>下要设置</p>
<p>[package]</p>
<p>edition &#x3D; “2018”</p>
<p>[profile.release]</p>
<p>5 1  0opt-level &#x3D; 0</p>
<p>不然几个实例客户端程序将可能会出错</p>
</blockquote>
<h2 id="实现批处理系统"><a href="#实现批处理系统" class="headerlink" title="实现批处理系统"></a>实现批处理系统</h2><ul>
<li>操作系统自身运行在内核态，支持应用程序在用户态运行，且能够完成应用程序发出的系统调用。</li>
<li>能够一个接着一个地自动运行不同的运行程序</li>
</ul>
<p>在具体实现其批处理执行应用程序功能之前，本节我们首先实现该应用加载机制，也即：在操作系统和应用程序需要被放置到同一个可执行文件的前提下，设计一种尽量简洁的应用放置和加载方式，使得操作系统容易找到应用被放置到的位置，从而在批处理操作系统和应用程序之间建立起联系的纽带。具体而言，应用放置采用“静态绑定”的方式，而操作系统加载应用则采用“动态加载”的方式：</p>
<ul>
<li>静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。</li>
<li>动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。</li>
</ul>
<h3 id="将应用程序链接到内核"><a href="#将应用程序链接到内核" class="headerlink" title="将应用程序链接到内核"></a>将应用程序链接到内核</h3><p>利用<code>build.rs</code>脚本文件生成汇编代码将应用程序链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;read_dir, File&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="type">Result</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=../user/src/&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=&#123;&#125;&quot;</span>, TARGET_PATH);</span><br><span class="line">    <span class="title function_ invoke__">insert_app_data</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> TARGET_PATH: &amp;<span class="type">str</span> = <span class="string">&quot;../user/target/riscv64gc-unknown-none-elf/release/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">insert_app_data</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;src/link_app.S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">apps</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="title function_ invoke__">read_dir</span>(<span class="string">&quot;../user/src/bin&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|dir_entry| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name_with_ext</span> = dir_entry.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">into_string</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            name_with_ext.<span class="title function_ invoke__">drain</span>(name_with_ext.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">unwrap</span>()..name_with_ext.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            name_with_ext</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    apps.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">writeln!</span>(</span><br><span class="line">        f,</span><br><span class="line">        <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .align 3</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global _num_app</span></span><br><span class="line"><span class="string">_num_app:</span></span><br><span class="line"><span class="string">    .quad &#123;&#125;&quot;#</span>,</span><br><span class="line">        apps.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..apps.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_start&quot;#</span>, i)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_end&quot;#</span>, apps.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx, app) <span class="keyword">in</span> apps.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;app_&#123;&#125;: &#123;&#125;&quot;</span>, idx, app);</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_start</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_end</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_start:</span></span><br><span class="line"><span class="string">    .incbin &quot;&#123;2&#125;&#123;1&#125;.bin&quot;</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_end:&quot;#</span>,</span><br><span class="line">            idx, app, TARGET_PATH</span><br><span class="line">        )?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>build.rs</code>脚本文件将生成以下类似文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br><span class="line">app_4_end:</span><br></pre></td></tr></table></figure>

<p>将汇编代码链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="找到并加载应用程序二进制码"><a href="#找到并加载应用程序二进制码" class="headerlink" title="找到并加载应用程序二进制码"></a>找到并加载应用程序二进制码</h3><p>创建一个<em>应用管理器</em><code>AppManager</code>用来找到并加载应用程序二进制码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中：</p>
<ul>
<li><code>current_app</code> 字段表示当前执行的是第几个应用，它是一个可修改的变量，会在系统运行期间发生变化。</li>
</ul>
</blockquote>
<p>我们希望将 <code>AppManager</code> 实例化为一个全局变量，使得任何函数都可以直接访问，最简单就是将它设置为<code>static mut</code>，但<code>static mut</code>则是 unsafe 的，而我们要在编程中尽量避免使用 unsafe ，这样才能让编译器负责更多的安全性检查。因此，我们需要使用<code>RefCell</code>，即内部可变性。但要给<code>static</code>类型的变量设置<code>RefCell</code>则必须要实现<code>Sync</code> tarit。为此我们在<code>RefCell</code>上封装一层叫做<code>UPSafeCell</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/sync/up.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// inner data</span></span><br><span class="line">    inner: RefCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; UPSafeCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// User is responsible to guarantee that inner struct is only used in</span></span><br><span class="line">    <span class="comment">/// uniprocessor.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; inner: RefCell::<span class="title function_ invoke__">new</span>(value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Panic if the data has been borrowed.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exclusive_access</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> RefMut&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">borrow_mut</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UPSafeCell</code> 对于 <code>RefCell</code> 简单进行封装，它和 <code>RefCell</code> 一样提供内部可变性和运行时借用检查，只是更加严格：调用 <code>exclusive_access</code> 可以得到它包裹的数据的独占访问权。因此当我们要访问数据时（无论读还是写），需要首先调用 <code>exclusive_access</code> 获得数据的可变借用标记，通过它可以完成数据的读写，在操作完成之后我们需要销毁这个标记，此后才能开始对该数据的下一次访问。相比 <code>RefCell</code> 它不再允许多个读操作同时存在。</p>
<p>这段代码里面出现了两个 <code>unsafe</code> ：</p>
<ul>
<li>首先 <code>new</code> 被声明为一个 <code>unsafe</code> 函数，是因为我们希望使用者在创建一个 <code>UPSafeCell</code> 的时候保证在访问 <code>UPSafeCell</code> 内包裹的数据的时候始终不违背上述模式：即访问之前调用 <code>exclusive_access</code> ，访问之后销毁借用标记再进行下一次访问。这只能依靠使用者自己来保证，但我们提供了一个保底措施：当使用者违背了上述模式，比如访问之后忘记销毁就开启下一次访问时，程序会 panic 并退出。<code>unsafe</code> 关键字本身无法提供上述保障，这个关键字主要是给用户一个警告和提示。这个保证在单核的情况下可以由借用检查器给到。</li>
<li>另一方面，我们将 <code>UPSafeCell</code> 标记为 <code>Sync</code> 使得它可以作为一个全局变量。这是 unsafe 行为，因为编译器无法确定我们的 <code>UPSafeCell</code> 能否安全的在多线程间共享。而我们能够向编译器做出保证，第一个原因是目前我们内核仅运行在单核上，因此无需在意任何多核引发的数据竞争&#x2F;同步问题；第二个原因则是它基于 <code>RefCell</code> 提供了运行时借用检查功能，从而满足了 Rust 对于借用的基本约束进而保证了内存安全。</li>
</ul>
<p>初始化<code>AppManager</code>的全局实例<code>APP_MANAGER</code></p>
<p>这里我们使用了外部库 <code>lazy_static</code> 提供的 <code>lazy_static!</code> 宏。</p>
<p>添加依赖</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = &#123; version = <span class="string">&quot;1.4.0&quot;</span>, features = [<span class="string">&quot;spin_no_std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>lazy_static!</code> 宏进行初始化工作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="keyword">fn</span> <span class="title function_">_num_app</span>(); &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =  core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">        app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">        AppManager &#123;</span><br><span class="line">            num_app,</span><br><span class="line">            current_app: <span class="number">0</span>,</span><br><span class="line">            app_start,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现跨特权级的系统接口调用"><a href="#实现跨特权级的系统接口调用" class="headerlink" title="实现跨特权级的系统接口调用"></a>实现跨特权级的系统接口调用</h3><h3 id="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"><a href="#执行系统调用前后能够准备和恢复用户态执行应用程序的上下文" class="headerlink" title="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"></a>执行系统调用前后能够准备和恢复用户态执行应用程序的上下文</h3><h3 id="支持多个应用程序轮流启动运行"><a href="#支持多个应用程序轮流启动运行" class="headerlink" title="支持多个应用程序轮流启动运行"></a>支持多个应用程序轮流启动运行</h3><h2 id="二者之间的特权级切换"><a href="#二者之间的特权级切换" class="headerlink" title="二者之间的特权级切换"></a>二者之间的特权级切换</h2><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>环境配置</title>
    <url>/OS/rCore/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h2><h3 id="WSL2配置"><a href="#WSL2配置" class="headerlink" title="WSL2配置"></a>WSL2配置</h3><p><strong>1.勾选适用于Linux的Windows子系统</strong>后<strong>重启</strong></p>
<p>打开“<strong>控制面板</strong>”-&gt;点击”<strong>程序</strong>“-&gt;在“<strong>程序和功能</strong>”中-&gt;点击“<strong>启用或关闭 Windows 功能</strong>”-&gt; 选中“<strong>适用于 Linux 的 Windows 子系统</strong>”-&gt;选择”<strong>立即重新启动</strong>“；</p>
<p><strong>2.启用虚拟机功能</strong></p>
<p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed">虚拟化功能</a>才能使用此功能。</p>
<p>以管理员身份打开 PowerShell 并运行：</p>
<p><strong>点击“开始”-&gt;搜索“Power shell”-&gt;右键“Power shell”-&gt;已管理员方式运行</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>此处最好重启一下不然后续启动arch Linux时会报错<strong>error: 0x8004032d(null)</strong></p>
<blockquote>
<p>如何没有安装 PowerShell 建议直接从 Microsoft Store 中搜索并下载</p>
</blockquote>
<p><strong>3.下载Linux内核更新包</strong></p>
<p>从<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">官网</a>下载最新的Linux内核更新包并<strong>安装</strong>；</p>
<p><strong>管理员</strong>身份打开PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl.exe <span class="literal">--update</span></span><br><span class="line">正在检查更新。</span><br><span class="line">已安装最新版本的适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure>

<p>这里如果安装进度一直为0.0%可以试下开启科学上网；</p>
<p><strong>4.将WSL2设置为默认版本</strong></p>
<p>打开 PowerShell运行以下命令，将 WSL 2 设置为默认版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">有关与 WSL <span class="number">2</span> 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure>

<p><strong>5.安装所选的Linux分发</strong></p>
<p>打开 <a href="https://aka.ms/wslstore">Microsoft Store</a>，并选择你偏好的 Linux 分发版。（我这里使用的是arch Linux）</p>
<p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。</p>
<p>然后，需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">为新的 Linux 分发版创建用户帐户和密码</a>。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Installing,this may take a few minutes...</span><br><span class="line">Iainstallation successful!</span><br><span class="line">Please create a default UNIX user account, The username does not needor to match your windows username.</span><br><span class="line"><span class="keyword">For</span> more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username:</span><br></pre></td></tr></table></figure>

<p>这里要关掉科学上网，不然<strong>Microsoft Store</strong>可能会打不开；</p>
<p><strong>6.查看当前环境的wsl版本和对应子系统</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 在Windows终端中键入</span><br><span class="line">&gt; wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line">  NAME    STATE           VERSION</span><br><span class="line">* Arch    Running         <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>7.注销安装的Linux子系统账户</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--unregister</span> Arch</span><br></pre></td></tr></table></figure>

<p>（名称要与wsl -l -v 命令中NAME一致）</p>
<p><strong>8.删除安装的Linux子系统</strong></p>
<p>系统 -&gt; 应用 -&gt; 安装的应用 删除Arch WSL。</p>
<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu // 防止软件库更新导致某些功能无法使用</span><br><span class="line">sudo pacman -S neovim</span><br><span class="line">sudo nvim /etc/pacman.conf 尾部添加</span><br><span class="line"></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/$repo/$arch</span><br><span class="line"></span><br><span class="line">顺便开启</span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">sudo pacman -Syyu</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>

<h3 id="C-Rust环境配置"><a href="#C-Rust环境配置" class="headerlink" title="C&#x2F;Rust环境配置"></a>C&#x2F;Rust环境配置</h3><p><strong>1.更新&#x2F;同步arch Linux内核</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>

<p><strong>这里cmd中需要管理员模式启动</strong>（WSL2中不要开梯子）</p>
<p><strong>2.C开发环境配置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git base-devel riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full riscv64-elf-gdb</span><br></pre></td></tr></table></figure>

<p><strong>3.Rust开发环境配置</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.<span class="number">2</span> -sSf https:<span class="comment">//sh.rustup.rs | sh</span></span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo --version // 如果cargo无效则重新打开终端进入Linux即可</span></span><br><span class="line">cargo 1.77.1 (e52e36006 2024-03-26)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.77.1 (7cf61ebde 2024-03-27)</span><br></pre></td></tr></table></figure>

<p>切换 nightly 版本，并设置为 rustc 的缺省版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br></pre></td></tr></table></figure>

<p>安装一些Rust相关的软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure>

<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qemu</span><br></pre></td></tr></table></figure>

<p>三个选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)qemu-base   2)qemu-desktop   3)qemu-full</span><br></pre></td></tr></table></figure>

<p>第一个提示中提示中选择<code>3</code>，第二个提示默认<code>1</code>即可。</p>
<p><strong>确认 QEMU 的版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 --version</span></span><br><span class="line">qemu-riscv64 version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>获取代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br></pre></td></tr></table></figure>

<p>在Qemu模拟的计算机上运行: （第一次可能会有些很慢）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line">(rustup target list | grep &quot;riscv64gc-unknown-none-elf (installed)&quot;) || rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">riscv64gc-unknown-none-elf (installed)</span><br><span class="line">cargo install cargo-binutils</span><br><span class="line">    Updating crates.io index</span><br><span class="line">     Ignored package `cargo-binutils v0.3.6` is already installed, use --force to override</span><br><span class="line">rustup component add rust-src</span><br><span class="line">info: component &#x27;rust-src&#x27; is up to date</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line">info: component &#x27;llvm-tools&#x27; for target &#x27;x86_64-unknown-linux-gnu&#x27; is up to date</span><br><span class="line">Platform: qemu</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) in 0.00s</span><br><span class="line">[rustsbi] RustSBI version 0.3.1, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e010f6</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[TRACE] [kernel] .text [0x80200000, 0x80202000)</span><br><span class="line">[DEBUG] [kernel] .rodata [0x80202000, 0x80203000)</span><br><span class="line">[ INFO] [kernel] .data [0x80203000, 0x80204000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80214000, lower_bound=0x80204000</span><br><span class="line">[ERROR] [kernel] .bss [0x80214000, 0x80215000)</span><br></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>1.当你在wsl2环境下运行<code>code</code>命令时报错<code>-bash: code: command not found</code>时：</p>
<ul>
<li>在vscode中安装<code>Remote Development</code>扩展包。</li>
<li>设置Windows下环境变量<code>D:\tools\IDE\VSCode\VSCode\bin</code>(一定要到bin下)</li>
</ul>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><h3 id="C-Rust环境配置-1"><a href="#C-Rust环境配置-1" class="headerlink" title="C&#x2F;Rust环境配置"></a>C&#x2F;Rust环境配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// C开发环境</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span></span><br><span class="line"></span><br><span class="line">// Rust开发环境</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://sh.rustup.rs -sSf | sh</span></span><br><span class="line"></span><br><span class="line">// 安装 rustc 的 nightly 版本，并把该版本设置为 rustc 的缺省版本。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"></span><br><span class="line">// 安装一些Rust相关的软件包</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure>

<h3 id="QEMU模拟器"><a href="#QEMU模拟器" class="headerlink" title="QEMU模拟器"></a>QEMU模拟器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装编译所需的依赖包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span></span><br><span class="line"><span class="language-bash">              gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span></span><br><span class="line"><span class="language-bash">              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev libslirp-dev \</span></span><br><span class="line"><span class="language-bash">              git tmux python3 python3-pip ninja-build</span></span><br><span class="line">              </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Qemu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install qemu-system</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install qemu-user</span></span><br></pre></td></tr></table></figure>

<h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>应用程序与基本执行环境</title>
    <url>/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="创建一个bin项目"><a href="#创建一个bin项目" class="headerlink" title="创建一个bin项目"></a>创建一个bin项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new os --bin</span></span><br><span class="line">    Creating binary (application) `os` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<h2 id="移除执行环境对操作系统的依赖"><a href="#移除执行环境对操作系统的依赖" class="headerlink" title="移除执行环境对操作系统的依赖"></a>移除执行环境对操作系统的依赖</h2><h3 id="1-添加目标平台"><a href="#1-添加目标平台" class="headerlink" title="1.添加目标平台"></a>1.添加目标平台</h3><ol>
<li>我们要构建一个可以在裸机上运行的 RISC-V架构的操作系统，那么就需要添加对目标平台的支持：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/os</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version --verbose</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 385fa9d845dd326c6bbfd58c22244215e431948a</span><br><span class="line">commit-date: 2024-04-04</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.79.0-nightly</span><br><span class="line">LLVM version: 18.1.2</span><br></pre></td></tr></table></figure>

<p>这条命令有几个作用：</p>
<ol>
<li><p><strong>识别目标平台：</strong></p>
<ul>
<li><code>riscv64gc</code> 表示 RISC-V 64位通用计算（General-Purpose Computing）架构（ CPU 架构）。</li>
<li><code>unknown</code> 表示 Rust 不了解这个目标的操作系统或供应商信息（CPU 厂商）。</li>
<li><code>none</code> 表示没有操作系统，这通常用于裸机编程（操作系统）。</li>
<li><code>elf</code> 表示没有标准的运行时库（没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序（运行时库）。</li>
</ul>
</li>
<li><p><strong>安装必要组件：</strong>如果 <code>rustup</code> 有为 <code>riscv64gc-unknown-none-elf</code> 准备的预编译组件，它会尝试下载并安装这些组件。</p>
</li>
<li><p><strong>更新Rust工具链配置：</strong>在 Rust 配置中添加对新目标的支持，这样当你使用 <code>cargo build --target riscv64gc-unknown-none-elf</code> 命令时，Cargo 就会知道如何为 <code>riscv64gc-unknown-none-elf</code> 目标构建你的项目。</p>
</li>
</ol>
<p>可以使用如下命令查看当前Rust工具链支持的所有目标平台:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target list</span></span><br></pre></td></tr></table></figure>

<p>2.在 <code>tuos</code> 目录下新建 <code>.cargo</code> 目录，并在这个目录下创建 <code>config</code> 文件，并在里面输入如下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">#  tuos/os/.cargo/config</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会对于 Cargo 工具在 os 目录下的行为进行调整：<strong>现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu。</strong></p>
<h3 id="2-移除标准库依赖"><a href="#2-移除标准库依赖" class="headerlink" title="2.移除标准库依赖"></a>2.移除标准库依赖</h3><p>我们希望它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/os/src/main.rs</span><br><span class="line"><span class="comment">// 告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）;</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 注释掉println!宏,它是由标准库 std 提供的且会使用到一个名为 write 的系统调用;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加错误处理机制"><a href="#3-添加错误处理机制" class="headerlink" title="3.添加错误处理机制"></a>3.添加错误处理机制</h3><p>Rust编译器在编译程序时，从安全性考虑，需要有 <code>panic!</code> 宏的具体实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/lang_items.rs</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="comment">// 指定一个函数作为程序的 panic 处理程序。</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把 <code>panic_handler</code> 配置在单独的文件 <code>tuos/src/lang_items.rs</code> 后，需要在os&#x2F;src&#x2F;main.rs文件中添加以下内容才能正常编译整个软件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br></pre></td></tr></table></figure>

<h3 id="4-移除标准main函数"><a href="#4-移除标准main函数" class="headerlink" title="4.移除标准main函数"></a>4.移除标准main函数</h3><p>应用程序在执行之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 <code>main</code> 函数）开始执行。 <code>start</code> 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。最简单的解决方案就是压根不让编译器使用这项功能。我们在 <code>main.rs</code> 的开头加入设置 <code>#![no_main]</code> 告诉编译器我们没有一般意义上的 <code>main</code> 函数，并将原来的 <code>main</code> 函数删除。在失去了 <code>main</code> 函数的情况下，编译器也就不需要完成所谓的初始化工作了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 禁用标准main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 删掉 自带的main函数</span></span><br></pre></td></tr></table></figure>

<p>至此，我们成功移除了标准库的依赖，并完成了构建裸机平台上操作系统的第一步工作–通过编译器检查并生成执行码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>

<h2 id="验证Qemu模拟器与执行环境是否正确可用"><a href="#验证Qemu模拟器与执行环境是否正确可用" class="headerlink" title="验证Qemu模拟器与执行环境是否正确可用"></a>验证Qemu模拟器与执行环境是否正确可用</h2><p>下面我们将实践在 Qemu 上执行内核的第一条指令,用以检验环境是否正确可用。</p>
<h3 id="编写内核第一条指令"><a href="#编写内核第一条指令" class="headerlink" title="编写内核第一条指令"></a>编写内核第一条指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line">    .section .text.entry # .section: 定义或切换到一个特定的代码段 .text.enery代码段</span><br><span class="line">    .globl _start        # 告知编译器 _start 是一个全局符号,可以被其他目标文件使用</span><br><span class="line">_start:                  # 全局符号,指向下面的(li x1, 100)</span><br><span class="line">    li x1, 100           # 立即数 100 被加载到了寄存器 x1 中</span><br></pre></td></tr></table></figure>

<p>一般情况下，所有的代码都被放到一个名为 <code>.text</code> 的代码段中，这里我们将其命名为 <code>.text.entry</code> 从而区别于其他 <code>.text</code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p>
<blockquote>
<p> 常见的 x86、RISC-V 等架构采用的是小端序。</p>
</blockquote>
<p><strong>将汇编代码嵌入<code>main.rs</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="comment">// 移除标准库</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 移除main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 载入模块</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line"><span class="comment">// global_asm!宏：嵌入全局汇编代码;include_str!宏：文件的内容作为一个字符串嵌入到程序中;</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于 <code>main</code> 函数和 <code>global_asm!</code> 的执行顺序，重要的是理解它们的作用和上下文：</strong></p>
<ul>
<li><p><strong>global_asm!</strong>: 这个宏用于在编译时嵌入汇编代码。这些汇编代码通常用于设置中断向量表、初始化硬件或其他低级设置。这些代码在二进制文件的开始或特定段中，并且在程序开始执行时就已经存在。<em>它们并不是在运行时执行的代码，而是作为二进制文件的一部分存在</em>。</p>
</li>
<li><p><strong>main 函数</strong>: 在 Rust 程序中，<code>main</code> 函数是程序的入口点。当程序开始执行时，它首先会跳转到 <code>main</code> 函数。<em>在 <code>main</code> 函数之前，任何全局的初始化代码（包括通过 <code>global_asm!</code> 嵌入的汇编代码）都应该已经完成</em>。</p>
</li>
</ul>
</blockquote>
<h3 id="调整内核的内存布局"><a href="#调整内核的内存布局" class="headerlink" title="调整内核的内存布局"></a>调整内核的内存布局</h3><p>由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/.cargo/config</span></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“-Clink-arg&#x3D;-Tsrc&#x2F;linker.ld” ：告诉 Rust 编译器在链接阶段使用 <code>src/linker.ld</code> 作为链接器脚本</li>
<li>“-Cforce-frame-pointers&#x3D;yes” : 强制编译器在生成的代码中包含帧指针。</li>
</ul>
</blockquote>
<p>链接脚本 <code>os/src/linker.ld</code> 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)	# 设置了目标平台为 riscv;</span><br><span class="line">ENTRY(_start)	# 设置了整个程序的入口点为之前定义的全局符号 _start;</span><br><span class="line">BASE_ADDRESS = 0x80200000;	# 定义了一个常量 BASE_ADDRESS 为 0x80200000 ,内核的初始化时的地址;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>；</p>
<p>第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code> ，也就是我们之前提到内核的初始化代码被放置的地址；</p>
<p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code>.</code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符来书写 <code>&lt;ObjectFile&gt;</code> 和 <code>&lt;SectionName&gt;</code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）。</p>
<p>第 12 行我们将包含内核第一条指令的 <code>.text.entry</code> 段放在最终的 <code>.text</code> 段的最开头，同时注意到在最终内存布局中代码段 <code>.text</code> 又是先于任何其他段的。因为所有的段都从 <code>BASE_ADDRESS</code> 也即 <code>0x80200000</code> 开始放置，这就能够保证内核的第一条指令正好放在 <code>0x80200000</code> 从而能够正确对接到 Qemu 上。</p>
<p>生成内核可执行文件，切换到 <code>os</code> 目录下进行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 release 模式生成了内核可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.06s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 file 工具查看它的属性</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file target/riscv64gc-unknown-none-elf/release/os</span></span><br><span class="line">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>

<h3 id="手动加载内核可执行文件"><a href="#手动加载内核可执行文件" class="headerlink" title="手动加载内核可执行文件"></a>手动加载内核可执行文件</h3><p>使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cargo build --release</code>后得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。所以我们需要将其元数据丢弃</p>
</blockquote>
<h3 id="基于GDB验证启动流程"><a href="#基于GDB验证启动流程" class="headerlink" title="基于GDB验证启动流程"></a>基于GDB验证启动流程</h3><p>在 <code>os</code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span></span><br><span class="line"><span class="language-bash">    -s -S</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code>-S</code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 <code>-s -S</code> 。</p>
<p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-elf-gdb \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span></span><br><span class="line">[GDB output]</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code>0x1000</code> 。我们可以检查一下 Qemu 的启动固件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) x/10i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      add     a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      .2byte  0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure>

<p>这里 <code>x/10i $pc</code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code>0x1018</code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code>unimp</code> 指令。 <code>0x101a</code> 处的数据 <code>0x8000</code> 是能够跳转到 <code>0x80000000</code> 进入启动下一阶段的关键。总之，在执行位于 <code>0x1014</code> 的指令之前，寄存器 <code>t0</code> 的值恰好为 <code>0x80000000</code> ，随后通过 <code>jr t0</code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$t0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x80000000</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>其中， <code>si</code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code>p/x $t0</code> 以 16 进制打印寄存器 <code>t0</code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code>$</code> 。可以看到，当位于 <code>0x1010</code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code>0x80000000</code> ，这意味着我们即将把控制权转交给 RustSBI 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:  auipc   sp,0x29</span><br><span class="line">   0x80000004:  add     sp,sp,-200</span><br><span class="line">   0x80000008:  lui     t0,0x4</span><br><span class="line">   0x8000000a:  add     t1,a0,1</span><br><span class="line">   0x8000000e:  add     sp,sp,t0</span><br><span class="line">   0x80000010:  add     t1,t1,-1</span><br><span class="line">   0x80000012:  bnez    t1,0x8000000e</span><br><span class="line">   0x80000016:  j       0x80015e0c</span><br><span class="line">   0x8000001a:  unimp</span><br><span class="line">   0x8000001c:  add     sp,sp,-32</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000e in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) b *0x80200000</span></span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) c</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们在内核的入口点，也即地址 <code>0x80200000</code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code>*</code> 。接下来通过 <code>c</code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code>0x80200000</code> 处。随后，可以检查内核第一条指令是否被正确执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x80200000:  li      ra,100</span><br><span class="line">   0x80200004:  unimp</span><br><span class="line">   0x80200006:  unimp</span><br><span class="line">   0x80200008:  unimp</span><br><span class="line">   0x8020000a:  unimp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080200004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/d <span class="variable">$x1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$sp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x0</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们在 <code>entry.asm</code> 中编写的第一条指令可以在 <code>0x80200000</code> 处找到。这里 <code>ra</code> 是寄存器 <code>x1</code> 的别名， <code>p/d $x1</code> 可以以十进制打印寄存器 <code>x1</code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code>sp</code> 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p>
<h2 id="设置栈空间以及内核初始化"><a href="#设置栈空间以及内核初始化" class="headerlink" title="设置栈空间以及内核初始化"></a>设置栈空间以及内核初始化</h2><h3 id="分配栈空间"><a href="#分配栈空间" class="headerlink" title="分配栈空间"></a>分配栈空间</h3><p>我们在 <code>entry.asm</code> 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 <code>sp</code> 设置为栈顶的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line"></span><br><span class="line">    .section .text.entry	# 定义一个段</span><br><span class="line">    .globl _start	# 定义一个全局符号</span><br><span class="line">_start:	# 程序入口</span><br><span class="line">    la sp, boot_stack_top	# 立即将 boot_stack_top 的地址加载到栈指针 sp 中</span><br><span class="line">    call main # 调用一个名为main的子程序</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16	# 为数据段分配一定数量的空间。</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:		# 表示为栈顶 ,上文_start程序入口加载的位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上所述，这段代码定义了程序的入口点 <code>_start</code>，并设置了一个栈空间，栈的顶部是 <code>boot_stack_top</code>，底部是 <code>boot_stack_lower_bound</code>，总共 64KB。程序从 <code>_start</code> 开始执行，首先设置栈指针，然后调用 Rust 编写的 <code>main</code> 函数。</p>
</blockquote>
<h3 id="编写入口函数"><a href="#编写入口函数" class="headerlink" title="编写入口函数"></a>编写入口函数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要对该函数名进行修饰，以便其他语言就可以通过该原始名称来链接和调用 Rust 函数或访问 Rust 变量。</span></span><br><span class="line"><span class="comment">// 这里面的main名字要与汇编代码中指定的入口子函数名称一致</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-bss-段的清零"><a href="#对-bss-段的清零" class="headerlink" title="对 .bss 段的清零"></a>对 <code>.bss</code> 段的清零</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对.bss段清零</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数 <code>clear_bss</code> 中，我们会尝试从其他地方找到全局符号 <code>sbss</code> 和 <code>ebss</code> ，它们由链接脚本 <code>linker.ld</code> 给出，并分别指出需要被清零的 <code>.bss</code> 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。</p>
</blockquote>
<h2 id="使用RustSBI-实现字符打印功能"><a href="#使用RustSBI-实现字符打印功能" class="headerlink" title="使用RustSBI 实现字符打印功能"></a>使用RustSBI 实现字符打印功能</h2><p>RustSBI 通过实现 SBI 标准，使得操作系统能够利用RISC-V处理器的指令集系统来执行各种操作。</p>
<h3 id="调用-SBI-服务"><a href="#调用-SBI-服务" class="headerlink" title="调用 SBI 服务"></a>调用 SBI 服务</h3><p><strong>在 <code>Cargo.toml</code> 中引入 sbi_rt 依赖来调用 SBI 服务的接口：</strong></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 因为兼容问题Qemu9.0.0在进行后续学习时候或出错，故将版次改为 2018	</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sbi-rt</span> = &#123; version = <span class="string">&quot;0.0.2&quot;</span>, features = [<span class="string">&quot;legacy&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>我们将内核与 RustSBI 通信的相关功能实现在子模块 <code>sbi</code> 中，因此我们需要在 <code>main.rs</code> 中加入 <code>mod sbi</code> 将该子模块加入我们的项目。在 <code>os/src/sbi.rs</code> 中，我们直接调用 sbi_rt 提供的接口来将输出字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line"></span><br><span class="line"># os/src/sbi.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// #[allow(deprecated)]属性来禁止编译器发出警告,对于某些已经弃用的方法。</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    sbi_rt::legacy::<span class="title function_ invoke__">console_putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现关机功能"><a href="#实现关机功能" class="headerlink" title="实现关机功能"></a>实现关机功能</h3><p><strong>实现关机功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/sbi.rs</span></span><br><span class="line">pub fn shutdown(failure: bool) -&gt; ! &#123;</span><br><span class="line">    use sbi_rt::&#123;system_reset, NoReason, Shutdown, SystemFailure&#125;;</span><br><span class="line">    if !failure &#123;</span><br><span class="line">        system_reset(Shutdown, NoReason);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        system_reset(Shutdown, SystemFailure);</span><br><span class="line">    &#125;</span><br><span class="line">    unreachable!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/console.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成内核镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Qemu模拟器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结果如图：</span></span><br><span class="line">[rustsbi] RustSBI version 0.4.0-alpha.1, adapting to RISC-V SBI v2.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.3</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e01290</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello, world!</span><br><span class="line">Panicked at src/main.rs:23 Shutdown machine!</span><br></pre></td></tr></table></figure>

<h2 id="程序内存布局与编译流程"><a href="#程序内存布局与编译流程" class="headerlink" title="程序内存布局与编译流程"></a>程序内存布局与编译流程</h2><h3 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h3><p>在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下所示：</p>
<p><img src="/public/image/OS/tuos/MemoryLayout.png" alt="MemoryLayout"></p>
<p>在上图中可以看到，代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：</p>
<ul>
<li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。</li>
<li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；</li>
<li><strong>堆</strong> （heap）区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 malloc&#x2F;new 分配到的数据本体就放在堆区域，它向高地址增长；</li>
<li><strong>栈</strong> （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。</li>
</ul>
<blockquote>
<p><strong>局部变量与全局变量</strong></p>
<p>在一个函数的视角中，它能够访问的变量包括以下几种：</p>
<ul>
<li>函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；</li>
<li>全局变量：保存在数据段 <code>.data</code> 和 <code>.bss</code> 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。</li>
<li>堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 <em>直接</em> 访问栈上或者全局数据段中的 <strong>编译期确定大小</strong> 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。</li>
</ul>
</blockquote>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：</p>
<ul>
<li><p><strong>编译器</strong> (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；</p>
</li>
<li><p><strong>汇编器</strong> (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 <strong>目标文件</strong> (Object File)；</p>
</li>
<li><p><strong>链接器</strong> (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。</p>
</li>
</ul>
<p>汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：</p>
<ul>
<li>第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 <code>1.o</code> 和 <code>2.o</code> 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 <code>output.o</code> 中。注意到，目标文件 <code>1.o</code> 和 <code>2.o</code> 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。</li>
</ul>
<p>​	<img src="/public/image/tuos/MemoryLayout-Linker.png" alt="MemoryLayout-Linker"></p>
<ul>
<li><p>第二件事情是将符号替换为具体地址。这里的符号指什么呢？我们知道，在我们进行模块化编程的时候，每个模块都会提供一些向其他模块公开的全局变量、函数等供其他模块访问，也会访问其他模块向它公开的内容。要访问一个变量或者调用一个函数，在源代码级别我们只需知道它们的名字即可，这些名字被我们称为符号。取决于符号来自于模块内部还是其他模块，我们还可以进一步将符号分成内部符号和外部符号。然而，在机器码级别（也即在目标文件或可执行文件中）我们并不是通过符号来找到索引我们想要访问的变量或函数，而是直接通过变量或函数的地址。例如，如果想调用一个函数，那么在指令的机器码中我们可以找到函数入口的绝对地址或者相对于当前 PC 的相对地址。</p>
<p>那么，符号何时被替换为具体地址呢？因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 <code>.bss</code> 或者 <code>.data</code> 段中，而函数则放在 <code>.text</code> 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。当一个模块被转化为目标文件之后，它的内部符号就已经在目标文件中被转化为具体的地址了，因为目标文件给出了模块的内存布局，也就意味着模块内的各个段的位置已经被确定了。然而，此时模块所用到的外部符号的地址无法确定。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。由于后续可能还需要重定位，内部符号也同样需要被记录在符号表中。</p>
<p>外部符号需要等到链接的时候才能被转化为具体地址。假设模块 1 用到了模块 2 提供的内容，当两个模块的目标文件链接到一起的时候，它们的内存布局会被合并，也就意味着两个模块的各个段的位置均被确定下来。此时，模块 1 用到的来自模块 2 的外部符号可以被转化为具体地址。同时我们还需要注意：两个模块的段在合并后的内存布局中被重新排布，其最终的位置有可能和它们在模块自身的局部内存布局中的位置相比已经发生了变化。因此，每个模块的内部符号的地址也有可能会发生变化，我们也需要进行修正。上面的过程被称为重定位（Relocation），这个过程形象一些来说很像拼图：由于模块 1 用到了模块 2 的内容，因此二者分别相当于一块凹进和凸出一部分的拼图，正因如此我们可以将它们无缝地拼接到一起。</p>
</li>
</ul>
<p>上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 <code>0x80200000</code> 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 <code>0x80200000</code> 的区域并未分配给内核，而是主要由 RustSBI 使用。其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust数据内存布局</title>
    <url>/Rust/basic/Rust%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p><strong>整数类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>u8</code></td>
<td>0</td>
<td>28-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>u16</code></td>
<td>0</td>
<td>216-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>u32</code></td>
<td>0</td>
<td>232-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>u64</code></td>
<td>0</td>
<td>264-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>u128</code></td>
<td>0</td>
<td>2128-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)align(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>i8</code></td>
<td>-(27)</td>
<td>27-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>i16</code></td>
<td>-(215)</td>
<td>215-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>i32</code></td>
<td>-(231)</td>
<td>231-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>i64</code></td>
<td>-(263)</td>
<td>263-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>i128</code></td>
<td>-(2127)</td>
<td>2127-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<p><strong>浮点数</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td>f32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>f64</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>f64 在 x86 系统上对齐到 4 bytes。</p>
<p><strong>usized &amp; isized</strong></p>
<p>usize 无符号整形，isize 有符号整形。 在 64 位系统上，长度为 8 bytes，在 32 位系统上长度为 4 bytes。</p>
<p><strong>bool</strong></p>
<p>bool 类型，取值为 true 或 false，长度和对齐长度都是 1 byte。</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>数组的内存布局为系统类型元组的有序组合。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">A</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 大小: 12</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::align_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 对齐: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p><strong>char 类型</strong></p>
<p>char 表示：一个 32 位长度字符，Unicode 标量值 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Value</a> 范围为 in the 0x0000 - 0xD7FF 或者是 0xE000 - 0x10FFFF。</p>
<p><strong>str 类型</strong></p>
<p>str 与 [u8] 一样表示一个 u8 的 slice。Rust 中标准库中对 str 有个假设：符合 UTF-8 编码。内存布局与 [u8] 相同。</p>
<blockquote>
<p>[u8]是一个字节切片的类型，而不是一个固定大小的数组。切片是对数组的引用或数组部分的一个动态视图，允许你访问一个连续的内存区域，就像访问一个数组一样，但切片本身并不拥有其引用的数据。</p>
<p><code>[u8; N]</code>：这是一个固定大小的字节数组，其中 <code>N</code> 是数组的长度。例如，<code>[u8; 4]</code> 是一个包含四个 <code>u8</code> 元素的数组。</p>
<p>二者要注意不要搞混了</p>
</blockquote>
<p><strong>slice</strong></p>
<p>slice 是 DST 类型，是类型 T 序列的一种视图。 slice 的使用必须要通过指针，&amp;[T] 是一个胖指针，保存指向<code>数据的地址</code>和<code>元素个数</code>。 <code>slice 的内存布局与其指向的 array 部分相同</code>。</p>
<p><strong>&amp;str 与 String 的区别</strong></p>
<p>下面给出 &amp;str String 的内存结构比对：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">my_name.<span class="title function_ invoke__">push_str</span>( <span class="string">&quot; Precht&quot;</span>);</span><br><span class="line"><span class="comment">// str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">last_name</span> = &amp;my_name[<span class="number">7</span>..];</span><br></pre></td></tr></table></figure>

<p>String</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                     buffer</span><br><span class="line">                   /   capacity</span><br><span class="line">                 /   /  length</span><br><span class="line">               /   /   /</span><br><span class="line">            +–––+–––+–––+</span><br><span class="line">stack frame │ • │ 8 │ 6 │ &lt;- my_name: String</span><br><span class="line">            +–│–+–––+–––+</span><br><span class="line">              │</span><br><span class="line">            [–│–––––––– capacity –––––––––––]</span><br><span class="line">              │</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">            [––––––– length ––––––––]</span><br></pre></td></tr></table></figure>

<p>String vs &amp;str</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">         my_name: <span class="type">String</span>   last_name: &amp;<span class="type">str</span></span><br><span class="line">            [––––––––––––]    [–––––––]</span><br><span class="line">            +–––+––––+––––+–––+–––+–––+</span><br><span class="line">stack frame │ • │ <span class="number">16</span> │ <span class="number">13</span> │   │ • │ <span class="number">6</span> │  <span class="comment">// &amp;str 没有 capacity</span></span><br><span class="line">            +–│–+––––+––––+–––+–│–+–––+</span><br><span class="line">              │                 │</span><br><span class="line">              │                 +–––––––––+</span><br><span class="line">              │                           │</span><br><span class="line">              │                           │</span><br><span class="line">              │                         [–│––––––– <span class="type">str</span> –––––––––]</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">			[––––––––––––––––––––––––––– my_name –––––––––––––––––––––––––––]</span><br><span class="line">										[–––––––––––– last_name ––––––––––––]</span><br></pre></td></tr></table></figure>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>结构体是带命名的复合类型，有以下几种</p>
<p><strong>具名结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元组结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br></pre></td></tr></table></figure>

<p><strong>单元结构体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Gamma;</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong></p>
<blockquote>
<p>数据对齐</p>
<p>数据对齐是指将数据存储在内存中时，按照特定的规则将数据放置在内存地址上的一种方式。</p>
<p>数据对齐的主要目的是为了提高数据读取效率。当CPU访问正确对齐的数据时，它的运行效率最高。若数据没有对齐，CPU在读取或写入数据时可能需要进行多次操作，这会降低CPU的效率，增加系统的开销。</p>
<p>编译器优化 -&gt; 字段重排</p>
<p>Rust编译器在优化结构体时，可能会进行字段重排（field reordering），这是为了优化内存访问、提高数据缓存的效率，以及确保数据满足平台的内存对齐要求。</p>
<p>Rust编译器的字段重排是一种优化技术，旨在提高程序的性能和内存使用效率。</p>
</blockquote>
<p>Rust 中结构体的对齐属性等于<code>它所有成员中最大的那个</code>。Rust 会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时<code>整个类型的尺寸是对齐属性的整数倍</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>, <span class="comment">// 1B</span></span><br><span class="line">    b: <span class="type">u32</span>, <span class="comment">// 4B</span></span><br><span class="line">    c: <span class="type">u16</span>, <span class="comment">// 2B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印下变量地址，可以根据结果看到对齐属性为 4, 结构大小为 8 byte 。</span></span><br><span class="line"><span class="comment">// 1 + 4 + 2 = 7</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = A &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x&#123;:X&#125; 0x&#123;:X&#125; 0x&#123;:X&#125;&quot;</span>, &amp;a.a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">usize</span>, &amp;a.b <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u32</span> <span class="keyword">as</span> <span class="type">usize</span> , &amp;a.c <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u16</span> <span class="keyword">as</span> <span class="type">usize</span> );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;A&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0x327EFBF35E</span> <span class="number">0x327EFBF358</span> <span class="number">0x327EFBF35C</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rust编译器会进行内存重排，并填充所需大小(这里是1B)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    b: <span class="type">u32</span>,</span><br><span class="line">    c: <span class="type">u16</span>,</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">    _pad: [<span class="type">u8</span>; <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1字段顺序：data2(0), count(4), data1(6) </span></span><br><span class="line"><span class="comment">// foo1字段顺序：data1(8), count(c), data2(e) </span></span><br><span class="line"><span class="comment">// 可以看到编译器会改变 Foo&lt;T, U&gt; 中成员顺序。</span></span><br><span class="line"><span class="comment">// 内存优化原则要求不同的范型可以有不同的成员顺序。 如果不优化的可能会造成如下情况，造成大量内存开销：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u16</span>, <span class="type">u32</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u16</span>,</span><br><span class="line">    data2: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u32</span>, <span class="type">u16</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    _pad1: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u32</span>,</span><br><span class="line">    data2: <span class="type">u16</span>,</span><br><span class="line">    _pad2: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是匿名的复合类型，有以下几种 tuple：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">() (unit)</span><br><span class="line">(<span class="type">f64</span>, <span class="type">f64</span>)</span><br><span class="line">(<span class="type">String</span>, <span class="type">i32</span>)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">String</span>) (different <span class="keyword">type</span> <span class="title class_">from</span> the previous example)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>tuple 的结构和 Struct 一致，只是元素是通过 index 进行访问的。</p>
<h2 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h2><p>闭包相当于一个捕获变量的结构体，实现了<code>FnOnce</code>或<code>FnMut</code>或<code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;F : <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>&gt; (g: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">g</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">f</span>(|| &#123;</span><br><span class="line">    s += &amp;t;</span><br><span class="line">    s</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prints &quot;foobar&quot;.</span></span><br></pre></td></tr></table></figure>



<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><h2 id="Dynamically-Sized-Types-DST"><a href="#Dynamically-Sized-Types-DST" class="headerlink" title="Dynamically Sized Types(DST)"></a>Dynamically Sized Types(DST)</h2><h2 id="零大小类型-ZST-Zero-Sized-Type"><a href="#零大小类型-ZST-Zero-Sized-Type" class="headerlink" title="零大小类型(ZST, Zero Sized Type)"></a>零大小类型(ZST, Zero Sized Type)</h2><h2 id="空类型-Empty-Types"><a href="#空类型-Empty-Types" class="headerlink" title="空类型(Empty Types)"></a>空类型(Empty Types)</h2><h2 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust版本概述</title>
    <url>/Rust/basic/Rust%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>Rust语言的版本主要包括<code>语义化版本</code>、<code>发行版本</code>、<code>Edition版次</code>三个相互正交的概念。</p>
<h1 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h1><ul>
<li><p>格式：主版本号.次版本号.修订号，以此用 . 隔开</p>
<p>主版本号：当做了不兼容的 API 修改。</p>
<p>次版本号：当做了向下兼容的功能性递增。</p>
<p>修订号：   当做了向下兼容的问题修正。</p>
</li>
</ul>
<h1 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h1><p>master -&gt; Nightly：开发版；</p>
<p>bata -&gt; Beta：测试版；</p>
<p>stable -&gt; Stable：稳定版；</p>
<h1 id="Edition版次"><a href="#Edition版次" class="headerlink" title="Edition版次"></a>Edition版次</h1><p>版次的意义在于方便<code>Rust</code>自身的进化，保证新的变化不会影响自身原有的生态系统。</p>
<p>类似于<code>Java</code>中编译器用于区分<code>Java8</code>与<code>Java17</code>这样的不兼容版本。</p>
<p>不同版次编译的代码可以互相依赖不影响使用(2021版次的代码可以引用2015版次编译的库)。</p>
<ol>
<li>2015 Edition</li>
<li>2018 Edition</li>
<li>2021 Edition</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust编译期计算</title>
    <url>/Rust/basic/Rust%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="Rust-编译期计算"><a href="#Rust-编译期计算" class="headerlink" title="Rust 编译期计算"></a>Rust 编译期计算</h2><p><em>CTFE</em>(compile time function evaluation)：是指在编译阶段由编译器进行的运算，这种运算不占用程序运行时的时间。</p>
<p>两种方式：</p>
<ul>
<li><p>过程宏 + Build脚本(build.rs)</p>
</li>
<li><p>常量表达式求值</p>
<ul>
<li>常量函数(const fn)</li>
<li>常量泛型(const generic)</li>
</ul>
</li>
</ul>
<p><strong>常量传播</strong>：常量传播是编译器的一种优化方式，例如将3 + 4 优化为 7 ，避免运行时再次计算。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> X: <span class="type">u32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// CTEF</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 不是 CTEF,但可能会被常量传播优化，因为他不在常量上下文。</span></span><br></pre></td></tr></table></figure>

<h3 id="常量表达式求值"><a href="#常量表达式求值" class="headerlink" title="常量表达式求值"></a>常量表达式求值</h3><p><strong>常量函数</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">fib</span>(n: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">helper</span>(n: <span class="type">u128</span>, a: <span class="type">u128</span>, b: <span class="type">u128</span>, i: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt;= n &#123;</span><br><span class="line">            <span class="title function_ invoke__">helper</span>(n, b, a + b, i + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">helper</span>(n, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> X: <span class="type">u128</span> = <span class="title function_ invoke__">filb</span>(<span class="number">10</span>); <span class="comment">// X 会在编译器完成求值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, X); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译期计算通过 MIR(中级中间语言) 中内置的 MIri(编译器内置 MIR 解释器) 实现</p>
</blockquote>
<p><strong>常量泛型</strong></p>
<p>为什么要有常量泛型？</p>
<p>因为在 Rust 中定义相同的静态数组是不同的元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二者是不同的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">3</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">5</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为了在使用过程中可以使用泛型统一个的不同长度的数组，官方引入了常量泛型的概念。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::MaybeUninit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ArrayVec</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    items: [MaybeUninit&lt;T&gt;; N],</span><br><span class="line">    length: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程宏-Build脚本-build-rs"><a href="#过程宏-Build脚本-build-rs" class="headerlink" title="过程宏 + Build脚本(build.rs)"></a>过程宏 + Build脚本(build.rs)</h3>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust编译过程</title>
    <url>/Rust/basic/Rust%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Rust 编译过程</strong></p>
<p><img src="/public/image/Rust/basic/rust-complie-process.png" alt="rust-complie-process"></p>
<p>直接使用源代码非常不方便且容易出错。因此在我们做任何其他事情之前，我们将原始源代码转换为 AST。即使这样做也涉及大量工作，包括词法分析、解析、 宏扩展、名称解析、条件编译、功能门控 AST的检查和验证。</p>
<p>值得注意的是，这些任务之间并不总是有明确的顺序。例如，宏扩展依赖于名称解析来解析宏和 imports。解析需要宏扩展，而这反过来又可能需要分析宏的输出。</p>
<p><strong>步骤说明</strong>：</p>
<ol>
<li><p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，编译器的 Lexing 会获取字符编码并将他们转换为<code>token Steam</code>，然后解析 token Stream 将它们转换为结构化的编译器更容易使用的表单，通常称为<code>抽象语法树</code>(AST)  。</p>
<p>请注意，在解析为 AST 时 ，Rust编译器会对其进行<em>词法分析</em>包括但不限于宏扩展、名称解析、#[test]实现、panic实现、AST验证、Feature 检查、检索 Lang 项目等。</p>
</li>
<li><p>AST 降低到  <em>HIR</em>(高级中间表示) </p>
<p>HIR 是抽象语法树 (AST) 对编译器更友好的表示形式，很多 Rust 语法糖在这一阶段，已经被脱糖（desugared）处理。比如 <code>for</code> 循环和<code>while(let)</code>在这个阶段会被转为<code>loop</code>，<code>if let</code> 被转为<code>match</code>，普遍<code>impl Trait</code>转换为泛型参数，存在<code>impl Trait</code>转换为虚拟声明<code>existential type</code>等等。</p>
<p>对于编译器来说，所有的版次也就是Edition版本，在到达中间语言层次的时候已经消除了版次差异。</p>
</li>
<li><p>HIR 降低到 <em>THIR</em>(类型化高级中间表示)</p>
<p>THIR 是 rustc 在类型检查后生成的另一种IR，它用于MIR建设、详尽性检查和不安全检查。是一个在在 HIR 的基础上进一步添加了类型信息的版本。</p>
</li>
<li><p>THIR 降级为 <em>MIR</em>(中级中间表示)</p>
<p>它是 Rust 的一种彻底简化的形式，用于 某些对流量敏感的安全检查——特别是借用检查器！– 也用于优化和代码生成。</p>
</li>
</ol>
<blockquote>
<p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，通过分词把词法结构处理为词条流，词条流经过语法解析形成<code>抽象语法树</code>，抽象语法树降级（简化）为<code>高级中间语言</code>（<em>HIR</em>），高级中间语言被用于编译器对代码进行类型检查方法查找等工作，高级中间语言继续降级（简化）为<code>中级中间语言</code>（<em>MIR</em>），中级中间语言被用于借用检查、优化、代码生成（宏、泛型、单态化）等工作，中级中间语言（MIR）优化为<code>LLVM中间语言</code>，最后交给LLVM编译器生成机器码。</p>
</blockquote>
<p><a href="https://rustc-dev-guide.rust-lang.org/the-parser.html">Rust 编译器开发指南</a></p>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rustc_part1.html">Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1 - Rust精选</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>crate与模块</title>
    <url>/Rust/basic/crate%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="crate与模块"><a href="#crate与模块" class="headerlink" title="crate与模块"></a>crate与模块</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode中的Rust配置</title>
    <url>/Rust/basic/vscode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装必要插件"><a href="#安装必要插件" class="headerlink" title="安装必要插件"></a>安装必要插件</h1><ul>
<li>rust-analyzer ：Rust 插件</li>
<li>Dependi ：crate 相关插件</li>
<li>Even Better TOML ：TOML 语法高亮</li>
</ul>
<h1 id="一些非必要但是好用的-crate"><a href="#一些非必要但是好用的-crate" class="headerlink" title="一些非必要但是好用的 crate"></a>一些非必要但是好用的 crate</h1><ul>
<li>cargo-edit: 该工具扩展了Cargo，允许您通过从命令行修改Cargo.toml文件来添加、删除和升级依赖项。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">任意目录下</span></span><br><span class="line">cargo install cargo-edit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和闭包</title>
    <url>/Rust/basic/%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="常规函数"><a href="#常规函数" class="headerlink" title="常规函数"></a>常规函数</h2><p><strong>特点</strong></p>
<ul>
<li>函数都拥有显示的类型签名；</li>
<li>函数可分为三种类型：<strong>自由函数</strong>、<strong>关联函数</strong>和<strong>方法</strong>；</li>
<li>函数自身也是一种类型(<strong>函数项类型</strong>)</li>
</ul>
<p><strong>自由函数</strong></p>
<p>最普通的函数，他的参数、返回值等都一目了然。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自由函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关联函数 &#x2F; 方法</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    	a + b</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数项类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> (<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="comment">// 此处存在一个自动解引用 Self::sum((*self).0, (*self).1) </span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// add 是 函数项类型 也就是函数自己本身的类型(Fn item 类型)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = A::sum; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_math</span> = A::math; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>), A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_math</span>(&amp;a),a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">    <span class="comment">// 大小为 0 函数项类型是零大小类型(指那些没有占用任何内存空间的类型)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add_math)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;A)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a)); <span class="comment">// 大小为 8 (4（i32）+ 4（i32）= 8)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 函数指针类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>)); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;c)); <span class="comment">// 大小为 8 函数指针类型  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针类型  </span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">rgb</span>: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB;  </span><br><span class="line">    <span class="comment">// 将函数项赋值给函数指针  </span></span><br><span class="line">	rgb = color; </span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rgb: &#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;rgb)); <span class="comment">// 函数项大小为 0 函数项是零大小类型  </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结论：</strong></p>
<ul>
<li>函数项类型可以通过显式指定函数类型转换为一个函数指针类型；</li>
<li>在写代码的时候，尽可能地去使用 <em>函数项类型</em>，不到万不得已不要使用函数指针类型，这样有助于享受零大小类型的优化；</li>
</ul>
</blockquote>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>函数无法捕获环境变量，这时就需要使用闭包。</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">inc</span>(n: <span class="type">i32</span>)<span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">		n+i <span class="comment">//error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    &#125;</span><br><span class="line">	inc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">3</span>，<span class="title function_ invoke__">f</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包与函数的异同"><a href="#闭包与函数的异同" class="headerlink" title="闭包与函数的异同"></a>闭包与函数的异同</h2><p><strong>闭包可以捕获环境中的自由变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> | n | n + i <span class="comment">// move 关键字将环境变量 i 的所有权移动到闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包可以与函数指针互通</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = color;</span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="comment">// 定义了实现`Fn(&amp;str) -&gt; RGB`trait 的闭包类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = | s: &amp;<span class="type">str</span> | &#123; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#125;; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(c); <span class="comment">// (1, 2, 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rust闭包的实现原理"><a href="#Rust闭包的实现原理" class="headerlink" title="Rust闭包的实现原理"></a>Rust闭包的实现原理</h2><p>rust中的闭包并没有引入特殊的语法，而是一种编译器的语法糖。</p>
<h3 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h3><ol>
<li>未捕获环境变量(所有权)</li>
<li>捕获但修改环境变量(可变引用)</li>
<li>捕获但未修改环境变量(不可变引用)</li>
</ol>
<p><strong>未捕获环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 未捕获环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">c1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    env_var: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 FnOnce trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		type Output;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">FnOnce</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Closure &#123; env_var: ()&#125;; <span class="comment">// 闭包未捕获任何变量用()来表示</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_once</span>(()); <span class="comment">// c 这个结构体示例就会被消耗掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你创建闭包的时候，编译器会解析你的闭包，然后生成一个匿名结构体<code>Closure</code>，其中的字段<code>env_var</code>用于存储捕获的自由变量；在上面的场景中闭包未捕获任何变量,所以<code>main</code>函数中创建<code>Closure</code>的字段值用<code>()</code>来表示；</p>
<p>接下来在为这个匿名的结构体<code>Closure</code>实现<code>FnOnce&lt;()&gt;</code>这个trait；其中<code>Arges</code>这个参数是闭包自身的参数，即闭包调用时传入的参数；</p>
<p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_once</code>这个方法；该方法会消耗掉该结构体的实例；</p>
</blockquote>
<p>编译器将<code>FnOnce</code>类型的闭包看成是函数指针</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || &#123; <span class="string">&quot;c1&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = || &#123; <span class="string">&quot;c2&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2]; <span class="comment">// Ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;c3&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123; i &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2, c3] <span class="comment">// Error  expected fn pointer, found closure 他把c1, c2当成了函数指针，c3当成了闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>捕获可修改环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 可修改环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c2</span> = | i | &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">c2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: [<span class="type">i32</span>, <span class="number">3</span>],  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 FnMut trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		// type Output; 因为 FnMut 实现自 FnOnce 所以此处不需要再重复定义了</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">            <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closuse &#123; env_var: arr &#125;;</span><br><span class="line">    <span class="comment">// c.call_once((0, )); 同样这里也会消耗 c</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_mut</span>((<span class="number">0</span>, )); <span class="comment">// 这里会修改 c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处根据<code>rust-call</code>的约定 <code>args</code>的参数类型必须是元组类型，这是<code>Rust API</code>的约定；</p>
<p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_mut</code>这个方法；该方法会修改该结构体的实例；</p>
</blockquote>
<p><strong>捕获但未修改环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">anwser</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            anwser</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">c3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: <span class="type">i32</span>,  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;( )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 Fn trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fn</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">anwser</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closure &#123;env_var: anwser&#125;;</span><br><span class="line">    <span class="comment">//c.call_once((0, )); </span></span><br><span class="line">    <span class="comment">//c.call_mut((0, ));</span></span><br><span class="line">    c.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出要实现<code>Fn</code>必须先实现<code>FnMut</code>，要实现<code>FnMut</code>必须先实现<code>FnOnce</code>；</p>
</blockquote>
<h3 id="实现总结"><a href="#实现总结" class="headerlink" title="实现总结"></a>实现总结</h3><p><strong>这里指的是编译器生成的默认结构体</strong></p>
<ul>
<li>如果没有捕获任何变量，则实现<code>FnOnce</code></li>
<li>如果有捕获变量，且对捕获变量进行了修改，则实现<code>FnMut</code></li>
<li>如果有捕获变量，但未对变量进行修改，则实现<code>Fn</code></li>
</ul>
<p><strong>两条特殊情况</strong></p>
<ul>
<li>编译器会将<code>FnOnce</code>当成<code>fn(T)</code>函数指针去看待。</li>
<li><code>Fn</code>&#x2F;<code>FnMut</code>&#x2F;<code>FnOnce</code>这三者t<code>rait</code>的关系是依次继承，他们正好对应<em>所有权语义三件套</em>。</li>
<li><code>Fn()</code>是<code>FnMut()</code>的子特型，而<code>FnMut()</code>是<code>FnOnce()</code>的子特型，</li>
</ul>
<h2 id="逃逸闭包与非逃逸闭包"><a href="#逃逸闭包与非逃逸闭包" class="headerlink" title="逃逸闭包与非逃逸闭包"></a>逃逸闭包与非逃逸闭包</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span></span><br><span class="line"><span class="comment">// 此处 impl FnMut(i32) -&gt; [i32; 3] 称为 impl trait</span></span><br><span class="line"><span class="comment">// 语法表示 任意一个实现了 FnMut(i32) -&gt; [i32; 3] 的类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">c_mut</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> [<span class="type">i32</span>; <span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// i 是 FnMut(i32) 中传入的</span></span><br><span class="line">    <span class="comment">// 闭包会复制一份 arr 到闭包中，arr 实现了 Copy</span></span><br><span class="line">    <span class="comment">// 从而实现将局部变量移出到其他位置</span></span><br><span class="line">    <span class="keyword">move</span> |i| &#123;arr[<span class="number">0</span>] = i; arr&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr_clouse</span> = <span class="title function_ invoke__">c_mut</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr_clouse.call_once((i, )));</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">arr_clouse</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回不在函数调用过程中被销毁的闭包称为<strong>逃逸闭包</strong>，否则就是<strong>非逃逸闭包</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">c_mut2</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">for</span>&lt;<span class="symbol">&#x27;a</span>&gt;<span class="title function_ invoke__">FnMut</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">move</span> |i| &#123;s += i; s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mut</span> = arr_clouse = <span class="title function_ invoke__">c_mut2</span>(); <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，<code>s</code>是一个动态大小的类型，当<code>move</code>移动时，移动的是指向推上的指针；根据<code>Rust</code>内存管理机制，<code>s</code>销毁后,他所指向的堆上的数据也会被销毁掉，这是<code>move</code>中的<code>s</code>就变成了<em>悬垂指针</em>，这是<code>rust</code>所不允许的。</p>
<h2 id="唯一不可变引用"><a href="#唯一不可变引用" class="headerlink" title="唯一不可变引用"></a>唯一不可变引用</h2><p>捕获方式中有一种被称为<em>唯一不可变借用</em>的特殊类型的借用捕获，这种借用不能在语言的其他任何地方使用，也不能显式地写出。唯一不可变借用发生在<strong>修改可变引用的引用对象(referent)时</strong>，如下面的示例所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里 x 是不可变借用</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = || &#123;(*x)[<span class="number">0</span>] = <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// Error</span></span><br><span class="line">        <span class="title function_ invoke__">c</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = &amp;x; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，不能去可变借用 <code>x</code>，因为 <code>x</code> 没有标注 <code>mut</code>。但与此同时，如果不可变借用 <code>x</code>，那对其赋值又会非法，因为 <code>&amp; &amp;mut</code> 引用可能不是唯一的，因此此引用不能安全地用于修改值。所以这里闭包使用了唯一不可变借用：它采用了不可变的方式借用了 <code>x</code>，但是又像可变借用一样，当然前提是此借用必须是唯一的。在上面的例子中，解开 <code>y</code> 那行上的注释将产生错误，因为这将违反闭包对 <code>x</code> 的借用的唯一性；<code>z</code> 的声明是有效的，因为闭包的生存期在块结束时已过期，从而已经释放了对 <code>x</code> 的借用。</p>
<h2 id="闭包自身所实现的trait"><a href="#闭包自身所实现的trait" class="headerlink" title="闭包自身所实现的trait"></a>闭包自身所实现的trait</h2><ul>
<li>Sized（默认实现）</li>
<li>Copy &#x2F; Clone（取决于环境变量是否实现）<ul>
<li>如果环境变量实现了 Copy &#x2F; Clone，闭包如果以<strong>可变借用方式</strong>捕获环境变量，并对其进行修改，则闭包自身不会实现 Copy &#x2F; Clone;（防止出现多个闭包的可变借用）</li>
<li>如果环境自身是 Move 语义，则闭包内捕获环境变量的操作涉及<strong>修改环境变量或者消耗环境变量</strong>，则闭包自身不会实现 Copy &#x2F; Clone；（防止出现多个闭包的可变借用）</li>
</ul>
</li>
<li>Sync &#x2F; Send<ul>
<li>如果所有捕获变量均实现了 Sync,则闭包实现 Sync;</li>
<li>如果环境变量都不是[唯一不可变引用]方式捕获的，并且都实现了 Sync,则闭包实现 Send;</li>
<li>如果环境变量是以[唯一不可变引用]、[可变引用]、Copy 或 Move 所有权捕获的，那闭包实现 Send;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/Rust/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>基于栈的原因，先定义的后释放</strong></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>trait</title>
    <url>/Rust/basic/trait/</url>
    <content><![CDATA[<h1 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>(<span class="type">i8</span>，<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>=<span class="title function_ invoke__">A</span>(<span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> =a; <span class="comment">// (Bit-wise Copy)按位复制，复制后，b和a完全相同，包括内存对齐填充的padding部分。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>=<span class="title function_ invoke__">A</span>(a.<span class="number">0</span>，a.<span class="number">1</span>); <span class="comment">// 逐成员复制，非按位复制，c和a的padding部分不一定相同。</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>按位复制他们的内存布局是完全相同的，成员复制则不一定相同。</strong></p>
 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u16</span>,</span><br><span class="line">    b: <span class="type">u8</span>,</span><br><span class="line">    c: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">unsound_a</span>();</span><br><span class="line">    <span class="comment">// 尝试将 Some(a) 改为 a 可以发现 Some 本身带有一个检查的效果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_a</span> = <span class="title function_ invoke__">Some</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:#?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;some_a: &#123;:#?&#125;&quot;</span>, some_a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">unsound_a</span>() <span class="punctuation">-&gt;</span> A &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        a: <span class="type">u16</span>,</span><br><span class="line">        b: <span class="type">u8</span>,</span><br><span class="line">        c: <span class="type">u8</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次修改 c 的值为 0，1，2 打印输出结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = B &#123; a: <span class="number">1</span>, b: <span class="number">1</span>, c: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;*(&amp;b <span class="keyword">as</span> *<span class="keyword">const</span> B <span class="keyword">as</span> *<span class="keyword">const</span> A) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// let b = B &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: true,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some(</span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: true,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// let b = B &#123; a: 1, b: 1, c: 0 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: false,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some( </span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: false,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// let b = B &#123; a: 1, b: 1, c: 2 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: true,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some( // let some_a = Some(a); 输出False; let some_a = a; 输出 None</span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: true,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>可以发现 Some 本身带有一个检查的效果</strong></p>
 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;ptr, mem&#125;;</span><br><span class="line"><span class="keyword">use</span> std::men::needs_drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">d</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cccc&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d_len</span> = d.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="type">String</span>::<span class="title function_ invoke__">with_capacity</span>(d_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// ptr::copy：从原(&amp;d)中copy一份(1 usize)大小的内容到目标区域(&amp;mut c)中</span></span><br><span class="line">            <span class="comment">// 此处 d 是栈上的一个指针</span></span><br><span class="line">            <span class="comment">// 相当于将 d 指向 &quot;cccc&quot; 的地址复制了一份到 c 中</span></span><br><span class="line">            <span class="comment">// 此时就存在了一个双重引用; d 和 c 都指向了&quot;cccc&quot;这块堆内存的区域</span></span><br><span class="line">            ptr::<span class="title function_ invoke__">copy</span>(&amp;d, &amp;<span class="keyword">mut</span> c, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">        <span class="comment">// unsafe &#123;</span></span><br><span class="line">        <span class="comment">//     assert_eq!(needs_drop::&lt;*mut u8&gt;, false);  //成立</span></span><br><span class="line">        <span class="comment">//     ptr::drop_in_place(c.as_mut_ptr());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 注掉 drop，会产生double free，</span></span><br><span class="line">        <span class="comment">// 但是不注掉 drop，会产生无效指针</span></span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, d.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">    d.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0x5630bd63f9b0</span></span><br><span class="line"><span class="comment">// 0x5630bd63f9b0</span></span><br><span class="line"><span class="comment">// c  </span></span><br><span class="line"><span class="comment">// 之所以输出一个 C 是因为在上面的作用域中 C 在离开作用域时将 d 指向的那部分内存drop掉了。</span></span><br><span class="line"><span class="comment">// 但是因为有 d 这个引用指向&quot;cccc&quot;区域，所以暂时内存不会被清理，但是会被标识为不可用。</span></span><br><span class="line"><span class="comment">// 所以此时给 d 追加一个&quot;c&quot;,d 中的内容应该是,一部分不可用的内容加上&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy 不一定只在栈上进行</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line">        *b.<span class="title function_ invoke__">borrow_mut</span>() = *a.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;    </span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, a) // Error</span></span><br><span class="line">    </span><br><span class="line">    a = <span class="string">&quot;32&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a)  <span class="comment">// 32</span></span><br><span class="line">    <span class="comment">// a 会在此处释放 相当于在此处进行  drop(a)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述可以看出 Move 的本质是 Rust 编译期把这个 a 变量重新进行了一个未初始化的标记，并不是立刻进行 drop，它会将 drop 延后到函数末尾释放</strong></p>
<h1 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h1><p>析构函数时，按照栈先进后出的顺序进行析构，变量按照内存布局进行析构；</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/Rust/basic/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>生命周期</title>
    <url>/Rust/basic/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="late-early-bound"><a href="#late-early-bound" class="headerlink" title="late&#x2F;early bound"></a>late&#x2F;early bound</h1><p>晚限定与早限定</p>
<h2 id="late-bound"><a href="#late-bound" class="headerlink" title="late bound"></a>late bound</h2><p>这也是最普遍的生命周期的理解。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>  = A::&lt;<span class="type">i32</span>&gt;(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ==============================================================</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123; s1 &#125; <span class="keyword">else</span> &#123; s2&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1_r</span> = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">the_longest</span>(s1_r, &amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is the longest&quot;</span>, res); <span class="comment">// Rust is the longest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>晚限定，就是对象在被定义的时候，他的泛型类型是没有被限定(为具体类型)的，只有在实际调用的时候才会被限定为是何类型。</p>
<p>在定义<code>the_longest</code>时只是确定了他们生命周期之间的关系；只有在具体的使用的时候，我们才需要判断个生命周期的实例，与上面函数中定义的是否一致。</p>
<p>生命周期参数只是开发与与编译期之间的一种约定，对实际代码的运行不做影响。</p>
<p>这一切是在编译期完成的。</p>
<h2 id="early-bound"><a href="#early-bound" class="headerlink" title="early bound"></a>early bound</h2><p>鸿蒙：</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>定义自己的Crate</title>
    <url>/Rust/basic/%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84Crate/</url>
    <content><![CDATA[<h1 id="创建自己的-Crate"><a href="#创建自己的-Crate" class="headerlink" title="创建自己的 Crate"></a>创建自己的 Crate</h1><p>安装<code>cargo-edit</code>工具，他扩展了<code>cargo</code>的功能</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下下</span></span><br><span class="line"></span><br><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>cargo add toml：将最新的<code>toml</code> Crate安装到当前项目中，并自动写入当前目录下的<code>Cargo.toml</code>文件中。</li>
</ul>
<h1 id="代码重构实践"><a href="#代码重构实践" class="headerlink" title="代码重构实践"></a>代码重构实践</h1><h1 id="探索引入模块的最佳实践"><a href="#探索引入模块的最佳实践" class="headerlink" title="探索引入模块的最佳实践"></a>探索引入模块的最佳实践</h1>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>异步Web实战</title>
    <url>/Rust/project/%E5%BC%82%E6%AD%A5Web%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h2 id="rust编码规范"><a href="#rust编码规范" class="headerlink" title="rust编码规范"></a>rust编码规范</h2><p>新建<code>.rustfmt.toml</code>文件用于帮助你写出地道的rust代码。</p>
<p>Rustfmt 的设计非常易于配置。您可以创建一个名为 <code>rustfmt.toml</code>或 的TOML 文件<code>.rustfmt.toml</code>，将其放在项目或任何其他父目录中，它将应用该文件中的选项。</p>
<p>这需要将rust设置为<code>nightly</code>时才可使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>

<p>在当前工作目录中的 Cargo 项目上运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo +nightly fmt</span><br><span class="line"></span><br><span class="line"># rustfmt lib.rs main.rs 将就只格式化“lib.rs”和“main.rs”</span><br><span class="line"># rustfmt lib.rs --check 检查 lib.rs 文件的格式，并给出修改意见，不进行格式化</span><br></pre></td></tr></table></figure>

<h2 id="学习axum"><a href="#学习axum" class="headerlink" title="学习axum"></a>学习axum</h2><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><strong>1.cargo-edit工具</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Toml文件插件</strong></p>
<p><code>TOML Language Support</code></p>
<p><strong>3. cratescha插件</strong></p>
<p><code>crates</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-实战</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/Rust/basic/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p><strong>Lazy</strong> 特性</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类型</title>
    <url>/Rust/basic/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Vec"><a href="#Vec" class="headerlink" title="Vec&lt;T&gt;"></a>Vec&lt;T&gt;</h1><p>动态可增长数组；</p>
<h1 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque&lt;T&gt;"></a>VecDeque&lt;T&gt;</h1><p>基于环形换冲突的先进先出双端队列；</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList&lt;T&gt;"></a>LinkedList&lt;T&gt;</h1><p>非侵入式双向链表实现；</p>
<h1 id="BinaryHeap"><a href="#BinaryHeap" class="headerlink" title="BinaryHeap&lt;T&gt;"></a>BinaryHeap&lt;T&gt;</h1><p>二叉堆实现，可用作优先队列</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap&lt;K, V&gt;"></a>HashMap&lt;K, V&gt;</h1><h1 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap&lt;K, V&gt;"></a>BTreeMap&lt;K, V&gt;</h1><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet&lt;T&gt;"></a>HashSet&lt;T&gt;</h1><h1 id="BTreeSet"><a href="#BTreeSet" class="headerlink" title="BTreeSet&lt;T&gt;"></a>BTreeSet&lt;T&gt;</h1>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装与配置</title>
    <url>/%E5%89%8D%E7%AB%AF/nodejs/nodejs%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://nodejs.org/">Node.js</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下一步即可</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1.在你需要的目录下新建两个文件夹【node_global】和【node_cache】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\tools\SDK\nodejs\configuration\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;D:\tools\SDK\nodejs\configuration\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>【此电脑】-单击右键【属性】-【高级系统设置】-【环境变量】</p>
<p>2.在【系统变量】中点击【新建】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_PATH</span><br><span class="line">D:\tools\SDK\nodejs\configuration\node_global\node_modules</span><br></pre></td></tr></table></figure>

<p>3.编辑【用户变量】中的【Path】</p>
<p>将默认C盘下【AppData\Roaming\npm】修改为【node_global】的路径</p>
<p>4.在【系统变量】中选择【Path】添加【%NODE_PATH%】</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>keil 中先把项目建好</p>
<p>安装</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/chuanbingliandianlu.png" alt="chuanbingliandianlu"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>三极管</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%9E%81%E7%AE%A1/</url>
    <content><![CDATA[<h2 id="MOS-管"><a href="#MOS-管" class="headerlink" title="MOS 管"></a>MOS 管</h2><p>MOS管（Metal-Oxide-Semiconductor Field-Effect Transistor，MOSFET）是一种广泛应用于电子电路中的场效应晶体管（FET）。它利用电场效应来控制电流流动，是数字和模拟电路中常见的元件。MOS 管凭借其高输入阻抗和低功耗特性，在功率开关、信号放大以及逻辑电路中有着广泛的应用。</p>
<h3 id="MOS-管的结构"><a href="#MOS-管的结构" class="headerlink" title="MOS 管的结构"></a>MOS 管的结构</h3><p>MOS管主要由三部分构成：</p>
<ol>
<li><strong>栅极（Gate）</strong>：这是 MOS 管的控制端，通过在栅极施加电压来控制电流的导通与关断。栅极和通道之间由一层薄薄的绝缘氧化物层（通常是二氧化硅）隔开，因此栅极与其他区域几乎没有电流流动。</li>
<li><strong>源极（Source）</strong>：电流从源极流向漏极，源极是电流的起点。</li>
<li><strong>漏极（Drain）</strong>：漏极是电流的终点，当 MOS 管导通时，电流从源极流向漏极。</li>
<li><strong>基极（Body or Substrate）</strong>：MOS 管内部的一个半导体区域，通常接地或接电源电压，用来控制或隔离栅极与源漏极之间的</li>
</ol>
<p>MOS 管通常分为 <strong>N沟道（N-Channel）</strong>和 <strong>P沟道（P-Channel）</strong>两种类型，分别根据导电通道是由 N 型还是 P 型半导体形成来区分。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/MOSguanyuanlitu.png" alt="MOSguanyuanlitu"></p>
<blockquote>
<p>G极(gate)—栅极，不用说比较好认</p>
<p>S极(source)—源极，不论是P沟道还是N沟道，两根线相交的就是</p>
<p>D极(drain)—漏极，不论是P沟道还是N沟道，是单独引线的那边</p>
</blockquote>
<h3 id="N-沟道与-P-沟道判别"><a href="#N-沟道与-P-沟道判别" class="headerlink" title="N 沟道与 P 沟道判别"></a>N 沟道与 P 沟道判别</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/NPpanbie.png" alt="NPpanbie"></p>
<blockquote>
<p>箭头指向G极的是N沟道<br>箭头背向G极的是P沟道</p>
</blockquote>
<h3 id="MOS-管的工作原理"><a href="#MOS-管的工作原理" class="headerlink" title="MOS 管的工作原理"></a>MOS 管的工作原理</h3><p>MOS 管是一种<strong>电压控制器件</strong>，它的工作状态由<strong>栅极的电压</strong>来控制。当在栅极和源极之间施加一定的电压时，栅极通过电场影响沟道区域的电荷分布，从而控制源极和漏极之间的电流流动。</p>
<ul>
<li><strong>N 沟道 MOS 管（NMOS）</strong>：当栅极电压高于源极电压（即正偏压）时，导电沟道形成，电流从漏极流向源极。这个过程称为导通。</li>
<li><strong>P 沟道 MOS 管（PMOS）</strong>：与 NMOS 相反，当栅极电压低于源极电压（即负偏压）时，导电沟道形成，电流从源极流向漏极。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>组件</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>半加器是一种能够对<strong>两个一位二进制数进行相加并输出结果</strong>的逻辑门电路。它只能处理两个输入位（被加数和加数），<strong>不考虑低位进位</strong>。	</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/banjiaqi.png" alt="banjiaqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/banjiaqizhenzhibiao.png" alt="banjiaqizhenzhibiao"></p>
<h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>全加器（Full-Adder）是一种能够处理<strong>两个一位二进制数</strong>以及<strong>它们之间可能产生的进位</strong>的加法器；</p>
<p>在计算机中，全加器是算术逻辑单元（ALU）的重要组成部分，用于执行加法、减法等算术运算（在计算机中所谓的减法、称法、除法都是通过加法来实现的）；</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/quanjiaqi.png" alt="quanjiaqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/quanjiaqizhenzhibiao.png" alt="quanjiaqizhenzhibiao"></p>
<h2 id="八位二进制加法器"><a href="#八位二进制加法器" class="headerlink" title="八位二进制加法器"></a>八位二进制加法器</h2><p>八位二进制加法器是一种数字电路，用于将两个八位的二进制数相加，并产生一个八位的和以及一个进位输出（通常称为溢出位或最高位进位）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/baweijiafaqi.png" alt="qbaweijiafaqi"></p>
<p>八位二进制加法器能够执行从0到255之间的任何两个数的加法，产生从0到510（包括溢出情况）的结果。如果结果小于或等于255，则溢出位为0；如果结果大于255，则溢出位为1，表示实际结果需要模256处理（在计算机科学中，这通常意味着忽略溢出位，只考虑最低的八位）。</p>
<blockquote>
<p>由上述可以看出，任意位数的加法器都只需要对应个数的全加器及可实现（如：16位加法器之只需要一个半加器和15个全加器。）</p>
</blockquote>
<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p><strong>可记忆数据的电路</strong></p>
<p>锁存器的工作原理基于电平控制数据的输入。它通常包括锁存控制信号输入端（如使能端WE）、数据输入端（Din）和数据输出端（Q）。当锁存控制信号有效时（如使能端WE为高电平或低电平，具体取决于锁存器的类型），数据输入端（Din）的状态被锁存到输出端Q，并保持不变，直到下一个锁存信号到来。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/suocunqi.png" alt="suocunqi"></p>
<blockquote>
<p>锁存器可以将数据暂存起来，等待后续处理，从而起到缓存的作用。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>元器件</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="电容器"><a href="#电容器" class="headerlink" title="电容器"></a>电容器</h2><p><strong>电容就是装电的容器</strong><br>电容器是一种电子元件，用于储存电荷和能量。它由两个导体板和介质层组成(两个板子一边积累正电荷，一边积累负电荷)，介质层位于两个导体板之间。</p>
<p> 当电容器接入电路时，负电荷被储存在导体板上，并在两板之间产生电场。</p>
<p>电容器的单位是<strong>法拉</strong>(F)，<strong>一个法拉等于存储一库仑电荷所需的电势差为一伏特的电容器</strong>。常见的电容器有电解电容器、陶瓷电容器、聚酯薄膜电容器、铝电解电容器等。</p>
<p>不同的材料介质，容纳电荷的能力不一样。电容的充放电是基于静电力的，不涉及化学反应变化，比锂电池更安全。</p>
<p>注意:法拉是个非常大非常大的单位哦，其他单位为mF，uF，nF，pF，</p>
<p>1F   (法拉) &#x3D; 1000mF(毫法)，</p>
<p>1mF(毫法) &#x3D; 1000μF(微法)，</p>
<p>1μF (微法) &#x3D; 1000nF(纳法)，</p>
<p>1nF (纳法) &#x3D; 1000pF(皮法)</p>
<p>电容器能够非常迅速地达到其存储电荷的能力上限，即充满电的状态。</p>
<p><strong>电容器的作用</strong></p>
<p>阻止电压的突变，储能，滤波(大电容滤低频，小电容滤高频)</p>
<p>生活中的电容: 充电器的电源灯并不是立刻断开，里面有电容，电荷慢慢释放掉。差点的耳机，滤波不好，噪音大。</p>
<p>常用的有$10^{-6},10^{-9}$大小等。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>基于功能和制作工艺划分</strong></p>
<p><strong>玻璃电容：</strong>使用玻璃作为介质的电容器，具有高温稳定性和低损耗等特点，常用于高频和高温环境下的电路中。</p>
<p><strong>钽电容：</strong>使用钽金属作为电极的电容器，具有小尺寸、大电容量和高频特性等优点，常用于微型电路中。</p>
<p><strong>薄膜电容：</strong>使用金属膜或金属箔作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中</p>
<p><strong>铝电解电容：</strong>使用铝箔和电解液作为电极的电容器，具有大电容量、低成本等特点，常用于低频和直流电路中。</p>
<p><strong>云母电容：</strong>使用云母作为介质的电容器，具有高精度、高频特性等特点，常用于精密仪器和高频电路中。</p>
<p><strong>空气电容：</strong>使用空气作为介质的电容器，具有高精度、稳定性好等特点，但体积较大，常用于高频和高压电路中。</p>
<p><strong>陶瓷电容：</strong>使用陶瓷作为介质的电容器，具有小尺寸、高频特性和高温稳定性等优点，常用于电子设备中。</p>
<p><strong>可调电容：</strong>具有可变电容值的电容器，常用于无线电和调谐电路中。</p>
<p><strong>金属纸电容：</strong>使用金属化薄膜作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中。</p>
<p><strong>超级电容：</strong>也称为电化学电容器，具有高能量密度、高功率密度和长寿命等特点，常用于储能系统和电动汽车中。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>有的电容是有极性的，正负极接错了会爆炸哦!!!</strong></p>
<p><strong>在电子元器件中如果两个引脚长短不一，通常情况下长脚为正极，短脚为负极</strong></p>
<p>例如：铝电解电容是一种极性电容，由于其特殊的结构和工作原理，如果接反了极性，万能会导致电容器失效或者损坏，甚至可能导致电容器短路或者起火等危险情况。</p>
<p>铝电解电容的结构是由一层氧化铝薄膜和一层电解液构成的。当正极连接正电压，负极连接负电压时，电解液中的氢离子会向氧化铝膜的负极移动，而负离子则向电解液的正极移动，形成一个稳定的电场，从而形成电容效应。如果电容器反接了极性，电解液中的氢离子会向氧化铝膜的正极移动，形成氢气，铝电解电容会爆浆。电容爆浆后压力较大,电解电容的外壳也是无规律的变形,有可能产生手榴弹爆炸后的效果,容易造成其他元器件的损坏。</p>
<h3 id="超级电容"><a href="#超级电容" class="headerlink" title="超级电容"></a>超级电容</h3><p>灯能亮多久?<br>t &#x3D; (C * *V) &#x2F; 1<br>t  是放电时间(单位：秒)<br>C 是电容的容量(单位：法拉)</p>
<p>V 是电容的电压(单位：伏特)</p>
<p>I  是放电电流(单位：安培)</p>
<p>C &#x3D; 1.5F</p>
<p>V &#x3D; 2.8V</p>
<p>1 &#x3D; 20mA &#x3D; 0.02A</p>
<p>将这些值代入公式，计算放电t &#x3D; (1.5 * 2.8) &#x2F; 0.02 ≈ 210秒</p>
<h2 id="电感器"><a href="#电感器" class="headerlink" title="电感器"></a>电感器</h2><p><strong>电和磁之间有密切的关系</strong><br>当我们在水里扔一块石头时，会产生一个涟漪，涟漪会从石头周围向外扩散。电和磁也是如此。当电通过导线时，它就像是在水中扔了一块石头一样，会在周围产生一个磁场，这个磁场就像是涟漪一样向外扩散。反过来，当一个磁场改变时产生的涟漪又会带动周围的电子运动，这些涟漪会产生电场，这就是电磁感应的原理。<br><strong>电和磁可以互相转换。</strong><br>电机中的电流流过线圈，从而产生磁场，这个磁场将旋转部件(例如电动机轴)带动起来。这就是电磁感应原理的应用。<br>发电机和电机相反。通过旋转磁场，发电机可以转换机械能为电能。</p>
<p><strong>什么是电感器</strong><br>电感器是一种电子元件，用于在电路中存储和释放能量。<strong>它由一个线圈组成，通常由铜线绕成，通常带有一个铁芯。</strong>当电流通过电感器时，它会在线圈中产生一个磁场，从而存储能量。当电流停止流动时，磁场会崩溃导致电感器释放存储的能量。<br>电感器的主要作用是在电路中调节电流的变化率。它可以用来过滤电路中的高频噪声，电感器两端的电流不会突变，保护其他电子元件不受到电磁干扰的影响。</p>
<p><strong>电感器的核心要点</strong></p>
<ul>
<li>通过磁场存储能量</li>
<li>阻止电流的突变</li>
</ul>
<h3 id="电感和电阻"><a href="#电感和电阻" class="headerlink" title="电感和电阻"></a>电感和电阻</h3><p><strong>理想的电感没有能量损耗</strong><br>电感:电磁感应元器件，电会产生磁场，磁场又会抵制电流的变化。理想的电感没有能量损耗。</p>
<p>跟电阻不同，电阻阻碍电流，发热。</p>
<p>电感使用漆包线，纱包线等外部绝缘导线缠绕到铁芯上。</p>
<p>电感的单位是亨利(Henry)表示为H，它的中文读法是“恒利”，以英国物理学家亨利的名字命名。</p>
<p>电感的基本单位是:H(亨)，它和电容一样，也是一个很大的计量单位，另外还有毫户mh、微亨uh、纳亨nh。</p>
<p><strong>电感的作用</strong></p>
<p>电感可以作为电路稳定器的 一部分，通过抵抗电路中电流的变化，保持电路的稳定性和可靠性。</p>
<p>在电源电路中，电感器可以储存能量并在需要时释放，从而平滑电源电压的波动，减少电压瞬变对电路的影响，提高电路的稳定性。</p>
<blockquote>
<p>电流突变会产生磁场。可能会影响其他元器件，电感器可以起到一个缓冲的作用。</p>
</blockquote>
<h2 id="电感电容组成LRC振荡电路"><a href="#电感电容组成LRC振荡电路" class="headerlink" title="电感电容组成LRC振荡电路"></a>电感电容组成LRC振荡电路</h2><p><strong>振荡电路原理</strong></p>
<p>LRC振荡电路是一种基本的振荡电路，由电感L、电容C和电阻R组成，可以产生稳定的交流电信号。在LRC振荡电路中，电感和电容通过共振的方式相互作用，导致电荷周期性地从电容器到电感器和反向流动，从而产生周期性的电流和电压信号。</p>
<p>LRC振荡电路的工作原理是当电容器放电时，电感器中的电流开始增加，而电容器的电荷开始减少。当电容器的电荷达到零时，电感器中的电流达到最大值，并开始流回电容器中，导致电容器的电荷开始增加。当电容器的电荷重新达到最大值时，电感器中的电流达到零值，并开始再次增加。这个过程不断重复，从而形成一个周期性的交流电信号。</p>
<p><strong>LRC振荡电路的频率由电感L和电容C的值决定，可以通过调整电感和电容的值来改变输出信号的频率。</strong></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>充电阶段<ul>
<li>当电容C开始充电时，电流从电源流向电容，此时电流方向可以视为“向右流动”（假设我们定义从电源到电容的方向为右）。</li>
<li>电容储存电荷，同时电感L由于电流的变化而产生感应电动势，但此时电感中的电流较小。</li>
</ul>
</li>
<li>放电阶段<ul>
<li>当电容C充满电后，如果电路中的开关（如果有的话）切换，使得电容开始放电，电流将流向电感L，此时电流方向变为“向左流动”（从电容到电感）。</li>
<li>电感L开始储存磁能，并产生与电容放电方向相反的感应电动势，试图阻止电流的变化。</li>
</ul>
</li>
<li>振荡过程<ul>
<li>随着电容的放电，其两端的电压逐渐降低，而电感中的电流逐渐增加。当电容放电完毕时，电感中的电流达到最大值。</li>
<li>此时，电感开始释放其储存的磁能，通过感应电动势对电容进行反向充电，电流方向再次变为“向右流动”。</li>
<li>这个过程不断重复，形成周期性的振荡。在振荡过程中，电流的方向会不断地在“向左”和“向右”之间切换。</li>
</ul>
</li>
</ol>
<h2 id="保险丝、熔断器"><a href="#保险丝、熔断器" class="headerlink" title="保险丝、熔断器"></a>保险丝、熔断器</h2><p>保险丝和熔断器都是用来保护电路免受过载或短路等电气故障的设备。</p>
<p>保险丝是一种电气元件，通常由金属丝或铜箔制成，其作用是<strong>在电流过载时断开电路，以保护电路中其他电气元件不受损坏。</strong>当电流达到或超过保险丝的额定电流时，保险丝中的金属丝或铜箔会被加热，最终熔断，中断电路，以避免电气火灾等危险情况。</p>
<p>熔断器与保险丝类似，与保险丝不同，其作用是<strong>当电流超过额定值的时候熔断器会自动断开，当过一段时间温度降下来后，熔断器会自动恢复。</strong>熔断器通常可以重复使用。熔断器的另一个优点是它们通常比保险丝更快地响应电气故障，因此能更好地保护电路。</p>
<p><strong>熔断器实现方式通常由两种</strong></p>
<ul>
<li><p><strong>基于材料特性熔断：</strong>在这种方式中，熔断器内部包含一段易熔的金属导体（即熔体），该导体由具有特定熔点的金属或合金制成。当通过熔断器的电流超过其额定值时，熔体因发热而温度急剧上升，当温度达到其熔点时，熔体将迅速熔化并断开电路，从而实现过流保护。这种方式的关键在于熔体材料的选择和熔体尺寸的设计，它们共同决定了熔断器的额定电流和熔断特性。</p>
</li>
<li><p><strong>基于物理结构熔断：</strong>例如：将两个不同材质的金属片压合在一起组成一个熔断器。这两个金属片由于材料不一样，他们热胀冷缩的系数也不一样，当温度达到一定地步的时候，其中一个金属片膨胀的厉害，另外一个金属片变化不明显，这时膨胀厉害的那一个金属片就弯掉了，导致电路断开，形成熔断的效果。</p>
</li>
</ul>
<h3 id="保险丝、熔断器参数"><a href="#保险丝、熔断器参数" class="headerlink" title="保险丝、熔断器参数"></a>保险丝、熔断器参数</h3><p><strong>购买元器件最重要的看参数</strong></p>
<p>熔断速度：慢速，中速，快速，特快速。</p>
<p>快速熔断器：熔断时间小于0.001秒</p>
<p>电压额定值：所能承受的最高电压(多大电压的时候他会熔断)</p>
<p>电流额定值:所能承受的最高电流(多大电流的时候他会熔断)</p>
<p>熔断特性:快速熔断器适用于对电路的保护要求较高的场合，能够在短时间内切断过载电流或短路电流;</p>
<p>​		而慢速熔断器则适用于对电路保护要求不高的场合，能够在一定时间内承受额定电流的2-3倍电流。</p>
<h2 id="接插件"><a href="#接插件" class="headerlink" title="接插件"></a>接插件</h2><p><strong>开关、按键、连接端子本质上都是电路连接器</strong></p>
<h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p><strong>能发出哗哔哗的声音的小元器件</strong><br>声音是由物体的震动产生，一切发生的物体都是在震动。 震动的频率不同，声音的音调就不同。</p>
<p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，源是震动源。有源蜂鸣器插电就叫，无源蜂鸣器插电不叫，需要一定周期的高低电压信息给他，他才会叫。</p>
<p>蜂鸣器的音频是指蜂鸣器发出的声音的声波频率，是指每秒连续循环的次数。频率的计量单位是“赫兹”(Hz)，人类听觉的频率范围约为20-20000Hz。20Hz以下是次声，20kHz以上是超声波。</p>
<p>蜂鸣器常用产品的谐振频率为2-4 kHz</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="万用表"><a href="#万用表" class="headerlink" title="万用表"></a>万用表</h2>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电流</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%94%B5%E6%B5%81/</url>
    <content><![CDATA[<h2 id="AC-DC"><a href="#AC-DC" class="headerlink" title="AC&#x2F;DC"></a>AC&#x2F;DC</h2><p><strong>AC(交流电)，DC(直流电)</strong></p>
<h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><ul>
<li><p>交流电的电流方向随时间变化</p>
</li>
<li><p>电荷会在正、负两个方向上流动，周期性的交替反向</p>
</li>
<li><p>交流电通常是通过电网提供电力</p>
</li>
<li><p>用于各种大型的较大功耗的电器设备和机械设备中</p>
<p>（如电视、冰箱、微波炉、电动汽车的电机）</p>
</li>
</ul>
<h3 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h3><ul>
<li><p>直流电是指电流方向不变的电流</p>
</li>
<li><p>电荷始终在同一个方向上流动</p>
</li>
<li><p>直流电源通常是由电池或者其他直流电源供应</p>
</li>
<li><p>直流电常用于需要稳定电压和恒定方向的小型设备中</p>
<p>（如手机、电动自行车）</p>
</li>
</ul>
<h3 id="AC-DC的对比"><a href="#AC-DC的对比" class="headerlink" title="AC&#x2F;DC的对比"></a>AC&#x2F;DC的对比</h3><p>直流电和交流电的主要区别在于电流的<strong>方向</strong>和<strong>性质</strong>。直流电的电流方向不变，而交流电的电流方向随时间周期性变化。直流电通常<br>用于需要恒定电压和电流方向的设备，而交流电通常用于各种电器设备和机械设备中。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">直流电</th>
<th align="center">交流电</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>方向</strong></td>
<td align="center">电流方向不变</td>
<td align="center">电流的方向随时间周期性变化</td>
</tr>
<tr>
<td align="center"><strong>电压变化</strong></td>
<td align="center">电压稳定不变</td>
<td align="center">电压随时间周期性变化</td>
</tr>
<tr>
<td align="center"><strong>发电方式</strong></td>
<td align="center">化学电池、太阳能电池等</td>
<td align="center">发电厂</td>
</tr>
<tr>
<td align="center"><strong>传输损失</strong></td>
<td align="center">传输损失小</td>
<td align="center">电流传输损失较大</td>
</tr>
<tr>
<td align="center"><strong>方便改变电压</strong></td>
<td align="center">不太方便</td>
<td align="center">非常方便</td>
</tr>
<tr>
<td align="center"><strong>应用</strong></td>
<td align="center">电池供电的设备：手机、笔记本电脑等</td>
<td align="center">家用电器、工业用电</td>
</tr>
</tbody></table>
<h2 id="开路和闭路"><a href="#开路和闭路" class="headerlink" title="开路和闭路"></a>开路和闭路</h2><p>“Open circuit”和“Close circuit”的区别在于电路中开关的状态是否闭合，这直接影响了电路中的电流是否能够流通，从而影响电路中的电器设备是否能够正常工作。</p>
<h3 id="开路Open-circuit"><a href="#开路Open-circuit" class="headerlink" title="开路Open circuit"></a>开路Open circuit</h3><p>当电路中的开关处于断开状态，电路就处于”Open circuit”(开路)状态。在这种状态下，电流无法流通，电路中的电器设备也无法工作。</p>
<h3 id="闭路close-circuits"><a href="#闭路close-circuits" class="headerlink" title="闭路close circuits"></a>闭路close circuits</h3><p>当电路中的开关处于闭合状态，电路就处于”Close circuit”(闭路)状态。在这种状态下，电流可以在电路中流通，电器设备也可以正常工作。</p>
<blockquote>
<p>电工操作的安全要求就是，保证电路是open的。</p>
<p>比如说站到木椅子上，使用绝缘手套;</p>
<p>千万不要让电流通过身体形成回路(close circuit);</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<h2 id="欧姆定律"><a href="#欧姆定律" class="headerlink" title="欧姆定律"></a>欧姆定律</h2><p>电压产生电势差，推动电流的流动</p>
<p><strong>阻碍电流的流动就是电阻</strong></p>
<p>电阻是电子学中的基本概念，它是指电流经过导体时阻碍电流流动的程度。电阻的单位是欧姆（Ω）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/dianzu.png" alt="dianzu"></p>
<p>欧姆定律描述了电流和电压之间的关系。欧姆定律的公式为：I &#x3D; U &#x2F; R，其中 I 是电流，U 是电压，R 是电阻。这个公式表明：在电阻不变的情况下，电压和电流成正比。</p>
<blockquote>
<p>I 电流（A）、U 电压（V）、R 电阻（Ω）</p>
</blockquote>
<h3 id="欧姆定律的计算"><a href="#欧姆定律的计算" class="headerlink" title="欧姆定律的计算"></a>欧姆定律的计算</h3><p>分为串联电路和并联电路</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/chuanbingliandianlu.png" alt="chuanbingliandianlu"></p>
<table>
<thead>
<tr>
<th align="center">串联电路</th>
<th align="center">并联电路</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电流关系：I &#x3D; I1 &#x3D; I2</td>
<td align="center">电流关系：I &#x3D; I1 + I2</td>
</tr>
<tr>
<td align="center">电压关系：U &#x3D; U1 + U2</td>
<td align="center">电压关系：U &#x3D; U1 &#x3D; U2</td>
</tr>
<tr>
<td align="center">电阻关系：R &#x3D; R1 + R2</td>
<td align="center">电阻关系：1&#x2F;R &#x3D; 1&#x2F;R1 + 1&#x2F;R2</td>
</tr>
<tr>
<td align="center">电压分配关系：U1&#x2F;R1 &#x3D; U2&#x2F;R2</td>
<td align="center">电压分配关系：I1R1 &#x3D; I2R2</td>
</tr>
</tbody></table>
<h2 id="常见电阻介绍"><a href="#常见电阻介绍" class="headerlink" title="常见电阻介绍"></a>常见电阻介绍</h2><p><strong>基于功能和制作工艺划分</strong><br><strong>普通电阻：</strong>普通电阻是一种最基本的电阻器，通常由一根或多根绕在绝缘体上的金属丝或碳膜组成，可以提供固定的电阻值适用于各种电路中。</p>
<p><strong>薄膜电阻：</strong>薄膜电阻是一种由金属或合金薄膜制成的电阻器，可以提供高精度和稳定性的电阻值，常用于精密仪器、测量仪器等高要求的场合。</p>
<p><strong>光敏电阻：</strong>光敏电阻是一种电阻值受光照强度影响的电阻器，常用于光敏电路和光控系统中。</p>
<p><strong>金属薄膜电阻：</strong>金属薄膜电阻器是一种由金属薄膜制成的电阻器，具有较高的精度和稳定性，适用于高精度电路中。</p>
<p><strong>电位器：</strong>电位器是一种可调电阻器，通常由一个旋转或滑动的电阻器件和一个旋钮或滑动器组成，可以提供可调的电阻值，常用于电路的调节和控制。</p>
<p><strong>旋钮可调电阻：</strong>旋钮可调电阻是一种可调电阻器，与电位器类似，但是旋钮可调电阻通常是用旋钮来改变电阻值，通常用于电子设备的调节和控制。</p>
<p><strong>热敏电阻：</strong>热敏电阻是一种电阻值随温度变化而变化的电阻器，通常用于温度测量和控制系统中。</p>
<p><strong>压敏电阻：</strong>压敏电阻是一种电阻值随压力变化而变化的电阻器，通常用于压力传感器和压力测量等应用场合。</p>
<p><strong>高精度电阻：</strong>高精度电阻是一种精度较高的电阻器，通常具有稳定的电阻值和温度系数，适用于高精度仪器和精密测量仪器等场合。</p>
<h2 id="电阻的数据手册"><a href="#电阻的数据手册" class="headerlink" title="电阻的数据手册"></a>电阻的数据手册</h2><p>电阻我们主要关心:<strong>封装</strong>(尺寸大小)，<strong>标称</strong>(精密度)，<strong>额定功率</strong></p>
<p>封装:看电阻是什么样的，是直插的还是贴片的，大小是多大。</p>
<p>标称:看电阻表的电阻阻值是多少，精确度是多少，误差1%的，还是5%的，还是20%的，精度越高越贵。</p>
<p>额定功率:额定功率是 <code>P=I*I*R = I*U</code>,额定功率其实决定了耐压值。电阻能通过的最大电流是固定的，额定功率越高，耐压值就越高，超过了电阻的耐压值会导致电阻烧毁。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/ADC/</url>
    <content><![CDATA[<p>ADC(Analog to Digital Converter 模数转换器）是一种将<strong>模拟信号转换为数字信号</strong>的<strong>电路</strong>。在电子系统中，模拟信号常常需要转换为数字信号进行处理和存储。模数转换的基本原理是将模拟信号进行<strong>采样</strong>，并将采样值<strong>量化</strong>为数字表示。</p>
<ul>
<li>采样：是指在一定时间间隔内对模拟信号进行测量，并将测量值存储在数字形式的数据中</li>
<li>量化：是将这些连续的模拟信号值离散化为一系列数字值，通常使用二进制表示。</li>
</ul>
<p>简单理解，<strong>ADC是把模拟信号转换为数字信号的工具</strong>，我们可以认为，一个信号有强弱之分，强弱的体现为电压的高低。在数字电路中，只有0和1之分，也就是高电平或低电平。那么体现不了这个强弱。ADC的作用就是体现强弱，精确化的拿到具体的值。</p>
<p>只有那些在硬件设计中具备 ADC 模块连接的引脚才能执行模数转换操作。</p>
<p>ADC（模数转换器）采样获取的是<strong>电压值</strong>。</p>
<p><strong>ADC 转换流程图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuanliuchengtu.png" alt="ADCzhuanhuanliuchengtu"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 芯片有 15 个通道的 ADC 功能引脚</p>
<p>通过控制滑动变阻器，来观察电压变化。</p>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/dianweiqiyinjiaotu.png" alt="dianweiqiyinjiaotu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到引脚需要配置 GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ADC引脚</span></span><br><span class="line">     GPIO_Init.Mode = GPIO_HighZ;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_5</span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line">    <span class="comment">// UART 引脚</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要用到 UART 查看数值输出也要配置 UART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">    UART_Init.Morecommunicate = DISABLE; </span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UART 必须要通过中断，故要设置下开启中断，并设置中断优先级</span></span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    <span class="comment">// 引脚选择</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到 ADC 需要配置ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC_INitTypeDef ADC_Init;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ADC 模拟信号采样时间控制, 0~31（注意： SMPDUTY 一定不能设置小于 10）</span></span><br><span class="line">    ADC_Init.ADC_SMPduty = <span class="number">31</span>; </span><br><span class="line">    <span class="comment">// 设置 ADC 工作时钟频率 ADC_SPEED_2X1T~ADC_SPEED_2X16T</span></span><br><span class="line">    <span class="comment">// 可以理解为 ADC 采样的频率或者说次数，一秒钟采样多少次</span></span><br><span class="line">    ADC_Init.ADC_Speed = ADC_SPEED_2X1T;</span><br><span class="line">    <span class="comment">// ADC结果调整,	ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIFIED</span></span><br><span class="line">    ADC_Init.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;</span><br><span class="line">    <span class="comment">//ADC 通道选择时间控制 0(默认),1</span></span><br><span class="line">    ADC_Init.ADC_CsSetup = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ADC 通道选择保持时间控制 0,1(默认),2,3</span></span><br><span class="line">    ADC_Init.ADC_CsHold = <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ADC_Inilize(&amp;ADC_Init);</span><br><span class="line">    <span class="comment">//中断使能,</span></span><br><span class="line">    NVIC_ADC_Init(DISABLE,Priority_0);		</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ADC 电源控制 ENABLE或DISABLE.</span></span><br><span class="line">    ADC_PowerControl(ENABLE);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> adc_v = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 中断总控</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    GPIO_Config();</span><br><span class="line">    UART_Config();</span><br><span class="line">    ADC_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 查询一次ADC转换结果. 得到的是一个数值</span></span><br><span class="line">        <span class="comment">// ADC_CH13 是我们所使用的引脚，也就是硬件连接的引脚</span></span><br><span class="line">        u16 adc_result = Get_ADCResult(ADC_CH13)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;adc_result = %d&quot;</span>, adc_result);</span><br><span class="line">        </span><br><span class="line">        adc_v = adc_result * <span class="number">2.5</span> / <span class="number">4096</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;adc_v = %d&quot;</span>, adc_v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>什么是模拟信号采样控制时间</strong></p>
<p>这里的“采样时间控制”指的是 ADC 在开始转换之前对输入的模拟信号进行采样的时间长短。</p>
<p>具体来说，采样时间是指 ADC 在转换开始前，<strong>输入模拟信号与内部采样电容相连的时间</strong>。采样时间的长短会影响采样电容对输入信号充电的充分程度。如果采样时间太短，采样电容无法完全充电，导致输入信号没有被准确读取，从而影响 ADC 转换后的数值精度。</p>
<p>在 STC8H 的 ADC 模块中，采样时间可以通过软件配置</p>
<p>二、<strong>什么是ADC结果调整</strong></p>
<p>就是 AD 转换结果对齐方式 设置ADC 转换的结果是左对齐还是右对齐，因为 STC8H 系列的单片机内部分别集成了一个 10 &#x2F; 12 位高速 A&#x2F;D 转换器；</p>
<p>ADC 转换结果的数据格式有两种，左对齐和右对齐。可以方便用户进行读取；</p>
<p>在 STC8H 系列中 STC8H1K28、STC8H1K08 是10 位高速 A&#x2F;D 转换器，其他都是 12位的</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuankongzhi.png" alt="ADCzhuanhuankongzhi"></p>
<p>三、<strong>什么是通道选择时间</strong></p>
<p>见下图</p>
<p>四、<strong>什么是通道选择保持时间控制</strong></p>
<p>见下图</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuanshijian.png" alt="ADCzhuanhuanshijian"></p>
<p>五、<strong>12位 ADC 采样计算中，2 的十二次方最大时 4095，为何我们在换算时通常是除以 4096</strong></p>
<p>12 位的寄存器用来存储采样数值，那么这种情况下 12 位全零的状态也应该作为一个采样数值，即 寄存器最大值+1</p>
<p>12位 ADC 的 ADCn 通道的输入电压 &#x3D; 采样数值 &#x2F; 4096 * ADC_VRef 是正解;</p>
<p>六、<strong>ADC 中也有中断，它的使用场景是什么</strong></p>
<p>ADC 中断是在 <strong>模数转换完成后</strong> 自动触发的。当 ADC 完成了一次从模拟信号到数字信号的转换时，系统会自动生成一个中断请求（ADC 中断标志位被置位），通知处理器模数转换已经完成，可以读取转换结果。</p>
<p>七、<strong>为何在计算时用到的是 2.5v 进行计算，而不是 Vcc 提供的 3.3V</strong></p>
<p>在电路电位器设计中接入了一个芯片 CJ431&#x2F;CD431，这是一款电压基准芯片，会恒定的输出 2.5V 电压。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>bevy基础</title>
    <url>/game/rust/Bevy/bevy%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Bevy-基础"><a href="#Bevy-基础" class="headerlink" title="Bevy 基础"></a>Bevy 基础</h1><h2 id="Bevy设置"><a href="#Bevy设置" class="headerlink" title="Bevy设置"></a>Bevy设置</h2><h3 id="加快编译优化"><a href="#加快编译优化" class="headerlink" title="加快编译优化"></a>加快编译优化</h3><p>在<code>Cargo.toml</code>或<code>.cargo/config.toml</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对依赖项启用最大优化，但不对我们的代码启用最大优化：</span></span><br><span class="line"><span class="section">[profile.dev.package.&quot;*&quot;]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调试/开发模式下仅启用少量优化</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际发布模式下最积极的优化配置：</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span> <span class="comment"># 设置为 true 时编译器会进行链接时间优化，但会增加编译时间。</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span> <span class="comment"># 设置优化级别为最高。</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span> <span class="comment"># 控制了代码生成的单元数量。当设置为 1 时，整个 crate 会被编译成一个单独的代码生成单元。</span></span><br><span class="line"><span class="attr">incremental</span> = <span class="literal">false</span> <span class="comment"># 不启用增量编译：增量编译允许 Cargo 只重新编译自上次构建以来已更改的文件和依赖项，从而加快编译速度。</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">false</span> <span class="comment"># 当设置为false时，编译器不会生成调试信息。</span></span><br></pre></td></tr></table></figure>

<p><strong>警告！</strong>如果您使用调试器（如<code>gdb</code>或<code>lldb</code>）来逐步执行代码，任何程度的编译器优化都会影响体验。您的断点可能会被跳过，并且代码流可能会以意想不到的方式跳来跳去。如果您想调试&#x2F;逐步执行代码，您可能需要 <code>opt-level = 0</code>。</p>
<h3 id="加速-Rust-Analyzer"><a href="#加速-Rust-Analyzer" class="headerlink" title="加速 Rust-Analyzer"></a>加速 Rust-Analyzer</h3><p><em>Powershell</em> 中键入 <strong>rustup shwo</strong> 来显示你的Rust构建工具链</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\cnkay&gt; rustup show</span><br><span class="line">Default host: x86_64<span class="literal">-pc-windows-msvc</span></span><br><span class="line">rustup home:  D:\tools\SDK\rust\.rustup</span><br><span class="line"></span><br><span class="line">stable<span class="literal">-x86_64-pc-windows-msvc</span> (default)</span><br><span class="line">rustc <span class="number">1.78</span>.<span class="number">0</span> (<span class="number">9</span>b00956e5 <span class="number">2024</span><span class="literal">-04-29</span>)</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 <em>MSVC</em> 工具链那么连接器是<code>link.exe</code>。</p>
<p>为了实现快速编译，需要设置非默认链接器。在 <em>VSCode</em> 中设置<code>settings.json</code> 添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Windows<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=rust-lld.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux(mold)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=mold&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux (lld)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=lld&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CI设置"><a href="#CI设置" class="headerlink" title="CI设置"></a>CI设置</h2><p><code>CI</code>是<strong>GitHub Actions</strong>的简称</p>
<h2 id="ECS-模式"><a href="#ECS-模式" class="headerlink" title="ECS 模式"></a>ECS 模式</h2><p>ECS 是*实体(Entity)<em>、</em>组件(Component)<em>、</em>系统(System)*的简称，是一种将<strong>数据</strong>和<strong>行为</strong>分开的编程范式。</p>
<p><strong>系统(System)</strong></p>
<p>系统是处理实体和组件的逻辑单元，负责执行特定的功能或行为。</p>
<p>系统是基于组件的存在于否，以及它们的状态来执行逻辑单元。</p>
<p>系统通常是独立于特定实体的，可以处理多个具有相似组件结构的实体。</p>
<p><strong>实体(Entity)</strong></p>
<p>实体是系统中的基本对象，可以是游戏中的角色、物体或者其他有意义的实体。</p>
<p>实体本身通常只是一个标识符，没有行为或状态。</p>
<p><strong>组件(Component)</strong></p>
<p>组件是实体的属性或数据单元，描述了实体的特征和状态。</p>
<p>不同的组件可以包含不同类型的数据，例如位置、渲染信息、健康状态等。</p>
<p>一个实体可以关联多个组件，组件之间是相互独立的。</p>
<p><strong>总结</strong></p>
<p><strong>实体只是指向组件的唯一ID或引用，本质上他将所有的组件连接在一起，构成游戏中的单个对象。</strong></p>
<p><strong>组件只是存粹的数据结构，如坦克对象的大小和速度。</strong></p>
<p><strong>系统只是对具有特定组件功能的实体进行操作的功能。</strong></p>
<p>在Bevy中<strong>实体(Entity)</strong> 是指向一群<strong>组件(Component)</strong> 的唯一 <strong>事物(things)</strong>, 然后使用 <strong>系统(System)</strong> 处理其过程.</p>
<p>例如，一个实体可能有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件，而另一个实体可能有<code>位置(Position)</code>和<code>UI</code>组件。系统是在一组特定组件上运行的逻辑， 你可能有一个运行在所有带有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件的实体上的<code>移动</code>系统。</p>
<h2 id="ECS-中的数据"><a href="#ECS-中的数据" class="headerlink" title="ECS 中的数据"></a>ECS 中的数据</h2><h3 id="World"><a href="#World" class="headerlink" title="World"></a>World</h3><p>定义：<em>World</em>是<strong>系统</strong>和<strong>实体</strong>的集合。在<code>ECS</code>架构中，<em>World</em>是最高级别的组织单位，它包含了<strong>游戏中的所有实体（Entity）以及处理这些实体的系统（System）</strong>。</p>
<p>当程序启动时，默认会生成一个World,可以存在多个World对象。</p>
<h3 id="Entities-Components"><a href="#Entities-Components" class="headerlink" title="Entities&#x2F;Components"></a>Entities&#x2F;Components</h3><p>概念上类似于在数据库或电子表格。</p>
<p>每一行数据就是一个对象，<code>(Entity)</code>与<code>ID</code>或者行号类似，<code>(Components)</code>类似于 表的<em>列</em>，可以有任意多个<em>行</em>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Xp</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Health</span> &#123;</span><br><span class="line">    current: <span class="type">u32</span>,</span><br><span class="line">    max: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">level_up</span>(<span class="keyword">mut</span> query: Query&lt;(&amp;<span class="keyword">mut</span> Xp, &amp;<span class="keyword">mut</span> Health)&gt;,) &#123;</span><br><span class="line">    <span class="comment">// process all relevant entities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">mut</span> xp, <span class="keyword">mut</span> health) <span class="keyword">in</span> query.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> xp.<span class="number">0</span> &gt; <span class="number">1000</span> &#123;</span><br><span class="line">            xp.<span class="number">0</span> -= <span class="number">1000</span>;</span><br><span class="line">            health.max += <span class="number">25</span>;</span><br><span class="line">            health.current = health.max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>如果某物只有一个全局实例（单例），并且它是独立（不与其他数据关联），那么你就可以创建一个<code>Resources</code></p>
<p>例如，您可以创建一个资源来存储游戏的图形 设置，或指向非 Bevy 库的接口。</p>
<p>这是一种存储数据的简单方法，当你不需要<code>实体/组件</code>的灵活性的时候。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Resource)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameSettings</span> &#123;</span><br><span class="line">    current_level: <span class="type">u32</span>,</span><br><span class="line">    difficulty: <span class="type">u32</span>,</span><br><span class="line">    max_time_seconds: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">setup_game</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Add the GameSettings resource to the ECS</span></span><br><span class="line">    <span class="comment">// (if one already exists, it will be overwritten)</span></span><br><span class="line">    commands.<span class="title function_ invoke__">insert_resource</span>(GameSettings &#123;</span><br><span class="line">        current_level: <span class="number">1</span>,</span><br><span class="line">        difficulty: <span class="number">100</span>,</span><br><span class="line">        max_time_seconds: <span class="number">60</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">spawn_extra_enemies</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">    <span class="comment">// we can easily access our resource from any system</span></span><br><span class="line">    game_settings: Res&lt;GameSettings&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> game_settings.difficulty &gt; <span class="number">50</span> &#123;</span><br><span class="line">        commands.<span class="title function_ invoke__">spawn</span>((</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>bevy</tag>
      </tags>
  </entry>
  <entry>
    <title>EEPROM读写</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/EEPROM%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p><strong>EEPROM</strong>（<strong>Electrically Erasable Programmable Read-Only Memory</strong>，电可擦除可编程只读存储器）是一种<strong>非易失性存储器</strong>，可以在<strong>掉电后仍保留数据</strong>。它允许<strong>单字节</strong>或<strong>多字节</strong>的数据被擦除和重新写入，而不需要整个芯片被擦除。嵌入式系统、微控制器以及各种电子设备中常使用 EEPROM 来存储需要在掉电后保留的数据，比如用户配置、校准参数等。</p>
<p><strong>ISP（In-System Programming）</strong></p>
<p>ISP，即在系统编，是一种允许开发者在目标系统（如电路板）上直接对芯片进行编程的技术。这意味着开发者无需将芯片从电路板上取下，即可通过特定的接口（如串口、JTAG、SPI等）将程序代码烧录到芯片内部的 Flash 存储器中。</p>
<p><strong>IAP（In-Application Programming）</strong></p>
<p>IAP，即在应用编程，是一种允许在应用程序运行时对芯片内部存储器进行编程或更新的技术。与 ISP 不同，IAP 通常需要在芯片内部划分出特定的存储区域（如引导区、运行程序区和下载区），并在应用程序中集成相应的编程逻辑。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>官方文档介绍</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ROMguanfangwendangjieshao.png" alt="ROMguanfangwendangjieshao"></p>
<p><strong>官方文档内部结构图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ROMjiegoutu.png" alt="ROMjiegoutu"></p>
<p>STC8 系列单片机中都包含有 Flash 数据存储器（EEPROM）。以字节为单位进行读&#x2F;写数据，以 512 字节为页单位进行擦除，可在线反复编程擦写 10 万次以上，提高了使用的灵活性和方便性。</p>
<p><strong>数据存储器</strong></p>
<p>STC8H系列单片机内部集成的RAM可用于存放程序执行的中间结果和过程数据。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/shujucunchuqi.png" alt="shujucunchuqi.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写 String 字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EEPROM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &gt;&gt;&gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &lt;&lt;&lt;</span></span><br><span class="line">    COMx_InitDefine		COMx_InitStructure;					<span class="comment">//结构定义</span></span><br><span class="line">    COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;	<span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			<span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			<span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				<span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			<span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);		<span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line"></span><br><span class="line">    NVIC_UART1_Init(ENABLE,Priority_1);		<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		<span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Max_Length          100      <span class="comment">//读写EEPROM缓冲长度</span></span></span><br><span class="line">u8  xdata   tmp[Max_Length];        <span class="comment">//EEPROM操作缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    u16 addr_sector = <span class="number">0x0000</span>;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;HelloWorld!abc123!&quot;</span>;</span><br><span class="line">    u16 str_length = <span class="built_in">strlen</span>(str);	<span class="comment">// 获取str的长度</span></span><br><span class="line"></span><br><span class="line">    UART_config();</span><br><span class="line">		</span><br><span class="line">		EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除扇区, 一次性擦除一个扇区512字节, 从0x0000开始, 0x01FF</span></span><br><span class="line"><span class="comment">//    EEPROM_SectorErase(u16 EE_address);</span></span><br><span class="line">    EEPROM_SectorErase(addr_sector);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 写入数据. 字符串\int\long\float</span></span><br><span class="line"><span class="comment">////    EEPROM_write_n(u16 EE_address,u8 *DataAddress,u16 number);</span></span><br><span class="line">    EEPROM_write_n(addr_sector, str, str_length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据. 字符串\int\long\float</span></span><br><span class="line"><span class="comment">//    EEPROM_read_n(u16 EE_address,u8 *DataAddress,u16 number);</span></span><br><span class="line">    EEPROM_read_n(addr_sector, tmp, str_length);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 添加字符串结束符</span></span><br><span class="line">		tmp[str_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;存储的字符串: %s\n&quot;</span>, str);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;读到的字符串: %s\n&quot;</span>, tmp);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, tmp) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;两个字符串相等\n&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;两个字符串不等\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID_模拟鼠标</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID_%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 STC8H 的矩阵键盘模拟 鼠标的功能</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改描述符配置</span></span><br><span class="line"><span class="comment">// usb_desc.c</span></span><br><span class="line"><span class="comment">// 定义 鼠标的 配置描述符</span></span><br><span class="line"><span class="comment">/* 我们加了一个 scroll 也就是鼠标滚轮的功能</span></span><br><span class="line"><span class="comment">Input Report:</span></span><br><span class="line"><span class="comment">0   Buttons (D0:LButton D1:RButton D2:MButton [D3:D7]:Pad)</span></span><br><span class="line"><span class="comment">1	X displacement (&gt;0:right; &lt;0:left)</span></span><br><span class="line"><span class="comment">2	Y displacement (&gt;0:down; &lt;0:up)</span></span><br><span class="line"><span class="comment">3 scroll</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 此处我们需要修改的地方有：</span></span><br><span class="line"><span class="comment">// 1. 添加鼠标滚轮的描述符内容：0x09,0x38,Wheel;  鼠标滚轮   修改 1</span></span><br><span class="line"><span class="comment">// 2. 将原本报告的计数从 2 改为3 // 0x95,0x03,REPORT_COUNT(3);   修改2</span></span><br><span class="line"><span class="comment">// 3. 将整个报告描述符的总长度进行修改 HIDREPORTDESC[52]，0x05,0x01, (包括头文件中的内容)</span></span><br><span class="line"><span class="comment">// 4. 将配置描述符中发送的最大字节数从 3 改为 4</span></span><br><span class="line"><span class="comment">// 5. 将配置描述符中的协议长度改为 52 与报告描述符的总长度要一致</span></span><br><span class="line"><span class="comment">// 注意：当我们将鼠标滚轮的功能追加在第四个字节也就是末尾的时候，对应 HIDREPORTDESC </span></span><br><span class="line"><span class="comment">// 中的位置也要在 x、y，的下面，要保证发送的内容与报告描述符的内容对应起来；</span></span><br><span class="line"><span class="type">char</span> code HIDREPORTDESC[<span class="number">52</span>] =  <span class="comment">// 修改3 --- 头文件的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x01</span>,              <span class="comment">//USAGE_PAGE(Generic Desktop);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x02</span>,              <span class="comment">//USAGE(Mouse);</span></span><br><span class="line">    <span class="number">0xa1</span>,<span class="number">0x01</span>,              <span class="comment">//COLLECTION(Application);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x01</span>,              <span class="comment">//  USAGE(Pointer);</span></span><br><span class="line">    <span class="number">0xa1</span>,<span class="number">0x00</span>,              <span class="comment">//  COLLECTION(Physical);</span></span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x09</span>,              <span class="comment">//    USAGE_PAGE(Buttons);</span></span><br><span class="line">    <span class="number">0x19</span>,<span class="number">0x01</span>,              <span class="comment">//    USAGE_MINIMUM(1);</span></span><br><span class="line">    <span class="number">0x29</span>,<span class="number">0x03</span>,              <span class="comment">//    USAGE_MAXIMUM(3);</span></span><br><span class="line">    <span class="number">0x15</span>,<span class="number">0x00</span>,              <span class="comment">//    LOGICAL_MINIMUM(0);</span></span><br><span class="line">    <span class="number">0x25</span>,<span class="number">0x01</span>,              <span class="comment">//    LOGICAL_MAXIMUM(1);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x01</span>,              <span class="comment">//    REPORT_SIZE(1);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x03</span>,              <span class="comment">//    REPORT_COUNT(3);</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x02</span>,              <span class="comment">//    INPUT(Data,Variable,Absolute);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x05</span>,              <span class="comment">//    REPORT_SIZE(5);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x01</span>,              <span class="comment">//    REPORT_COUNT(1);</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x01</span>,              <span class="comment">//    INPUT(Constant);</span></span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x01</span>,              <span class="comment">//    USAGE_PAGE(Generic Desktop);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x30</span>,              <span class="comment">//    USAGE(X);  x方向移动</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x31</span>,              <span class="comment">//    USAGE(Y);  y方向移动</span></span><br><span class="line">	<span class="number">0x09</span>,<span class="number">0x38</span>,              <span class="comment">//    Wheel;  鼠标滚轮   修改 1</span></span><br><span class="line">    <span class="number">0x15</span>,<span class="number">0x81</span>,              <span class="comment">//    LOGICAL_MINIMUM(-127);</span></span><br><span class="line">    <span class="number">0x25</span>,<span class="number">0x7f</span>,              <span class="comment">//    LOGICAL_MAXIMUM(127);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x08</span>,              <span class="comment">//    REPORT_SIZE(8);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x03</span>,              <span class="comment">//    REPORT_COUNT(3);   修改2</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x06</span>,              <span class="comment">//    INPUT(Data, Variable, Relative);</span></span><br><span class="line">    <span class="number">0xc0</span>,                   <span class="comment">//  END_COLLECTION;</span></span><br><span class="line">    <span class="number">0xc0</span>,                   <span class="comment">//END_COLLECTION;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置描述符</span></span><br><span class="line"><span class="type">char</span> code CONFIGDESC[<span class="number">41</span>] = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 遵循的协议版本 HID 1.01协议</span></span><br><span class="line">    <span class="number">0x09</span>,                   <span class="comment">//bLength(9);</span></span><br><span class="line">    <span class="number">0x21</span>,                   <span class="comment">//bDescriptorType(HID);</span></span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0x01</span>,              <span class="comment">//bcdHID(1.01);</span></span><br><span class="line">    <span class="number">0x00</span>,                   <span class="comment">//bCountryCode(0);</span></span><br><span class="line">    <span class="number">0x01</span>,                   <span class="comment">//bNumDescriptors(1);</span></span><br><span class="line">    <span class="number">0x22</span>,                   <span class="comment">//bDescriptorType(HID Report);</span></span><br><span class="line">    <span class="number">0x34</span>,<span class="number">0x00</span>,              <span class="comment">//wDescriptorLength(52);</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 描述鼠标给PC发的数据信息</span></span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x81</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as IN);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(4);   修改4 鼠标1次会给PC发送4个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms); </span></span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="comment">// 修改处理函数</span></span><br><span class="line"><span class="type">void</span> usb_class_in(BYTE button[<span class="number">4</span>]) &#123;</span><br><span class="line">    BYTE i;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (DeviceState != DEVSTATE_CONFIGURED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!UsbInBusy )&#123;</span><br><span class="line">        IE2 &amp;= ~<span class="number">0x80</span>;   <span class="comment">//EUSB = 0;</span></span><br><span class="line">        UsbInBusy = <span class="number">1</span>;</span><br><span class="line">        usb_write_reg(INDEX, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            usb_write_reg(FIFO1, button[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        usb_write_reg(INCSR1, INIPRDY);</span><br><span class="line">        IE2 |= <span class="number">0x80</span>;    <span class="comment">//EUSB = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="comment">// &gt;&gt;&gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &lt;&lt;&lt;</span></span><br><span class="line">    COMx_InitDefine		COMx_InitStructure;					<span class="comment">//结构定义</span></span><br><span class="line">    COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;	<span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			<span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			<span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				<span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			<span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);		<span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line"></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		<span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0、L_Button、M_Button、R_Button</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  0			-y		 -s</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  -x		0		 +x</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  0			+y		 +s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 按下按键...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_down</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 准备好4个字节长度的数组，初值都是 0</span></span><br><span class="line">	u8 dat[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//2. 判定按下的哪个键位，组装数据	</span></span><br><span class="line">	<span class="comment">//2.1 判定按键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">1</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">// 左键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">1</span>; <span class="comment">// 右键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">// 中键</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.2 判定x方向</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">2</span> &amp;&amp; col ==<span class="number">1</span>) dat[<span class="number">1</span>] = <span class="number">-10</span>;  <span class="comment">// 向左移动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">2</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">1</span>] = <span class="number">10</span>;   <span class="comment">// 向右移动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.3 判定y方向</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">1</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">2</span>] = <span class="number">-10</span>;  <span class="comment">// -y 向上移动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">3</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">2</span>] = <span class="number">10</span>;   <span class="comment">// +y 向下移动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.4 判定滚轮</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">1</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">3</span>] = <span class="number">-10</span>;  <span class="comment">// -s 向下滚动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">3</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">3</span>] = <span class="number">10</span>;   <span class="comment">// +s 向上滚动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 发数据</span></span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//printf(&quot;dat[0]=%d\n&quot;, (int)dat[0]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[1]=%d\n&quot;, (int)dat[1]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[2]=%d\n&quot;, (int)dat[2]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[3]=%d\n&quot;, (int)dat[3]);	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">	u8 dat[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;up..\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// usb初始化</span></span><br><span class="line">    usb_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化矩阵键盘</span></span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">	UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		MK_Scan( key_down, key_up );        </span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/GPIO/</url>
    <content><![CDATA[<p>GPIO（General Purpose Input&#x2F;Output）是“通用输入输出”的缩写，它是微控制器（MCU）或单片机（MCU）、处理器或其他数字电子设备上用来处理各种信号的基本接口。<strong>是一种能够配置为不同模式的引脚或端口</strong>，用于与外部世界进行交互。能够配置为输入模式或输出模式，以实现不同的功能。</p>
<h3 id="GPIO-的主要特性"><a href="#GPIO-的主要特性" class="headerlink" title="GPIO 的主要特性"></a>GPIO 的主要特性</h3><p><strong>可配置性</strong>：</p>
<ul>
<li><strong>输入模式</strong>：当 GPIO 引脚被配置为输入时，微控制器可以通过该引脚<strong>读取外部信号的状态</strong>，通常是高电平（1）或低电平（0）。输入模式常用于读取传感器、按键、开关的状态。</li>
<li><strong>输出模式</strong>：当 GPIO 引脚被配置为输出时，微控制器可以通过该引脚<strong>驱动外部设备</strong>，如点亮 LED、驱动电机、控制继电器等。</li>
<li><strong>双向引脚</strong>：大多数 GPIO 引脚既可以作为输入，也可以作为输出，通常通过软件控制配置。</li>
</ul>
<p><strong>电平高低</strong>：</p>
<ul>
<li><strong>高电平（逻辑 1）</strong>：通常表示接近电源电压（如 3.3V 或 5V）。</li>
<li><strong>低电平（逻辑 0）</strong>：通常表示接近地电压（0V）。</li>
</ul>
<p><strong>输入&#x2F;输出电流能力</strong>： GPIO 引脚的输入和输出电流能力有限，一般只能驱动较小的负载。如果需要驱动更大的负载（如电机），通常需要使用额外的驱动器件（如晶体管或 MOSFET）。</p>
<p><strong>中断支持</strong>： 有些 GPIO 引脚支持中断，<strong>当引脚的状态变化（如从高电平变为低电平，或从低电平变为高电平）时，能够触发中断信号</strong>，让处理器及时响应。这在按钮按下、传感器信号变化等场景下非常有用。</p>
<p><strong>上拉&#x2F;下拉电阻</strong>： 为了确保输入引脚在未连接任何信号时有稳定的电平状态，GPIO 通常提供<strong>内部上拉电阻</strong>或<strong>下拉电阻</strong>。上拉电阻将引脚默认拉到高电平，而下拉电阻将引脚默认拉到低电平。这样可以防止引脚悬空时处于不确定状态。</p>
<h3 id="GPIO-的工作模式"><a href="#GPIO-的工作模式" class="headerlink" title="GPIO 的工作模式"></a>GPIO 的工作模式</h3><p><strong>输入模式</strong>：</p>
<ul>
<li><strong>功能</strong>：读取外部设备的电平状态。</li>
<li><strong>应用场景</strong>：检测按钮按下&#x2F;松开、读取传感器数据、检测信号电平。</li>
<li><strong>操作</strong>：配置 GPIO 为输入模式后，通过读取引脚的值（通常为 0 或 1）来获得外部设备的状态。</li>
</ul>
<p><strong>输出模式</strong>：</p>
<ul>
<li><strong>功能</strong>：通过 GPIO 向外部设备输出高电平或低电平信号。</li>
<li><strong>应用场景</strong>：控制 LED 点亮&#x2F;熄灭、驱动蜂鸣器、开关继电器等。</li>
<li><strong>操作</strong>：配置 GPIO 为输出模式后，可以设置引脚为高电平或低电平，控制外部设备。</li>
</ul>
<p><strong>中断模式</strong>：</p>
<ul>
<li><strong>功能</strong>：当 GPIO 引脚的电平状态发生变化时触发中断，处理器执行相应的中断服务程序（ISR）。</li>
<li><strong>应用场景</strong>：按钮按下时触发中断，传感器信号变化时立即响应。</li>
<li><strong>操作</strong>：配置 GPIO 为中断模式，并指定触发条件（如上升沿、下降沿或电平变化）。</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>在 <strong>STC8H</strong> 系列单片机中，GPIO（通用输入输出）引脚具有四种主要模式，分别是<strong>准双向口模式</strong>、<strong>推挽输出模式</strong>、<strong>开漏输出模式</strong>和<strong>高阻输入模式</strong>。</p>
<h3 id="准双向模式"><a href="#准双向模式" class="headerlink" title="准双向模式"></a><strong>准双向模式</strong></h3><p>默认状态下引脚处于高电平状态，且引脚内部连接了一个弱上拉电阻，既可以作为输入，也可以作为输出，不需要额外设置方向寄存器。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOzhunshuangxiang.png" alt="GPIOzhunshuangxiang"></p>
<h3 id="推挽输出模式"><a href="#推挽输出模式" class="headerlink" title="推挽输出模式"></a><strong>推挽输出模式</strong></h3><p>强推挽输出配置的下拉结构与开漏模式以及准双向口的下拉结构相同，但当锁存器为1时提供持续<br>的强上拉。推挽模式- -般用于需要更大驱动电流的情况。</p>
<p>强推挽引脚配置如下图所示:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOtuiwanshuchu.png" alt="GPIOtuiwanshuchu"></p>
<h3 id="开漏输出模式"><a href="#开漏输出模式" class="headerlink" title="开漏输出模式"></a><strong>开漏输出模式</strong></h3><p>【开漏工作模式】，对外设置输出为 1，等同于 【高阻输入】</p>
<p>【开漏工作模式】,【打开内部上拉电阻 | 或外部加上拉电阻】，简单等同于 【准双向口】</p>
<p>开漏模式既可读外部状态也可对外输出(高电平或低电平)。如要正确读外部状态或需要对外输出高电平，需外加上拉电阻。</p>
<p>当端口锁存器为0时，开漏模式关闭所有上拉晶体管。当作为一个逻辑输出高电平时，这种配置方式必须有外部上拉，一般通过电阻外接到 Vcc。如果外部有上拉电阻，开漏的 O 口还可读外部状态，即此时被配置为开漏模式的 IO 口还可作为输入IO 口。这种方式的下拉与准双向口相同。</p>
<p>开漏端口带有一个施密特触发输入以及一个干扰抑制电路。</p>
<p>输出端口配置如下图所示:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOkailou.png" alt="GPIOkailou"></p>
<h3 id="高阻输入模式"><a href="#高阻输入模式" class="headerlink" title="高阻输入模式"></a><strong>高阻输入模式</strong></h3><p> 电流既不能流入也不能流出。通常由三态缓冲器等电路元件实现。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOgaozu.png" alt="GPIOgaozu"></p>
<p><strong>电气特性：</strong></p>
<p>1、高电阻值：高阻态的管脚<strong>电阻极高</strong>，这使得通过该管脚的电流非常小，<strong>接近于零</strong>。这样的特性使得该管脚在电路中的电流驱动能力极弱，对电路中的电流分布影响极小。<br>2、电平不确定性：处于高阻态的管脚，其<strong>电平状态不确定</strong>。如果用万用表测量，测量结果可能是高电平，也可能是低电平，具体取决于该<strong>管脚后面所连接的电路元件</strong>。</p>
<p>内阻非常大，管脚输入电流有轻微波动都能识别到，电压等于电阻乘以电流。如果设为高阻态，当管脚连接的外设驱动能力非常弱，也不会误读电平状态。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在进行嵌入式开发中为什么需要多次指定同一个引脚，比如在使用 UART 时，需要 GPIO 和UART 分别指定一次引脚</strong></p>
<p>在嵌入式开发中，可能需要多次指定同一个引脚，例如在使用 UART 时，需要在 GPIO 和 UART 模块中分别进行引脚指定。这是因为<strong>引脚的功能配置和电气特性配置是独立的</strong>，并且涉及到不同的系统组件。下面详细解释为什么需要这样做，并且解释每个配置的角色和原因。</p>
<p><strong>配置方式</strong></p>
<ul>
<li><strong>GPIO 配置：</strong> 配置引脚的电气特性，如上拉&#x2F;下拉电阻、输入&#x2F;输出模式等。</li>
<li><strong>外设配置：</strong> 配置引脚用于特定的外设功能，如 UART 的 TX&#x2F;RX。外设模块需要知道具体的引脚用于什么功能，以便正确地处理信号。</li>
</ul>
<p>在嵌入式开发中，尽管一个引脚可能在物理上是相同的，但为了实现不同功能（如 GPIO 和 UART），需要在不同的配置阶段分别指定引脚。这是因为 GPIO 配置关注<strong>电气特性</strong>，而外设配置关注功能模式和功能启用。这种分离允许微控制器的引脚支持多种功能，并确保每种功能能够正常工作。</p>
<p>二、<strong>什么是电气特性</strong></p>
<p>在嵌入式系统和单片机开发中，”电气特性”（Electrical Characteristics）指的是引脚在<strong>不同工作模式下的电气行为和性能参数</strong>。这些特性决定了引脚如何与外部电路交互，并影响其在实际应用中的功能和可靠性。</p>
<p>举个例子，在一个典型的微控制器中，如果你配置一个引脚为输入模式并启用内部上拉电阻，这样可以确保在引脚没有外部信号连接时，它会稳定地保持在高电平。相反，如果配置为输出模式，你可以设置引脚为高电平或低电平，并确保它能够提供足够的电流来驱动连接的设备，如 LED。</p>
<p>简单来说，<strong>电气特性</strong>指的就是引脚在不同工作模式下的<strong>电压和电流</strong>相关的参数和行为。这些特性包括了引脚如何表现电压、电流的能力以及它如何响应不同的电气信号。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID_模拟键盘按键</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID_%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p><strong>如何去阅读 USB HID 设备开发指南</strong></p>
<p><strong>如何去看得懂官方的示例教程</strong></p>
<p><strong>按照我们的需求改造示例教程</strong></p>
<p>PC 通过 HID 协议与键盘进行交互，那么就可以分为两部分：</p>
<p><strong>STC8H 向 PC 发送按键报告</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usb_desc.c</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改描述符中的内容</span></span><br><span class="line"><span class="comment">// 1.修改产品描述符 -&gt; 也就是 PC 端中所显示的文本信息</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">0x0c</span>,<span class="number">0x03</span>, <span class="comment">// 0x0ec 为描述符的长度，与 PRODUCTDESC[12] 中的 12 对应   </span></span><br><span class="line">	<span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,     </span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;-&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0x2e</span>,<span class="number">0x95</span>, <span class="comment">// 键盘的 ASCII: \u952e\u76d8</span></span><br><span class="line">	<span class="number">0xd8</span>,<span class="number">0x76</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.修改制造商信息 </span></span><br><span class="line"><span class="comment">// 修改方式同上</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>] = &#123;</span><br><span class="line">    <span class="number">0x12</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 其他内容照 STC8H 示例即可</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 注意查看 HIDREPORTDESC -&gt; HID 报告的内容</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// usb_desc.h</span></span><br><span class="line"><span class="comment">// 修改对应的头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> code PRODUCTDESC[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改实现的方式</span></span><br><span class="line"><span class="comment">// 发送数据给PC，要传递进来8个字节长度的数组</span></span><br><span class="line"><span class="type">void</span> usb_class_in(BYTE key[<span class="number">8</span>]) &#123;</span><br><span class="line">    BYTE i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DeviceState != DEVSTATE_CONFIGURED)</span><br><span class="line">        <span class="keyword">return</span>;		</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (!UsbInBusy) &#123;</span><br><span class="line">        IE2 &amp;= ~<span class="number">0x80</span>;   <span class="comment">//EUSB = 0;</span></span><br><span class="line">        UsbInBusy = <span class="number">1</span>;</span><br><span class="line">        usb_write_reg(INDEX, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">            usb_write_reg(FIFO1, key[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        usb_write_reg(INCSR1, INIPRDY);</span><br><span class="line">        IE2 |= <span class="number">0x80</span>;    <span class="comment">//EUSB = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// MatrixKey.c    </span></span><br><span class="line"><span class="comment">/*	扫描按键，如果需要感知按下或者弹起的状态，那么就传递进来按下和弹起的函数</span></span><br><span class="line"><span class="comment">	如果有某一个方向不想感知，那么可以直接传递 NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">u16 MK_Scan( <span class="type">void</span>(*key_down)(u8,u8), <span class="type">void</span> (*key_up)(u8,u8)) &#123;	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//1. 拉低第1行</span></span><br><span class="line">		set_row(i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//2. 判定列</span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_col(j) == <span class="number">0</span> &amp;&amp; is_up(status,i ,j)	)&#123; <span class="comment">// 按下了</span></span><br><span class="line">				set_down(status ,i , j);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span>(key_down != <span class="literal">NULL</span>) key_down(i,j);</span><br><span class="line">					</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(get_col(j) == <span class="number">1</span> &amp;&amp; is_down(status,i,j) )&#123; <span class="comment">// 弹起了</span></span><br><span class="line">				set_up(status,i,j);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span>(key_up != <span class="literal">NULL</span>) key_up(i,j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> status; <span class="comment">// 返回16个按键的状态</span></span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    COMx_InitDefine COMx_Init;				</span><br><span class="line">    COMx_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    COMx_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    COMx_Init.UART_BaudRate  = <span class="number">115200ul</span>;</span><br><span class="line">    COMx_Init.UART_RxEnable  = ENABLE;	</span><br><span class="line">    COMx_Init.BaudRateDouble = DISABLE;			</span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_Init);	</span><br><span class="line">    </span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备好的键位对应的字母、功能键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Q		 W	 E	   R	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">A		 S	 D	   F	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">CapsLock C	 V     Backspace	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">Ctrl_L	 Gui Space Enter					</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备好键位对应的字节数据</span></span><br><span class="line"><span class="comment">0x14、0x1A、0x08、0x15</span></span><br><span class="line"><span class="comment">				   				   </span></span><br><span class="line"><span class="comment">0x04、0x16、0x07、0x09</span></span><br><span class="line"><span class="comment">				   				   </span></span><br><span class="line"><span class="comment">0x39、0x06、0x19、0x2A				   </span></span><br><span class="line"><span class="comment">				   </span></span><br><span class="line"><span class="comment">0xE0、0xE3、0x2C、0x58</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了更好的对应键位和字节，需要使用一个二维数组来组装字节数据</span></span><br><span class="line">u8 key_arr[<span class="number">4</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0x14</span>		,   <span class="number">0x1A</span> 		,		<span class="number">0x08</span>		, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>		,   <span class="number">0x16</span>		,		<span class="number">0x07</span>		,	<span class="number">0x09</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x39</span>		,   <span class="number">0x06</span>		,		<span class="number">0x19</span>		,	<span class="number">0x2A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>		,   <span class="number">0xE3</span>		,		<span class="number">0x2C</span>		,	<span class="number">0x58</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">u16 key_arr2[] = &#123;</span><br><span class="line">	<span class="number">0x14</span>, <span class="number">0x1A</span>, <span class="number">0x08</span>, <span class="number">0x15</span>,</span><br><span class="line">	<span class="number">0x04</span>, <span class="number">0x16</span>, <span class="number">0x07</span>,	<span class="number">0x09</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0x06</span>, <span class="number">0x19</span>,	<span class="number">0x2A</span>,</span><br><span class="line">  <span class="number">0xE0</span>, <span class="number">0xE3</span>, <span class="number">0x2C</span>,	<span class="number">0x58</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 num = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_down</span><span class="params">(u8 row, u8 col)</span>&#123;	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_up</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">	<span class="comment">// 如果我们要做成键盘，那么就必须走HID协议，此时串口就无法使用了</span></span><br><span class="line">	<span class="comment">//printf(&quot;up: %d-%d\n&quot; , (int)row , (int)col);	</span></span><br><span class="line">	u8 dat[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">// 一开始就是8个0</span></span><br><span class="line">	</span><br><span class="line">	num--;</span><br><span class="line">	</span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 last_status;  <span class="comment">// 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能   EAXSFR();</span></span><br><span class="line"></span><br><span class="line">    usb_init(); <span class="comment">//初始化USB信息，这样PC就知道我们是键盘了.</span></span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己的代码</span></span><br><span class="line">	UART_Config();</span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;       </span><br><span class="line">		u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		u8 num = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//usb_class_in();  // 发送按键数据给PC</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//1. 先扫描16个按键的状态，并且获取到16个按键的数据【按的是哪些键】</span></span><br><span class="line">		u16 status = MK_Scan(key_down , key_up);   <span class="comment">// 1111 1101 1011 1111</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">// 如果这次的键位数据和以前的键位数据一样，那么就不用发送键盘数据给PC了。</span></span><br><span class="line">		<span class="keyword">if</span>(status == last_status)&#123;</span><br><span class="line">			delay_ms(<span class="number">20</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//2. 遍历取出status的每一个二进制位，看看这个bit是否是 0 。 0-按下，1-弹起</span></span><br><span class="line">			<span class="keyword">for</span>( i= <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)&#123;  <span class="comment">// 1111 1111  1011 0110</span></span><br><span class="line">				</span><br><span class="line">			<span class="comment">//3. 依次取出来二进制位，判定是否是 0</span></span><br><span class="line">				</span><br><span class="line">			<span class="comment">//3.1 status是16位 ，判断 第 0 位是否是 0,  status &amp; (1&lt;&lt;0) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 1 位是否是 0， status &amp; (1&lt;&lt;1) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 2 位是否是 0， status &amp; (1&lt;&lt;2) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 4 位是否是 0， status &amp; (1&lt;&lt;3) == 0 </span></span><br><span class="line">				<span class="keyword">if</span>( ( status &amp; (<span class="number">1</span>&lt;&lt;i) ) == <span class="number">0</span>)&#123; <span class="comment">// 是按下</span></span><br><span class="line">										</span><br><span class="line">					<span class="comment">//4. 判断是功能键吗？组装功能键  0   Modifierkeys (D0:LCtrl D1:LShift D2:LAlt D3:LGui D4:RCtrl D5:RShift D6:RAlt D7:RGui)</span></span><br><span class="line">					<span class="keyword">if</span>(i == <span class="number">12</span>)&#123;  <span class="comment">//  Ctrl_L</span></span><br><span class="line">						dat[<span class="number">0</span>] |=  <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">13</span>)&#123;  <span class="comment">// Windows键</span></span><br><span class="line">						dat[<span class="number">0</span>] |=  <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">						<span class="comment">//5. 判断是普通键吗？组装普通键 第 2 ~ 7 字节，用来装普通的按键 </span></span><br><span class="line">						dat[num++] = key_arr2[i];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//5. 处理num的问题</span></span><br><span class="line">					<span class="keyword">if</span>(num &gt; <span class="number">7</span>) num = <span class="number">7</span>;					</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;																			</span><br><span class="line">			<span class="comment">//2.7. 发送数据</span></span><br><span class="line">			usb_class_in(dat);   <span class="comment">// 0000 0000</span></span><br><span class="line">			</span><br><span class="line">		  <span class="comment">//为了记录这次发送键位数据给PC的时候，16个按键是个什么状态。</span></span><br><span class="line">			last_status = status;  <span class="comment">// 1111 1111 1111 1111</span></span><br><span class="line">		</span><br><span class="line">			delay_ms(<span class="number">20</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PC 向 STC8H 发送状态更新报告</strong></p>
<p>接收 PC 端发送过来的报告是模拟功能键的功能</p>
<p>例如：按下 NumLock键：指示灯亮起，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 PC 返回的报告进行响应或者处理是 STC8H 自动响应的我们只需找到处理函数然后调用我们的代码即可</span></span><br><span class="line"><span class="comment">// 当PC发送数据给键盘的时候，会调用这个函数</span></span><br><span class="line"><span class="comment">// 查看 usb_desc.c中返回值内容的格式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output Report:  【要站在PC的角度看输出的输入】  PC --------u8 dat--------&gt; 键盘</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数字锁定键 NumLock    大小写切换键  CapsLock   滚动锁定键  ScrollLock</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0   LEDs (D0:NumLock D1:CapLock D2:ScrollLock)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hanlde_usb_out</span><span class="params">(BYTE led)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">usb_class_out</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">	 <span class="keyword">if</span> (usb_bulk_intr_out(UsbBuffer, <span class="number">1</span>) == <span class="number">1</span>)&#123;		</span><br><span class="line">			<span class="comment">//直接调用我们的函数</span></span><br><span class="line">			hanlde_usb_out( UsbBuffer[<span class="number">0</span>]);		 </span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    BYTE led;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    if (usb_bulk_intr_out(UsbBuffer, 1) == 1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        P4M0 &amp;= ~0x01;</span></span><br><span class="line"><span class="comment">        P4M1 &amp;= ~0x01;</span></span><br><span class="line"><span class="comment">        P6M0 &amp;= ~0xe0;</span></span><br><span class="line"><span class="comment">        P6M1 &amp;= ~0xe0;</span></span><br><span class="line"><span class="comment">        P40 = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        led = UsbBuffer[0];</span></span><br><span class="line"><span class="comment">        LED_NUM = !(led &amp; 0x01);</span></span><br><span class="line"><span class="comment">        LED_CAPS = !(led &amp; 0x02);</span></span><br><span class="line"><span class="comment">        LED_SCROLL = !(led &amp; 0x04);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">//处理键盘收到PC的数据  </span></span><br><span class="line"><span class="comment">// 0   LEDs (D0:NumLock D1:CapLock D2:ScrollLock)</span></span><br><span class="line"><span class="type">void</span> hanlde_usb_out(BYTE led)&#123; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		PC返回的值是这样的，按下第一次返回0，按下第二次就返回1，按下第三次就返回0，按下第四次就返回1，以此类推...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//LED1 = led &amp; 0x01;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;0) ) LED1 = ~LED1; //亮起来;  按下了数字锁定键</span></span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;1) ) LED2 = ~LED2; //亮起来;  按下了大小写切换键</span></span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;2) ) LED3 = ~LED3; //亮起来;  按下了滚动锁定键</span></span><br><span class="line">	</span><br><span class="line">	LED1 = !(led &amp; <span class="number">0x01</span>);     <span class="comment">//亮起来;  按下了数字锁定键</span></span><br><span class="line">	LED5 = !(led &amp; <span class="number">0x02</span>);     <span class="comment">//亮起来;  按下了大小写切换键</span></span><br><span class="line">	LED8 = !(led &amp; <span class="number">0x04</span>);     <span class="comment">//亮起来;  按下了滚动锁定键	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID协议</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>HID（Human Interface Device）协议是一种用于<strong>连接人机交互设备（如键盘、鼠标、游戏控制器等）到计算机</strong>或其他主机设备的通信协议。它是 <strong>USB（通用串行总线）设备的一部分</strong>，专门用于<strong>处理和管理人机交互设备的数据传输</strong>。</p>
<p><strong>HID 协议概述</strong></p>
<p>HID 协议最初是为 USB 而设计的，但随着技术的发展，它也被应用在其他通信方式上，例如 <strong>蓝牙</strong>。HID 设备以一种标准化的方式报告其数据，使得主机可以理解设备的输入和输出，无需依赖具体的硬件驱动。HID 的典型设备包括：</p>
<ul>
<li>键盘、鼠标、触控板、游戏手柄、条码扫描仪、远程控制设备</li>
</ul>
<p><strong>HID 设备的工作原理</strong></p>
<p>HID 协议定义了<strong>如何描述设备的功能</strong>以及<strong>如何传输数据</strong>。通过使用 HID 协议，<strong>设备和主机之间可以在无需特定驱动程序的情况下通信</strong>。</p>
<p>HID 设备通过 <strong>描述符（Descriptor）</strong> 向主机传达其自身信息。描述符是一个<strong>数据结构</strong>（例如数组），详细说明了设备的输入&#x2F;输出功能、设备的类型、报告格式等。主机通过解析描述符，可以知道如何与设备交互和处理其数据。</p>
<p><strong>通信流程</strong></p>
<p>USB HID通讯时序可以大致分为以下几个步骤：</p>
<ol>
<li>设备连接和初始化：设备被插入USB端口后，会进行初始化和配置，包括分配USB地址和设置通信端点等。</li>
<li>主机发送设备描述符：主机会向设备发送请求，要求设备提供自己的描述符信息，包括设备类型、厂商信息、设备功能等。</li>
<li>设备响应描述符请求：设备接收到主机的请求后，会根据请求提供相应的设备描述符信息，包括设备类型、厂商信息、设备功能等。</li>
<li>主机发送配置描述符：主机会向设备发送请求，要求设备提供自己的配置描述符信息，包括端点数量、数据传输速率、电源需求等。</li>
<li>设备响应配置描述符请求：设备接收到主机的请求后，会根据请求提供相应的配置描述符信息，包括端点数量、数据传输速率、电源需求等。</li>
<li>主机发送数据：主机会向设备发送数据包，数据包中包含了控制信息和数据内容。</li>
<li>设备接收和处理数据：设备接收到主机发送的数据包后，会进行处理和响应，包括识别控制信息和处理数据内容。</li>
<li>设备发送数据：设备会向主机发送数据包，数据包中包含了控制信息和数据内容。</li>
<li>主机接收和处理数据：主机接收到设备发送的数据包后，会进行处理和响应，包括识别控制信息和处理数据内容。</li>
<li>完成通讯：通讯完成后，设备和主机会进行断开连接和资源释放等操作。</li>
</ol>
<p>需要注意的是，USB HID通讯过程中的具体时序和流程可能会因为具体的应用场景和设备而有所不同，上述步骤仅供参考。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/HIDtongxinliucheng.png" alt="HIDtongxinliucheng"></p>
<p><strong>通信方式：中断传输</strong></p>
<p><strong>中断传输（Interrupt Transfer）</strong> 是 HID 协议中的核心通信方式。主机会定期轮询 HID 设备，询问其是否有新的输入数据。这种传输方式确保主机能够及时接收到输入数据（例如鼠标移动、按键输入等）。</p>
<p>当有数据变化时，设备通过中断传输将输入报告发送给主机，主机根据报告内容执行相应的操作，如在屏幕上移动鼠标光标、显示键盘输入的字符等。</p>
<blockquote>
<p>也就是说，当我通过单片机按键输入 Q 之后必须也要判断按键弹起不然他就会一直输出 Q</p>
</blockquote>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>学习官方 USB HID 范例</strong></p>
<ol>
<li><p>下载<a href="https://www.stcaimcu.com/forum.php?mod=attachment&aid=ODg3Mnw1NTVmMzc3NXwxNzEzNDMzODM4fDF8MTUyNQ==">8H试验箱</a>中的代码（60-HID(Human Interface Device)协议范例）使用其中的示例编译并烧录到开发板中；</p>
</li>
<li><p>将开发板的开关拨动到 HID</p>
</li>
<li><p>打开”设置“ -&gt; 搜索”蓝牙和其他设备设置“并点击 -&gt; 查看 ”输入“中的设备</p>
</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/HIDshili.png" alt="HIDshili"></p>
<blockquote>
<p>如果提示 ”其他设备“ USB-SERIAL CH340(COM3) 则说明没有将开关拨动到 HID</p>
<p>如果按照上述步骤执行，但是不显示”STC UST Keyboard“则可能需要多烧录几次（重复1、2、3步骤）</p>
</blockquote>
<p>官方示例的作用，就是帮助我们构建了一个HID设备，将设备注册到了PC机中。</p>
<p><strong>文件说明</strong></p>
<ul>
<li>usb.c 和 usb.h：  USB入口文件，提供USB所有功能，设备信息，配置信息，通讯过程等</li>
<li>usb_req_std.c 和 usb_req_std.h：设备信息和配置信息通讯过程中的逻辑实现。</li>
<li>usb_req_class.c 和 usb_req_class.h：通讯过程中的逻辑实现</li>
<li>usb_vendor.c 和 usb_vendor.h：初始化配置逻辑</li>
<li>usb_desc.c 和 usb_desc.h: 协议描述信息，内部是协议的常量信息。</li>
</ul>
<p><strong>修改 PC 端的显示</strong></p>
<p>修改 usb_desc.c 中间的内容即可：</p>
<ol>
<li>MANUFACTDESC 制造商信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原代码</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">8</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x08</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">===================================</span><br><span class="line"><span class="comment">// 修改后代码</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x12</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>, <span class="comment">// &#x27;T&#x27; 的 Unicode 表示：0x0054</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>, <span class="comment">// &#x27;O&#x27; 的 Unicode 表示：0x004F</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;E&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>0x12</code> 和 <code>0x03</code> 是用于 USB 描述符中的两个特定字节，</p>
<p><code>0x12</code> 是 <strong>18（十进制）</strong>，表示该字符串描述符的总长度为 <strong>18 字节</strong>。字符串描述符的第一个字节通常用来表示整个描述符的长度，包括描述符本身的所有数据。</p>
<p><code>0x03</code> 是 USB 标准中定义的 <strong>描述符类型代码</strong>，表示这是一个 <strong>字符串描述符（String Descriptor）</strong>。</p>
</blockquote>
<p>在上面的代码中要注意除了<strong>字符串描述类型代码</strong>之外要按照<strong>小端序</strong>，即<strong>低位在前，高位在后</strong>。</p>
<p>小端序是指<strong>低字节存储在低地址</strong>，高字节存储在高地址。在多字节数据类型（例如 16 位、32 位、64 位）中，小端序总是将数值的<strong>最低有效字节（LSB, Least Significant Byte）</strong>存储在最前面的地址位置，而<strong>最高有效字节（MSB, Most Significant Byte）</strong>放在最后的地址。（以 ‘T’ 为例在 0x0054 中，54 存储在数组中的低位也就是下标为 2 的位置，00 存储在数组的高位也就是下标为 3 的位置）</p>
<ol start="2">
<li>PRODUCTDESC 产品信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">26</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x1a</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;I&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line">=============================================</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">34</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x22</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;Z&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;I&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;i&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0x2e</span>, <span class="number">0x95</span>, <span class="number">0xd8</span>, <span class="number">0x76</span>,  <span class="comment">//\u952e \u76d8 键盘</span></span><br><span class="line">	<span class="string">&#x27;4&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;3&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改后长度发生变化，长度由第一个字符描述决定。</p>
<p>需要同时修改头文件长度配置信息</p>
<p>如果是中文，需要把中文转化为ASCII码格式（<a href="https://www.ip138.com/ascii/">ASCII在线转换</a>），写入其中</p>
<p>例如：</p>
<ul>
<li><code>今晚打母驴</code>对应ASCII码：<code>\u4eca\u665a\u6253\u6bcd\u9a74</code></li>
<li>汉字低位在前，添加<code>今</code>为：<code>0xca</code>, <code>0x4e</code></li>
</ul>
</blockquote>
<p><strong>兼容库函数</strong></p>
<p>由于提供的官方示例中，<code>stc.h</code> <code>STC8H.h</code> <code>config.h</code>，这些文件和我们需要用到的库函数，在变量定义或者是文件命名上，存在重名等冲突，需要进行修改。</p>
<p>将 STC8H 删掉用我们自己的，config.h 中有用到的不能删，就改个名字，stc.h 中有重复定义的删掉就行；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Soft_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MAtrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">URAT_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine COMx_InitStructure;					</span><br><span class="line">    COMx_InitStructure.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			</span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			</span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				</span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			</span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);	</span><br><span class="line"></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);	</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kay_down</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    dat[<span class="number">2</span>] = <span class="number">0x14</span> <span class="comment">// Q</span></span><br><span class="line">    usb_class_in(dat);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kay_up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能</span></span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    usb_init();</span><br><span class="line">    <span class="comment">//URAT_Config();</span></span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        MK_Scan(kay_down, kay_up);</span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="type">char</span> code CONFIGDESC[<span class="number">41</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x81</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as IN);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x08</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(8);	// 设备向主机传输最大不能超过 8 个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms);</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x01</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as OUT);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(1); // 设备接收主机传输最大不能超过 1 个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms);</span></span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>既然 通信方式为中断传输 那为什么我在单片机中写代码时要将语句放入 while(1) 循环中呢？</strong></p>
<p>虽然 HID 协议使用的是 <strong>中断传输</strong>，但在嵌入式系统中，通常还是需要将相关处理代码放在循环中。这是因为中断传输并不意味着单片机会自动处理所有的通信细节，尤其是在嵌入式开发中。具体原因如下：</p>
<ol>
<li><strong>中断传输与轮询机制的区别</strong></li>
</ol>
<ul>
<li><strong>中断传输</strong> 是一种 <strong>USB 通信方式</strong>，它表示<strong>主机</strong>会定期轮询 HID 设备，询问设备是否有新的数据。这是主机端的行为，即在 <strong>USB 层面</strong>，主机会定时查询设备，确保数据能及时获取。</li>
<li>然而，在嵌入式系统（如单片机）中，代码逻辑仍需要主动处理数据的接收、发送和状态检查，这通常通过循环来实现。</li>
</ul>
<blockquote>
<p>在 USB 或 HID 协议中，中断传输指的是 <strong>主机周期性地轮询设备</strong>，检查设备是否有数据需要传输。</p>
</blockquote>
<ol start="2">
<li><strong>单片机代码中的循环</strong></li>
</ol>
<ul>
<li><strong>实时响应与轮询</strong>：单片机的代码中，放入循环的目的是为了轮询设备的状态。例如，单片机在等待新数据或判断是否有新的中断信号产生时，需要在循环中反复检查某些状态寄存器或标志位。这样，当有数据到达或状态变化时，代码可以及时做出反应。</li>
<li><strong>中断并不是自动执行</strong>：中断传输并不意味着所有的数据传输都是自动完成的。中断传输指的是 USB 主机会定期轮询设备，但单片机仍然需要执行具体的处理代码，例如读写数据、处理中断信号等，这些都需要在主循环中完成。</li>
</ul>
<p>虽然 HID 协议使用中断传输方式，主机（如 PC）会定期轮询 HID 设备，但在嵌入式开发中，单片机的程序仍然需要通过循环来实现持续的任务调度、轮询状态和处理数据。循环确保代码可以实时检查设备的状态，及时响应中断请求。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C_OLED显示</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/I2C_OLED%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p><strong>OLED（有机发光二极管，Organic Light-Emitting Diode）</strong> 是一种显示技术，通过使用有机材料在电流通过时自发光来产生图像。与传统的 LCD（液晶显示器）不同，OLED 不需要背光源，因此可以实现更薄的显示器，并且具备许多独特的优点。</p>
<h2 id="I2C-协议"><a href="#I2C-协议" class="headerlink" title="I2C 协议"></a>I2C 协议</h2><p>I2C（Inter-Integrated Circuit）协议是一种广泛使用的<strong>双线同步串行通信协议</strong>，由飞利浦半导体（现为恩智浦半导体）在1982年发明。该协议以其简单的硬件连接和灵活的设备支持，在嵌入式系统和各种电子设备中得到了广泛应用。</p>
<p><strong>I2C 特点</strong></p>
<ul>
<li><strong>双线通信</strong>：I2C 是一种<strong>双线通信</strong>协议，使用两条线进行数据传输<ul>
<li><strong>SDA（Serial Data Line）</strong>: 用于数据传输的双向数据线。</li>
<li><strong>SCL（Serial Clock Line）</strong>: 用于同步数据传输的时钟线，由主设备生成时钟信号。</li>
</ul>
</li>
<li><strong>主从架构</strong>：支持<strong>多个主设备</strong>和<strong>多个从设备</strong>，可以灵活配置<ul>
<li><strong>主设备（Master）</strong>: 控制通信过程，生成时钟信号，并决定是发送数据还是接收数据。</li>
<li><strong>从设备（Slave）</strong>: 被动响应主设备的操作，它根据主设备发出的指令接收或发送数据。</li>
<li><strong>唯一地址</strong>: 每个从设备在总线上都有一个唯一的 7 位或 10 位地址，主设备通过地址识别与哪个从设备通信。</li>
</ul>
</li>
<li><strong>同步通信</strong>：时钟信号由主设备控制，从设备被动接收；但多主设备时主设备之间不能同时发起通信。</li>
<li><strong>寻址机制</strong>：每个从设备都有一个唯一的地址，主设备通过地址来选择与哪个从设备通信。</li>
</ul>
<p><strong>I2C 的通信过程</strong></p>
<ol>
<li><p><strong>起始条件（START Condition）</strong></p>
<ul>
<li>主设备将 SDA 线从<strong>高电平拉低</strong>，同时 SCL 保持高电平。这告诉所有从设备即将开始通信。</li>
</ul>
</li>
<li><p><strong>发送设备地址（Address Phase）</strong></p>
<ul>
<li><p>主设备接着发送从设备的<strong>7 位地址</strong>（或 10 位地址，视协议扩展），紧接着一个<strong>读&#x2F;写位</strong>（1 表示读，0 表示写）。SDA 在 SCL 时钟的<strong>高电平期间</strong>发送地址。</p>
</li>
<li><p>从设备检查地址是否与自身匹配，匹配的设备将准备回应。</p>
</li>
</ul>
</li>
<li><p><strong>应答（ACK&#x2F;NACK）</strong></p>
<ul>
<li>在地址发送后，从设备将<strong>拉低 SDA 线</strong>表示应答（ACK）。如果 SDA 保持高电平，则表示无应答（NACK），通信终止。</li>
</ul>
</li>
<li><p><strong>数据传输（Data Transfer Phase）</strong></p>
<ul>
<li><p>主设备开始发送或接收数据（视读&#x2F;写位）。每次数据传输是 8 位，数据在 SCL 线的<strong>高电平期间</strong>稳定，接收端读取数据。</p>
</li>
<li><p>每 8 位数据后，接收端发送一个应答信号（ACK&#x2F;NACK）。如果发送结束，接收端会发 NACK，表示数据结束。</p>
</li>
</ul>
</li>
<li><p><strong>停止条件（STOP Condition）</strong></p>
<ul>
<li>主设备将 SDA 从<strong>低电平拉高</strong>，同时 SCL 保持高电平，表示数据传输结束，释放总线。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>通信流程总结：</strong></p>
<ol>
<li>起始条件（START）</li>
<li>发送设备地址 + 读&#x2F;写位</li>
<li>应答信号（ACK）</li>
<li>传输数据（8 位）</li>
<li>接收设备发送应答（ACK&#x2F;NACK）</li>
<li>如果有更多数据，重复步骤 4-5</li>
<li>发送停止条件（STOP）</li>
</ol>
<p>这种过程可以让主设备与多个从设备通信，因为每个从设备都有独立的地址。</p>
</blockquote>
<h2 id="SSD1306"><a href="#SSD1306" class="headerlink" title="SSD1306"></a>SSD1306</h2><p><strong>SSD1306</strong> 是一款常用的单色 OLED（有机发光二极管）显示控制器驱动芯片，广泛用于小型OLED屏幕中，如 128x64 或 128x32 分辨率的显示屏。它的设计专为驱动OLED面板，并通过 I2C、SPI 或并行接口与微控制器或单片机通信。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/OLEDyinjioatu.png" alt="OLEDyinjioatu"></p>
<h4 id="软件模拟"><a href="#软件模拟" class="headerlink" title="软件模拟"></a>软件模拟</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////	 </span></span><br><span class="line"><span class="comment">//本程序只供学习使用，未经作者许可，不得用于其它任何用途</span></span><br><span class="line"><span class="comment">//中景园电子</span></span><br><span class="line"><span class="comment">//店铺地址：http://shop73023976.taobao.com/?spm=2013.1.0.0.M4PqC2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  文 件 名   : main.c</span></span><br><span class="line"><span class="comment">//  版 本 号   : v2.0</span></span><br><span class="line"><span class="comment">//  作    者   : HuangKai</span></span><br><span class="line"><span class="comment">//  生成日期   : 2014-0101</span></span><br><span class="line"><span class="comment">//  最近修改   : </span></span><br><span class="line"><span class="comment">//  功能描述   : OLED 4接口演示例程(51系列)</span></span><br><span class="line"><span class="comment">//              说明: </span></span><br><span class="line"><span class="comment">//              ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//              GND    电源地</span></span><br><span class="line"><span class="comment">//              VCC  接5V或3.3v电源</span></span><br><span class="line"><span class="comment">//              SCL  P10（SCL）</span></span><br><span class="line"><span class="comment">//              SDA  P11（SDA）</span></span><br><span class="line"><span class="comment">//              RES  P12 注：SPI接口显示屏改成IIC接口时需要接RES引脚</span></span><br><span class="line"><span class="comment">//                           IIC接口显示屏用户请忽略</span></span><br><span class="line"><span class="comment">//              ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 修改历史   :</span></span><br><span class="line"><span class="comment">// 日    期   : </span></span><br><span class="line"><span class="comment">// 作    者   : HuangKai</span></span><br><span class="line"><span class="comment">// 修改内容   : 创建文件</span></span><br><span class="line"><span class="comment">//版权所有，盗版必究。</span></span><br><span class="line"><span class="comment">//Copyright(C) 中景园电子2014/3/16</span></span><br><span class="line"><span class="comment">//All rights reserved</span></span><br><span class="line"><span class="comment">//******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bmp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line"></span><br><span class="line">	GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">		u8 t=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">	GPIO_Config();</span><br><span class="line">	OLED_Init();<span class="comment">//初始化OLED</span></span><br><span class="line">	</span><br><span class="line">	OLED_ColorTurn(<span class="number">0</span>);<span class="comment">//0正常显示，1 反色显示</span></span><br><span class="line">  	OLED_DisplayTurn(<span class="number">0</span>);<span class="comment">//0正常显示 1 屏幕翻转显示</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;		</span><br><span class="line">		OLED_DrawBMP(<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>,<span class="number">64</span>,BMP1);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_Clear();</span><br><span class="line">		OLED_ShowChinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>);<span class="comment">//中</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">16</span>);<span class="comment">//景</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>);<span class="comment">//园</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">16</span>);<span class="comment">//电</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">16</span>);<span class="comment">//子</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">16</span>);<span class="comment">//科</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">16</span>);<span class="comment">//技</span></span><br><span class="line">		OLED_ShowString(<span class="number">8</span>,<span class="number">2</span>,<span class="string">&quot;ZHONGJINGYUAN&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">20</span>,<span class="number">4</span>,<span class="string">&quot;2014/05/01&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">0</span>,<span class="number">6</span>,<span class="string">&quot;ASCII:&quot;</span>,<span class="number">16</span>);  </span><br><span class="line">		OLED_ShowString(<span class="number">63</span>,<span class="number">6</span>,<span class="string">&quot;CODE:&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowChar(<span class="number">48</span>,<span class="number">6</span>,t,<span class="number">16</span>);</span><br><span class="line">		t++;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="string">&#x27;~&#x27;</span>)t=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		OLED_ShowNum(<span class="number">103</span>,<span class="number">6</span>,t,<span class="number">3</span>,<span class="number">16</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_Clear();</span><br><span class="line">	&#125;	  	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">// olde.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span>	  	 </span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD  0	<span class="comment">//写命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 1	<span class="comment">//写数据</span></span></span><br><span class="line"></span><br><span class="line">sbit OLED_SCL=P3^<span class="number">2</span>;<span class="comment">//SCL</span></span><br><span class="line">sbit OLED_SDA=P3^<span class="number">3</span>;<span class="comment">//SDA</span></span><br><span class="line">sbit OLED_RES =P1^<span class="number">2</span>;<span class="comment">//RES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------OLED端口定义----------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCL_Clr() OLED_SCL=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCL_Set() OLED_SCL=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDA_Clr() OLED_SDA=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDA_Set() OLED_SDA=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_RES_Clr() OLED_RES=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_RES_Set() OLED_RES=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED控制用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ColorTurn</span><span class="params">(u8 i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DisplayTurn</span><span class="params">(u8 i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 sizey)</span>;</span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(u8 x,u8 y,u8 no,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(u8 x,u8 y,u8 sizex, u8 sizey,u8 BMP[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// olde.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span>  	 </span></span><br><span class="line"><span class="comment">//OLED的显存</span></span><br><span class="line"><span class="comment">//存放格式如下.</span></span><br><span class="line"><span class="comment">//[0]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[1]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[2]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[3]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[4]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[5]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[6]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[7]0 1 2 3 ... 127 			   </span></span><br><span class="line"><span class="type">void</span> delay_ms(<span class="type">unsigned</span> <span class="type">int</span> ms) &#123;                         </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">while</span>(ms) &#123;</span><br><span class="line">		a=<span class="number">1800</span>;</span><br><span class="line">		<span class="keyword">while</span>(a--);</span><br><span class="line">		ms--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反显函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ColorTurn</span><span class="params">(u8 i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//正常显示</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA7</span>,OLED_CMD);<span class="comment">//反色显示</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕旋转180度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DisplayTurn</span><span class="params">(u8 i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//正常显示</span></span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xC0</span>,OLED_CMD);<span class="comment">//反转显示</span></span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA0</span>,OLED_CMD);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_delay</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u8 t=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SDA_Clr();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Clr();	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_SDA_Clr();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待信号响应</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_WaitAck</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">//测数据信号的电平</span></span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Clr();</span><br><span class="line">	IIC_delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Send_Byte</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;        </span><br><span class="line">		OLED_SCL_Clr();<span class="comment">//将时钟信号设置为低电平</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">//将dat的8位从最高位依次写入</span></span><br><span class="line">			OLED_SDA_Set();</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			OLED_SDA_Clr();</span><br><span class="line">    	&#125;</span><br><span class="line">		IIC_delay(); <span class="comment">// 延时</span></span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 拉高信号线（高电平时写入）</span></span><br><span class="line">		IIC_delay(); 	<span class="comment">// 延时</span></span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 拉低信号线</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="comment">//向SSD1306写入一个字节。</span></span><br><span class="line"><span class="comment">//mode:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 mode)</span> &#123;</span><br><span class="line">	I2C_Start();</span><br><span class="line">	Send_Byte(<span class="number">0x78</span>);</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	<span class="keyword">if</span>(mode)&#123;Send_Byte(<span class="number">0x40</span>);&#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;Send_Byte(<span class="number">0x00</span>);&#125;</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	Send_Byte(dat);</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	I2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(u8 x, u8 y)</span> &#123; </span><br><span class="line">	OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte((x&amp;<span class="number">0x0f</span>),OLED_CMD);</span><br><span class="line">&#125;   	  </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;		   			 </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span> &#123;  </span><br><span class="line">	u8 i,n;		    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;  </span><br><span class="line">		OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">		OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">		OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">		<span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">	&#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63				 </span></span><br><span class="line"><span class="comment">//sizey:选择字体 6x8  8x16</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 sizey)</span> &#123;      	</span><br><span class="line">	u8 c=<span class="number">0</span>,sizex=sizey/<span class="number">2</span>;</span><br><span class="line">	u16 i=<span class="number">0</span>,size1;</span><br><span class="line">	<span class="keyword">if</span>(sizey==<span class="number">8</span>)size1=<span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> size1=(sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*(sizey/<span class="number">2</span>);</span><br><span class="line">	c=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值</span></span><br><span class="line">	OLED_Set_Pos(x,y);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i%sizex==<span class="number">0</span>&amp;&amp;sizey!=<span class="number">8</span>) OLED_Set_Pos(x,y++);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">8</span>) OLED_WR_Byte(asc2_0806[c][i],OLED_DATA);<span class="comment">//6X8字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>) OLED_WR_Byte(asc2_1608[c][i],OLED_DATA);<span class="comment">//8x16字号</span></span><br><span class="line"><span class="comment">//		else if(sizey==xx) OLED_WR_Byte(asc2_xxxx[c][i],OLED_DATA);//用户添加字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span> &#123;</span><br><span class="line">	u32 result=<span class="number">1</span>;	 </span><br><span class="line">	<span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;				  </span><br><span class="line"><span class="comment">//显示数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标</span></span><br><span class="line"><span class="comment">//num:要显示的数字</span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//sizey:字体大小		  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 sizey)</span> &#123;         	</span><br><span class="line">	u8 t,temp,m=<span class="number">0</span>;</span><br><span class="line">	u8 enshow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(sizey==<span class="number">8</span>)m=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++) &#123;</span><br><span class="line">		temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="number">0</span>) &#123;</span><br><span class="line">				OLED_ShowChar(x+(sizey/<span class="number">2</span>+m)*t,y,<span class="string">&#x27; &#x27;</span>,sizey);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 	OLED_ShowChar(x+(sizey/<span class="number">2</span>+m)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,sizey);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 sizey)</span> &#123;</span><br><span class="line">	u8 j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>) &#123;		</span><br><span class="line">		OLED_ShowChar(x,y,chr[j++],sizey);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">8</span>)x+=<span class="number">6</span>;</span><br><span class="line">		<span class="keyword">else</span> x+=sizey/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(u8 x,u8 y,u8 no,u8 sizey)</span> &#123;</span><br><span class="line">	u16 i,size1=(sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*sizey;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i%sizey==<span class="number">0</span>) OLED_Set_Pos(x,y++);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">16</span>) OLED_WR_Byte(Hzk[no][i],OLED_DATA);<span class="comment">//16x16字号</span></span><br><span class="line"><span class="comment">//		else if(sizey==xx) OLED_WR_Byte(xxx[c][i],OLED_DATA);//用户添加字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="comment">//x,y显示坐标</span></span><br><span class="line"><span class="comment">//sizex,sizey,图片长宽</span></span><br><span class="line"><span class="comment">//BMP：要显示的图片</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(u8 x,u8 y,u8 sizex, u8 sizey,u8 BMP[])</span> &#123; 	</span><br><span class="line">  u16 j=<span class="number">0</span>;</span><br><span class="line">	u8 i,m;</span><br><span class="line">	sizey=sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sizey;i++) &#123;</span><br><span class="line">		OLED_Set_Pos(x,i+y);</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;sizex;m++) &#123;      </span><br><span class="line">			OLED_WR_Byte(BMP[j++],OLED_DATA);	    	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化				    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_RES_Clr();</span><br><span class="line">	delay_ms(<span class="number">200</span>);</span><br><span class="line">	OLED_RES_Set();</span><br><span class="line">	</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--turn off oled panel</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD);<span class="comment">//--set contrast control register</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xCF</span>,OLED_CMD); <span class="comment">// Set SEG Output Current Brightness</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--set normal display</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//--1/64 duty</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//-not offset</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//--set display clock divide ratio/oscillator frequency</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//--set divide ratio, Set Clock as 100 Frames/Sec</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//--set pre-charge period</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//--set com pins hardware configuration</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//--set vcomh</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//Set VCOM Deselect Level</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x20</span>,OLED_CMD);<span class="comment">//-Set Page Addressing Mode (0x00/0x01/0x02)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x02</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//--set Charge Pump enable/disable</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//--set(0x10) disable</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA4</span>,OLED_CMD);<span class="comment">// Disable Entire Display On (0xa4/0xa5)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">// Disable Inverse Display On (0xa6/a7) </span></span><br><span class="line">	OLED_Clear();</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD); <span class="comment">/*display ON*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>STC8H 本身支持硬件实现，就是不用上面他们写的函数，给换成我们 STC8H 库函数中的读写函数就可以了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/PWM/</url>
    <content><![CDATA[<p><strong>PWM（Pulse Width Modulation，脉宽调制）</strong> 是嵌入式开发中一种非常常见的信号调制技术。它通过调节<strong>脉冲信号的宽度</strong>（占空比），来控制电流或电压的平均值，以达到对设备（如电机、LED、音频设备等）的精确控制。</p>
<p><strong>PWM的基本概念：</strong></p>
<ol>
<li><strong>脉冲信号</strong>：<ul>
<li>PWM 信号是一个方波信号，它在一定时间周期内反复地在高电平（“开”）和低电平（“关”）之间切换。</li>
</ul>
</li>
<li><strong>周期（T）</strong>：<ul>
<li>PWM信号的周期是指一个完整方波的<strong>时间</strong>长度。通常用频率（Hz）来表示，频率是周期的倒数，即 <strong>频率 &#x3D; 1&#x2F;周期</strong>。</li>
<li>例如，如果 PWM 信号的周期为 2 毫秒（ms），那么频率 &#x3D; 1 &#x2F; (2 * 10<sup>-3</sup>) &#x3D; 500 Hz</li>
<li>频率是<strong>单位时间</strong>（一秒）内完成周期（一个高低电平）性变化的次数</li>
</ul>
</li>
<li><strong>占空比（Duty Cycle）</strong>：<ul>
<li>占空比是指信号在一个周期内处于<strong>高电平的时间长度</strong>与<strong>总周期长度</strong>的比例。占空比的范围从0%到100%。</li>
<li>占空比 &#x3D; （高电平时间 &#x2F; 总周期时间）× 100%<ul>
<li>例如，占空比为50%的PWM信号意味着高电平和低电平各占一半时间；占空比为25%则表示信号只有四分之一的时间处于高电平。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMzhouqimaichong.png" alt="PWMzhouqimaichong"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 系列的单片机内部集成了8 通道 16 位高级 PWM 定时器，分成两周期可不同的 PWM，分别命名为 PWMA 和PWMB ，可分别单独设置。</p>
<p>第一组 PWMA 可配置成 4 组互补 &#x2F; 对称 &#x2F; 死区控制 的PWM 或捕捉外部信号。</p>
<p>第二组 PWMB 可配置成 4 路PWM 输出或捕捉外部信号。</p>
<p>两组 PWM 的时钟频率可分别独立设置。</p>
<h3 id="输出占空比"><a href="#输出占空比" class="headerlink" title="输出占空比"></a>输出占空比</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>串口实现 PWM 启停 0x01启动，0x00停止</p>
<p>拷贝所需库文件（其他必备库请自行准备）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H_PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PWM 周期时间设置为 1ms 24000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIOD (MAIN_Fosc/1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记位，是否更新PWM</span></span><br><span class="line"><span class="type">int</span> is_update_PWM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置马达 IO 引脚</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">    <span class="comment">// 摄制工作模式为 推挽输出</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_OUT_PP;		</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_1;	    </span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 UART IO 引脚</span></span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PWMx_InitDefine PWM_Init;</span><br><span class="line">    <span class="comment">// PWM 工作模式</span></span><br><span class="line">    PWM_Init.PWM_Mode = CCMRn_PWM_MODE1;</span><br><span class="line">    <span class="comment">// 设置周期时间 1ms</span></span><br><span class="line">    PWM_Init.PWM_Period = PERIOD - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置占空比</span></span><br><span class="line">    PWM_Init.PWM_Duty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置死区时间</span></span><br><span class="line">    PWM_Init.PWM_DeadTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出通道选择</span></span><br><span class="line">    PWM_Init.PWM_EnoSelect = ENO6P;</span><br><span class="line">    <span class="comment">// 使能计数器，开启输入捕获/比较输出</span></span><br><span class="line">    PWM_Init.PWM_CEN_Enable = ENABLE;</span><br><span class="line">    <span class="comment">// 主使能输出</span></span><br><span class="line">    PWM_Init.PWM_MainOutEnable = ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 既要配置小组，也要配置大组</span></span><br><span class="line">    PWM_Configuration(PWM6, &amp;init);<span class="comment">// 初始化 PWM4 口</span></span><br><span class="line">    PWM_Configuration(PWMB, &amp;init);<span class="comment">// 初始化PWM通用寄存器,  PWMA,PWMB</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要开启中断使能</span></span><br><span class="line">    <span class="comment">// PWM 不涉及中断，但是可以使用中断，如不使用可以不配置</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 切换引脚</span></span><br><span class="line">    PWM6_SW(PWM6_SW_P01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx; <span class="comment">//模式,UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1; <span class="comment">//使用波特率, BRT_Timer1,BRT_Timer2,BRT_Timer3,BRT_Timer4</span></span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>; <span class="comment">//波特率, 	   一般 110 ~ 115200</span></span><br><span class="line">    UART_Init.Morecommunicate = DISABLE;	<span class="comment">//多机通讯允许, ENABLE,DISABLE</span></span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE; <span class="comment">//允许接收,   ENABLE,DISABLE</span></span><br><span class="line">    UART_Init.BaudRateDouble = ENABLE; <span class="comment">//波特率加倍, ENABLE,DISABLE</span></span><br><span class="line"></span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口中断使能</span></span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    <span class="comment">// 切换引脚</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> direction = <span class="number">1</span>; <span class="comment">//控制占空比的变化 1 / -1</span></span><br><span class="line"><span class="type">int</span> percent = <span class="number">0</span>; <span class="comment">// 占空比值    </span></span><br><span class="line">PWMx_Duty duty; <span class="comment">// 占空比设置结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动PWM马达</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_motor</span><span class="params">()</span> &#123;</span><br><span class="line">    PWM_Config();</span><br><span class="line">    <span class="comment">//让pwm从0开始</span></span><br><span class="line">    percent = <span class="number">0</span>;</span><br><span class="line">    direction = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止PWM马达</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop_motor</span><span class="params">()</span> &#123;</span><br><span class="line">    PWMx_InitDefine PWM_Init;</span><br><span class="line">    <span class="comment">// PWM 工作模式</span></span><br><span class="line">    PWM_Init.PWM_Mode = CCMRn_FORCE_INVALID;</span><br><span class="line">    PWM_Configuration(PWM6, &amp;init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 由于PWM的配置相关特殊功能寄存器位于扩展RAM区域，</span></span><br><span class="line">    <span class="comment">// 访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写。</span></span><br><span class="line">    EAXSFR(); <span class="comment">//  扩展寄存器访问使能   </span></span><br><span class="line">    GPIO_Config();</span><br><span class="line">    PWM_Config();    </span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据表示位判断是否跟新占空比</span></span><br><span class="line">        <span class="keyword">if</span>(is_update_PWM) &#123;</span><br><span class="line">            <span class="comment">// 占空比 0~100 循环</span></span><br><span class="line">            percent += direction;</span><br><span class="line">            <span class="keyword">if</span>(percent &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                direction = <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(percent &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                direction = <span class="number">1</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="comment">// 设置占空比</span></span><br><span class="line">            duty.PWM6_Duty = PERIOD * percent / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 更新占空比</span></span><br><span class="line">            UpdatePwm(PWM6, &amp;duty);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 获取串口指令</span></span><br><span class="line">        <span class="keyword">if</span>(COM1.RX_Cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(RX1_Buffer[<span class="number">0</span>] == <span class="number">0x01</span>) &#123;</span><br><span class="line">                is_update_PWM = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 启动PWM</span></span><br><span class="line">                start_motor();               </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RX1_Buffer[<span class="number">0</span>] == <span class="number">0x00</span>) &#123;</span><br><span class="line">                is_update_PWM = <span class="number">0</span>;</span><br><span class="line">                stop_motor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        COM1.RX_Cnt = <span class="number">0</span>;   </span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">20</span>); </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>选择工作模式</strong></p>
<p>常用的有 模式1、模式2</p>
<p>一般来说，PWM 模式 2 是“下降模式”，即在计数器从最大值向下计数时输出高电平，而从0计数向上时输出低电平，反之亦然。这种模式决定了PWM信号的工作方式和输出形态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMmoshi.png" alt="PWMmoshi.png"></p>
<p><strong>设置PWM的占空比</strong></p>
<p>占空比：<strong>占空比是指信号为高电平的时间与一个周期内总时间的比值</strong>（也可以理解为在一个 PWM 周期内高电平所占的比值）。占空比为0意味着信号始终为低电平，而占空比为100%意味着信号始终为高电平。</p>
<p><strong>选择PWM输出的通道</strong></p>
<p>正相&#x2F;反相输出：正相（P）输出即正常的PWM波形，而反相（N）输出是正相波形的反相信号。在某些场合，如电机控制，需要同时输出正反相信号。</p>
<blockquote>
<p>配置好后，直接通过物理引脚输出即可，为什么还要选择或者说设置一个”PWM输出的通道”?</p>
<p>不同的微控制器（MCU）通常内部有多个PWM生成模块。每个PWM模块内部可以生成多个不同的PWM信号，称为<strong>通道</strong>。</p>
<p>假设你使用一个MCU有一个定时器，可以生成4个PWM通道。如果你需要输出两个不同频率和占空比的 PWM 信号到两个引脚上，就可以配置通道 1 和通道 2，分别对应这两个 PWM 信号，并将它们分别映射到不同的物理引脚。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMtongdaoyinjiaotu.png" alt="PWMtongdaoyinjiaotu"></p>
<p><strong>设置PWM的周期</strong></p>
<p>PWM 周期指的是一个完整的 PWM 波形从开始到结束的时间长度，通常以时间单位（如毫秒或微秒）表示。在一个周期内，PWM 信号会从高电平变化到低电平，然后再回到高电平，形成一个完整的波形。</p>
<p>频率 &#x3D; 1&#x2F;周期：频率它描述了PWM信号中脉冲（或周期）出现的快慢。具体来说，频率是单位时间内脉冲重复出现的次数，通常用赫兹（Hz）作为单位来表示。例如，如果一个PWM信号的周期是1毫秒（ms），那么它的频率就是1毫秒的倒数，即1000次&#x2F;秒，或者说1千赫兹（kHz）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMzhouqitu.png" alt="PWMzhouqitu"></p>
<p>周期的长短决定了PWM信号的频率。周期越短，频率越高；周期越长，频率越低。具体的单位取决于定时器的配置和时钟频率。</p>
<blockquote>
<p>STC8H 的时钟频率为 24 000 000，也就是 1 秒内有 24 000 000 个周期变化</p>
<p>我们这里将 PWM 周期设置为 1 ms 也就是 24 000 000 &#x2F; 1000 &#x3D; 24 000个周期变化</p>
<p>我们没法通过赋值 1，2这样来设置周期，只能通过上述的方式来进行计算；</p>
</blockquote>
<p><strong>设置死区时间</strong></p>
<p>死区时间：在一些应用中，尤其是控制 H 桥电路或电机驱动时，正相和反相信号之间可能需要一个短暂的时间间隔，称为<strong>死区时间</strong>。这个间隔可以防止在两个 MOSFET 或者 IGBT 同时导通时造成短路。如果你不需要这种保护，就可以将死区时间设置为0。</p>
<p><strong>启用PWM主输出</strong></p>
<p>主输出：这是一个全局开关，控制所有已配置的PWM输出通道是否真正输出信号。如果设置为DISABLE，则即便其他配置已经完成，信号仍不会输出。</p>
<p><strong>启用定时器计数</strong></p>
<p>这通常是 PWM 定时器的使能控制位。当启用时，定时器开始计数并生成PWM波形。如果设置为DISABLE，定时器停止计数，PWM信号也停止输出。</p>
<blockquote>
<p><strong>PWM（脉宽调制）</strong> 一般需要配合<strong>计数器（定时器）</strong>一起使用。PWM信号的生成过程依赖于计数器的工作机制，定时器用于控制PWM信号的频率和占空比。定时器通过不断计数和重置，来实现PWM信号的周期性变化。</p>
</blockquote>
<p><strong>选择输出引脚</strong></p>
<p>这一步将具体的 PWM 通道与物理引脚进行绑定。PWM4 的正相和反相信号将分别从使用的引脚输出。</p>
<h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>为什么周期计算要 -1</strong></p>
<p>假设我们希望 PWM 信号的周期时间是 100 个时钟周期。</p>
<p>定时器会从 <code>0</code> 开始计数，到达 <code>99</code> 后重置回 <code>0</code>。(从 0 数到 99 一共 99 次，然后在加一 就变成 0 了 也就是 数了 100 次)</p>
<p>从 <code>0</code> 计到 <code>99</code>，共计 100 次。</p>
<p>因此，我们设定的周期值应当是 <code>100 - 1 = 99</code>。</p>
<p>二、<strong>PWM 要用到计数器，那么为什么没有配置，或者说配置的内容在哪</strong></p>
<p>三、<strong>特殊功能寄存器</strong></p>
<p>由于 PWM 的配置相关特殊功能寄存器位于扩展 RAM 区域，访问这些寄存器,需先将P_SW2 的 BIT7 设置为 1,才可正常读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EAXSFR();		<span class="comment">/* 扩展寄存器访问使能 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将 EAXFR 置1</span></span><br><span class="line"><span class="comment">STC8H.h</span></span><br><span class="line"><span class="comment">#define	EAXSFR()		P_SW2 |= 0x80 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/teshugongnengyjiaojicunqi.png" alt="teshugongnengyjiaojicunqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/teshujicunqishuom.png" alt="teshujicunqishuom"></p>
<blockquote>
<p>详细可参见STC8手册：</p>
<ul>
<li>3.1.2 《外设端口切换控制寄存器 2（P_SW2）》</li>
<li>9.2.8 《扩展 SFR 使能寄存器 EAXFR 的使用说明》</li>
</ul>
</blockquote>
<p>四、<strong>没有指定为高电平（1）为什么马达也可以震动？</strong></p>
<p>当你配置完占空比并指定引脚后，PWM 模块已经在你所指定的引脚上开始工作，产生脉冲信号。在 PWM 模式下，即便你没有手动拉高马达引脚，PWM 模块会自动根据配置产生高低电平信号。这种信号的变化（方波）会驱动马达振动。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C总线</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/I2C%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p><strong>I2C（Inter-Integrated Circuit）是一种用于短距离通信</strong>的<strong>半双工同步串行</strong>通信<strong>协议</strong>，通常用于在电子设备中连接微控制器、传感器、显示器、EEPROM、ADC&#x2F;DAC 等外围器件。它由飞利浦公司在1982年发明，目的是简化不同集成电路之间的通信需求。</p>
<p>I2C协议采用了<strong>双线</strong>设计，使得多个设备可以通过<strong>同一条总线（数据线）</strong>互相通信，具有简单、灵活和高效的特点，广泛应用于嵌入式系统中。</p>
<p><strong>半双工：</strong>半双工通信是指在同一时间内，数据可以在两个方向上传输，但不能同时进行。换句话说，通信设备可以在发送和接收之间切换，但在任何给定的时刻只能进行一种操作。即使在同一总线上，主设备不能同时向从设备发送数据并接收数据。</p>
<p><strong>同步：</strong>同步通信是指数据的传输是通过一个共同的时钟信号进行协调的。所有参与通信的设备都依赖于同一时钟信号来发送和接收数据。</p>
<p><strong>串行通信：</strong>串行通信是指数据以逐位（bit）的形式进行传输，而不是一次传输多个数据位。</p>
<h2 id="I2C-的关键特性"><a href="#I2C-的关键特性" class="headerlink" title="I2C 的关键特性"></a>I2C 的关键特性</h2><ol>
<li><p><strong>主从结构</strong>：I2C是一种<strong>主从通信协议</strong>，其中<strong>主设备（Master）</strong>负责<strong>控制</strong>总线，启动和停止数据传输，管理时钟信号，而<strong>从设备（Slave）</strong>则<strong>被动响应</strong>主设备的请求。通常只有一个主设备，也支持多个主设备共存的架构。</p>
</li>
<li><p><strong>双线设计</strong>：I2C协议使用两条主要的信号线：</p>
<ul>
<li><p><strong>SDA（数据线，Serial Data Line）</strong>：用于传输数据。</p>
</li>
<li><p><strong>SCL（时钟线，Serial Clock Line）</strong>：用于同步数据传输。</p>
</li>
</ul>
<p>两根线都使用<strong>开漏（Open-drain）</strong>设计，需要外部上拉电阻来将信号线拉到高电平。</p>
</li>
<li><p><strong>设备寻址</strong>：I2C 总线上可以连接多个从设备，每个从设备有唯一的<strong>7位或10位地址</strong>。主设备通过发送目标从设备的地址来选择与哪个从设备通信。</p>
</li>
<li><p><strong>双向通信</strong>：</p>
<ul>
<li>I2C 支持<strong>半双工通信</strong>，数据可以在SDA线上<strong>双向传输</strong>，即主设备既可以发送数据给从设备，也可以从从设备接收数据。</li>
</ul>
</li>
<li><p><strong>同步通信</strong>：</p>
<ul>
<li>I2C 使用时钟信号（SCL）同步主设备和从设备之间的数据传输，保证每个数据位都在时钟信号的上升或下降沿有效。</li>
</ul>
</li>
</ol>
<blockquote>
<p>I2C协议使用开漏设计来实现 SDA 和 SCL 线的多设备连接。由于 I2C 总线上的多个设备需要共享 SDA 和 SCL 线，开漏设计允许多个设备通过<strong>拉低信号线来发送数据</strong>，而不会干扰其他设备的通信。上拉电阻确保信号线在没有设备拉低时维持高电平状态。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Czhuchong.png" alt="I2Czhuchong"></p>
<blockquote>
<ol>
<li>Master: 主设备。通常是主控 MCU</li>
<li>Slave：从设备。通常是功能芯片，例如 RTC 时钟，陀螺仪，温湿度等等。</li>
<li>SCL：时钟线，控制数据传输的速度和时序。</li>
<li>SDA：数据线。传输数据的。</li>
<li>地址：从设备地址。主设备通过地址进行访问。在总线中，每个从设备地址唯一，设备的地址通常是由设备制造商确定的，并在设备的数据手册中公布。。</li>
</ol>
</blockquote>
<h4 id="上拉电阻"><a href="#上拉电阻" class="headerlink" title="上拉电阻"></a>上拉电阻</h4><p>在 I2C 总线中，上拉电阻的大小通常是由以下几个因素决定的：</p>
<ol>
<li>总线长度：总线长度越长，上拉电阻的阻值就应该越小，以保证信号的稳定性。这是因为，总线长度越长，线路上的电容就越大，需要更多的电流来充电和放电，因此上拉电阻的阻值也应该相应地减小。</li>
<li>总线上的设备数量：总线上连接的设备数量越多，需要更大的电流来充电和放电，以确保信号的稳定性。因此，当总线上连接的设备数量增加时，上拉电阻的阻值也应该相应地减小。</li>
<li>总线上设备的最高工作频率：I2C 总线的时钟频率通常在 100kHz 到 400kHz 之间。如果总线上的设备需要使用更高的时钟频率，则上拉电阻的阻值应该相应地减小，以确保设备能够在规定的时间内完成数据的传输。</li>
</ol>
<p>总的来说，I2C 总线中上拉电阻的大小需要根据具体的情况来确定，以保证总线的稳定性和可靠性。一般来说，上拉电阻的阻值应该在 1kΩ 到 10kΩ 之间。</p>
<h4 id="信号电平"><a href="#信号电平" class="headerlink" title="信号电平"></a><strong>信号电平</strong></h4><p>I2C 总线的信号电平是基于器件的供电电压而定的，通常为 3.3V 或 5V。在 I2C 总线上，<strong>SDA 和 SCL 信号线都是开漏模式</strong>，因此需要外接上拉电阻，以避免信号电平的不确定性。（默认高电平）</p>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>I2C 总线的速度是由其<strong>时钟频率</strong>决定的。I2C 总线的时钟频率通常在 100kHz 到 400kHz 之间，其中 100kHz 是标准模式（Standard Mode），400kHz 是快速模式（Fast Mode）。</p>
<ul>
<li>在标准模式下，I2C 总线的时钟频率为 100kHz，数据传输速率最高可以达到每秒约 10kbps。标准模式适用于大多数的应用场景，可以满足许多设备的数据传输需求。</li>
<li>在快速模式下，I2C 总线的时钟频率为 400kHz，数据传输速率最高可以达到每秒约 40kbps。快速模式适用于一些需要更高速度的应用场景，例如传感器数据采集等。</li>
</ul>
<p>此外，I2C 总线还支持更高速度的高速模式（High Speed Mode）和超高速模式（Ultra-Fast Mode），它们的时钟频率分别为 1MHz 和 5MHz。这些高速模式通常用于一些需要非常高速数据传输的应用场景。</p>
<p>需要注意的是，总线的速度不仅受时钟频率的影响，还受到总线长度、电容负载、上拉电阻大小等因素的影响。因此，在实际应用中，需要根据具体情况来确定总线的速度以确保数据传输的稳定性和可靠性。</p>
<h3 id="I2C-的实现方式"><a href="#I2C-的实现方式" class="headerlink" title="I2C 的实现方式"></a>I2C 的实现方式</h3><p>I2C 通信可以通过两种主要方式实现：<strong>硬件实现</strong>和<strong>软件模拟</strong>。</p>
<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>硬件实现指的是使用微控制器（MCU）或其他芯片<strong>内置的 I2C 硬件模块</strong>来进行通信。这种方式利用了专门设计的电路来管理I2C通信的所有细节，如时钟同步、地址识别和数据传输。</p>
<p><strong>优点</strong></p>
<ol>
<li><strong>效率高</strong>：硬件处理所有通信细节，无需软件干预，减少了 CPU 的负担。</li>
<li><strong>实时性强</strong>：通信快速且时序准确，不会受到软件处理速度的影响。</li>
<li><strong>简化编程</strong>：大多数硬件 I2C 模块提供简单的接口用于发送和接收数据，无需编写复杂的控制代码。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><strong>灵活性较低</strong>：硬件实现通常固定支持一定的速率和模式，难以适应特殊的通信需求。</li>
<li><strong>硬件依赖</strong>：只能在支持硬件 I2C 模块的芯片上使用。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><strong>正确配置</strong>：确保正确设置 I2C 模块的时钟频率、从设备地址等参数。</li>
<li><strong>错误处理</strong>：编写代码时要考虑如何处理通信错误，如未应答、总线冲突等。</li>
<li><strong>电气特性</strong>：确保外围电路符合 I2C 的电气标准，例如上拉电阻的选择。</li>
</ul>
<h4 id="软件模拟（Bit-Banging）"><a href="#软件模拟（Bit-Banging）" class="headerlink" title="软件模拟（Bit-Banging）"></a>软件模拟（Bit-Banging）</h4><p>软件模拟，也称为Bit-Banging，是指通过软件<strong>控制普通的I&#x2F;O端口来模拟I2C通信</strong>。这种方式不依赖于硬件I2C模块，更加灵活。</p>
<p><strong>优点</strong></p>
<ol>
<li><strong>灵活性高</strong>：可以在任何具有GPIO功能的微控制器上实现。</li>
<li><strong>自定义能力强</strong>：可以根据需求自定义通信速率、时序等参数。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><strong>占用CPU资源</strong>：所有的通信过程都需要CPU来手动控制，可能影响程序的其他部分。</li>
<li><strong>实时性差</strong>：通信质量和速度受CPU处理能力和当前任务负载的影响。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><strong>精确时序</strong>：软件模拟需要精确控制时序，特别是在高速通信时。</li>
<li><strong>中断管理</strong>：需要处理可能在通信过程中发生的中断，确保数据的完整性。</li>
<li><strong>跨平台兼容性</strong>：在不同的硬件平台上，相同的软件模拟代码可能需要调整以适应特定的时钟和性能特性。</li>
</ul>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>在开发中使用I2C协议进行通信的流程可以分为以下几个步骤：</p>
<p><strong>硬件连接</strong></p>
<p><strong>选择主设备和从设备地址</strong></p>
<p><strong>软件的初始化</strong></p>
<p><strong>I2C 库函数 &#x2F; 寄存器</strong></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 系列的单片机内部集成了一个 <strong>I2C 串行总线控制器</strong>。I2C 是一种高速同步通讯总线，通讯使用  SCL (时钟线)和 SDA (数据线)两线进行同步通讯。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Cyinjiao.png" alt="I2Cyinjiao"></p>
<blockquote>
<p>在 STC8H 中 I2C 的控制器位于特殊寄存器地址范围内，所以访问使用时需要开启特殊寄存器允许使能</p>
</blockquote>
<h3 id="I2C-的读写"><a href="#I2C-的读写" class="headerlink" title="I2C 的读写"></a>I2C 的读写</h3><p>I2C 总线使用一条数据线（SDA）和一条时钟线（SCL）进行通信，由主设备控制整个总线，通过<strong>发送从设备地址</strong>来指定目标设备，然后进行数据的读取或写入。以下是I2C协议下读取和写入数据的流程。</p>
<h4 id="I2C-的读取流程"><a href="#I2C-的读取流程" class="headerlink" title="I2C 的读取流程"></a>I2C 的读取流程</h4><ol>
<li><p><strong>发送起始命令</strong>：主设备产生起始信号，SDA 在 SCL 为高电平时从高电平<strong>拉低</strong>，标志通信的开始。</p>
</li>
<li><p><strong>发送从设备地址 + 写入信号</strong>：主设备将从设备的地址加上写入方向位（RW&#x3D;0表示写）发送到总线上。总共发送8位数据：7位地址 + 1位方向。</p>
<ul>
<li>从设备地址。I2C 总线上，每个从设备都有唯一的地址，用于主设备识别通信对象。</li>
</ul>
</li>
<li><p><strong>等待从设备应答（ACK）</strong>：从设备收到地址后，若该地址匹配，会返回一个 <strong>ACK 信号</strong>（将SDA线拉低）。主设备检测 ACK 信号确认从设备准备好了，主设备准备接收数据。</p>
</li>
<li><p><strong>发送存储地址</strong>：主设备发送存储地址（mem_addr），发送完成后，再次调用 <code>RecvACK()</code>，等待 ACK 信号。</p>
<ul>
<li>存储地址为从设备中的寄存器地址</li>
</ul>
</li>
<li><p><strong>再次发送起始命令</strong>：在准备读取数据之前，主设备重新生成 I2C 的<strong>起始条件</strong>，通知总线上所有设备通信重新开始。这是因为从设备现在需要进入读取模式。</p>
</li>
<li><p><strong>发送设备地址+读命令</strong>：主设备发送从设备地址，这次地址的最低位为1，表示要进行读取操作。dev_addr | 1 通过将写位设置为 1，表示主设备希望从从设备读取数据。</p>
</li>
<li><p><strong>等待从设备应答</strong>：发送完从设备地址后的读命令，主设备再次等待从设备返回一个 ACK 信号，确认从设备已经准备好开始数据传输。</p>
</li>
<li><p><strong>接收数据</strong>：主设备从从设备接收数据，每接收一个字节后，主设备可以发送一个 ACK 信号，表明数据接收成功，继续接收下一个字节。通常，在接收最后一个字节时，主设备会发送 NACK（非应答）信号，表示结束接收。</p>
</li>
<li><p><strong>发送停止型号</strong>：最后，主设备生成 I2C 的<strong>停止条件</strong>，表示通信结束。停止信号通过 SDA 线在 SCL 线为高电平时从低电平拉高产生，告诉从设备数据传输已完成，总线释放。(将 SDA 拉高)</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: void I2C_ReadNbyte(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span></span><br><span class="line"><span class="comment">// 描述: I2C读取数据函数.</span></span><br><span class="line"><span class="comment">// 参数: dev_addr: 设备地址, mem_addr: 存储地址, *p读取数据存储位置, number读取数据个数.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-15</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">/*  DeviceAddress,WordAddress,First Data Address,Byte lenth   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ReadNbyte</span><span class="params">(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span>   </span><br><span class="line">&#123;</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr);                     <span class="comment">//发送设备地址+写命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	SendData(mem_addr);                     <span class="comment">//发送存储地址</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr|<span class="number">1</span>);                   <span class="comment">//发送设备地址+读命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		*p = RecvData(); <span class="comment">// 读取数据并存储到缓冲区</span></span><br><span class="line">		p++;</span><br><span class="line">		<span class="keyword">if</span>(number != <span class="number">1</span>) SendACK();          <span class="comment">//send ACK</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(--number);</span><br><span class="line">	SendNAK();                              <span class="comment">//send no ACK	</span></span><br><span class="line">	Stop();                                 <span class="comment">//发送停止命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="I2C-的写入流程"><a href="#I2C-的写入流程" class="headerlink" title="I2C 的写入流程"></a>I2C 的写入流程</h4><p>写入流程与读取流程类似~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: void I2C_WriteNbyte(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span></span><br><span class="line"><span class="comment">// 描述: I2C写入数据函数.</span></span><br><span class="line"><span class="comment">// 参数: dev_addr: 设备地址, mem_addr: 存储地址, *p写入数据存储位置, number写入数据个数.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-15</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">/*  DeviceAddress,WordAddress,First Data Address,Byte lenth   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_WriteNbyte</span><span class="params">(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span>  </span><br><span class="line">&#123;</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr);                     <span class="comment">//发送设备地址+写命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	SendData(mem_addr);                     <span class="comment">//发送存储地址</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendData(*p++);</span><br><span class="line">		RecvACK();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(--number);</span><br><span class="line">	Stop();                                 <span class="comment">//发送停止命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>I2C 是个通信协议，那为啥还有什么 I2C 的串行控制总线控制器呢，我不理解的地方在于，协议直接遵守实用就好了，为什么还需要配个控制器?</strong></p>
<ul>
<li><p><strong>I2C协议</strong>：是一个<strong>通信协议</strong>，定义了设备间如何通过两条线（SDA 数据线，SCL 时钟线）进行数据交换。这个协议规定了设备如何开始通信、发送数据、确认数据接收、结束通信等细节。</p>
</li>
<li><p><strong>I2C控制器</strong>：是<strong>硬件上的实现</strong>，用于帮助微控制器（MCU）或处理器遵守 I2C 协议进行通信。I2C 控制器负责处理协议中的细节，比如生成时钟信号、发送和接收数据、处理起始条件、停止条件、应答信号等。</p>
</li>
</ul>
<p>二、<strong>为什么需要 I2C 控制器?</strong></p>
<p>虽然 I2C 协议是一个标准，但协议本身只是一套规则，实际通信的实现需要底层的硬件电路来处理时序、信号生成、数据传输等任务。如果没有 I2C 控制器，微控制器将需要通过软件代码逐位操作引脚，手动处理所有协议细节。这是非常复杂且低效的。</p>
<p>三、<strong>在使用时，如何知道是传入写地址为设备从地址，还是传入读地址作为设备从地址？</strong></p>
<p>在 I2C 通信中，当要求传入从设备地址时，通常只需要传入 7 位的 <strong>从设备地址</strong>，即不需要区分读地址和写地址，传入的是设备的基础地址。</p>
<p>当然在一些微控制器中，比如 STC8H，它内部的 I2C 寄存器不自动处理 7 位地址和 R&#x2F;W 位，所以需要手动提供完整的 8 位地址；这时候就需要去查看<strong>数据手册</strong>、或者示例代码、又或者是具体的实现方式，查看他具体传输的是哪一个(当然一般在有 I2C 寄存器的芯片中，传输的从设备地址都是写地址)。</p>
<p>四、<strong>什么是开漏模式</strong></p>
<p><strong>开漏（open-drain）</strong> 指设备内部<strong>只能通过拉低引脚来输出低电平，而不能主动输出高电平(也就是说将引脚置 1 时，它是通过上拉电阻输出高电平的)。引脚的高电平由外部的上拉电阻提供</strong>，当设备不拉低引脚时，电压通过上拉电阻升高到逻辑高电平。</p>
<p>五、<strong>默认情况下（因为有上拉电阻），数据线不是一直是1么，他是一直向从设备传输1么？</strong></p>
<p>在 I2C 通信中，虽然数据线 <strong>SDA</strong> 和时钟线 <strong>SCL</strong> 默认情况下通过上拉电阻处于高电平（<strong>1</strong>），但这并不意味着总线在默认状态下一直传输 <strong>1</strong>。实际上，I2C 通信的关键在于时钟线 <strong>SCL</strong> 的配合，数据传输只在时钟有效时发生。下面是更详细的解释：</p>
<ol>
<li><strong>默认高电平的含义</strong></li>
</ol>
<ul>
<li><p><strong>SDA 和 SCL</strong> 默认处于高电平状态是为了表示 <strong>总线空闲</strong>。高电平表示当前没有通信正在进行。</p>
</li>
<li><p>高电平是因为没有设备主动拉低 SDA 或 SCL，这只是表示线路空闲，并不是传输 <strong>1</strong>。</p>
</li>
</ul>
<ol start="2">
<li><strong>通信开始（起始条件）</strong></li>
</ol>
<p>​	通信的开始由 <strong>主设备</strong> 发送<strong>起始条件</strong>来触发，起始条件的定义是：</p>
<ul>
<li><strong>SCL 处于高电平</strong> 时，主设备将 <strong>SDA</strong> 由 <strong>高电平拉低到低电平</strong>，这标志着通信的开始。</li>
<li>在此之后，主设备会根据时钟信号 <strong>SCL</strong> 控制 SDA 的电平，开始发送数据位。</li>
</ul>
<ol start="3">
<li><strong>数据传输的机制</strong></li>
</ol>
<p>​	数据的传输发生在 <strong>SCL 时钟信号的高电平周期</strong>，这时候 <strong>SDA</strong> 线上传输的是有效数据。</p>
<ul>
<li><strong>发送 0</strong>：主设备或从设备会主动拉低 <strong>SDA</strong> 线。</li>
<li><strong>发送 1</strong>：设备不会拉低 <strong>SDA</strong> 线，SDA 保持由上拉电阻提供的高电平。</li>
</ul>
<p>​	只有在 <strong>SCL 高电平</strong> 时，SDA 上的电平才会被解读为有效数据（<strong>0 或 1</strong>）。如果 SCL 处于低电平，SDA 的变化不被视为数据。</p>
<ol start="4">
<li><strong>数据线高电平不代表传输 1</strong></li>
</ol>
<ul>
<li><p><strong>SDA 默认高电平</strong> 并不意味着设备在传输 <strong>1</strong>。I²C 通信遵循特定的时序，只有在 <strong>SCL 高电平期间</strong> 读取 SDA 的状态，才能确定传输的是 <strong>0</strong> 还是 <strong>1</strong>。</p>
</li>
<li><p>当 <strong>总线空闲</strong>（即没有通信）时，SDA 和 SCL 线都保持高电平。但通信没有开始，所以没有传输任何有效数据。</p>
</li>
</ul>
<p>当 I²C 总线空闲时，<strong>SDA 和 SCL</strong> 都是高电平，这表示 <strong>没有通信正在进行</strong>，而不是在传输 <strong>1</strong>。</p>
<p><strong>数据传输</strong> 只会在通信启动（即发送起始条件）后，根据 <strong>SCL 时钟线的高低电平周期</strong>，在 SDA 线上传输有效数据位（0 或 1）。</p>
<p><strong>默认高电平</strong> 只是空闲状态，数据的传输取决于时钟信号的配合和 SDA 线的实际电平状态。</p>
<p>因此，虽然 SDA 线在空闲时是高电平，但它不会一直向从设备传输 <strong>1</strong>，只有在配合时钟信号的情况下，才会通过 SDA 传输有效的 <strong>0 或 1</strong>。</p>
<p>六、<strong>在下面这函数中我将最后的 OLED_SCL_Clr(); &#x2F;&#x2F; 拉低 SCL 去掉可以么，有什么影响？，为什么每个循环结束都要拉低 SCL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Send_Byte</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		OLED_SCL_Clr();<span class="comment">// 将时钟信号设置为低电平</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">// 将 dat 的 8 位从最高位依次写入</span></span><br><span class="line">			OLED_SDA_Set(); <span class="comment">// 将数据信号设置为高电平</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			OLED_SDA_Clr(); <span class="comment">// 将数据信号设置为低电平</span></span><br><span class="line">    &#125;</span><br><span class="line">		IIC_delay();</span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 将时钟信号设置为高电平，写入数据信号</span></span><br><span class="line">		IIC_delay();</span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 将时钟信号设置为低电平</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你将最后的 <code>OLED_SCL_Clr();</code>（拉低 SCL）去掉，会导致 <strong>I2C 时钟线 SCL</strong> 一直处于 <strong>高电平</strong>，这会对整个 I2C 通信产生不良影响。</p>
<p>在 <strong>I2C 协议</strong> 中，SCL 的高低电平交替用于同步数据传输。如果你不在传输完一个位之后将 <strong>SCL 拉低</strong>，SCL 就会一直保持在 <strong>高电平</strong>。</p>
<p>当 <strong>SCL 一直保持高电平</strong> 时，会导致以下两个主要问题：</p>
<ol>
<li><p><strong>时钟信号被认为未结束</strong></p>
<ul>
<li><p>I2C 的通信是基于 <strong>SCL 的上升沿和下降沿</strong> 来控制数据传输和同步的。</p>
</li>
<li><p>每一位数据传输后，<strong>SCL 必须回到低电平</strong> 才能标志着该位传输完成。</p>
</li>
<li><p>如果没有拉低 SCL，下一个数据位的传输将无法开始，通信也可能陷入死锁或混乱状态。</p>
</li>
</ul>
</li>
<li><p><strong>I2C 从设备无法正确同步数据</strong></p>
<ul>
<li><strong>从设备</strong> 在每次 <strong>SCL 下降沿</strong> 后才准备好接收下一位数据。如果 SCL 没有被拉低，从设备可能会认为当前数据还在传输，无法同步到下一个时钟周期。</li>
</ul>
</li>
</ol>
<p>尽管在循环开始时已经拉低了 SCL，但是 <strong>在每次数据位传输后（也就是循环的结尾），需要再次拉低 SCL</strong>，确保时钟周期完整，并为下一个数据位的传输做准备。</p>
<p><strong>SCL 需要周期性地升高和降低</strong>，形成时钟信号，这样 I2C 通信才能正常进行。</p>
<p>七、<strong>SCL 的时钟是如何产生的</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI_OLED显示</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/SPI_OLED%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>SPI（串行外设接口）是一种广泛应用的<strong>全双工同步串行通信协议</strong>，通常用于微控制器与外部设备之间的高速数据传输。它采用<strong>主从架构</strong>，通过<strong>主设备生成时钟信号</strong>并控制数据流动，通过四条主要信号线<strong>（MOSI、MISO、SCLK和SS）</strong>实现<strong>全双工通信</strong>。数据传输通过时钟的<strong>上升或下降沿</strong>进行，且支持可配置的时钟极性（CPOL）和相位（CPHA），以适应不同设备的要求。尽管SPI的传输速度较高，且实现相对简单，但其缺点在于需要较多的引脚和短距离传输的限制，适合用于传感器、存储器、显示屏及其他外设的接口。整体来说，SPI因其速度和灵活性在嵌入式系统中得到了广泛应用。</p>
<p><strong>全双工：</strong>全双工指的是通信的双方可以同时进行数据的发送和接收，彼此互不干扰。(也就是说需要至少两条线进行通信)</p>
<p><strong>同步：</strong>指数据的传输是通过一个共同的时钟信号进行协调的。所有参与通信的设备都依赖于同一时钟信号来发送和接收数据。</p>
<p><strong>串行通信：</strong> 数据通过一条数据线依次<strong>一位一位</strong>的发送。</p>
<p>发送设备和接收设备在<strong>同一时刻</strong>依据<strong>同一个时钟信号</strong>进行数据的采样和传输。</p>
<p><strong>SPI 协议通信过程</strong></p>
<ol>
<li><p><strong>主设备选择从设备</strong>：通过将对应从设备的 <strong>SS</strong> 线拉低，选中某个从设备进行通信。</p>
</li>
<li><p><strong>时钟同步</strong>：主设备生成 <strong>SCLK</strong>，并在时钟上升沿或下降沿驱动数据。</p>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li><p>在时钟脉冲的作用下，主设备通过 <strong>MOSI</strong> 线发送数据，同时从设备通过 <strong>MISO</strong> 线发送数据。</p>
</li>
<li><p>数据在时钟的上升沿或下降沿采样，具体依赖于时钟极性和相位设置。</p>
</li>
</ul>
</li>
<li><p><strong>完成通信</strong>：数据传输结束后，主设备将 <strong>SS</strong> 线拉高，终止对从设备的选择。</p>
</li>
</ol>
<p><strong>通信过程图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPItongxinliucheng.jpg" alt="SPItongxinliucheng"></p>
<blockquote>
<p>MOSI: 主设备输出，从设备输入（接收）</p>
<p>MISO: 主设备输入（接收），从设备输出</p>
<p>SCLK: 主设备生成的时钟信号</p>
<p>SS(NSS): 选择从设备的的信号（当每次传输完成后，主设备拉高 SS 信号，结束通信）</p>
</blockquote>
<h2 id="OLED显示屏"><a href="#OLED显示屏" class="headerlink" title="OLED显示屏"></a>OLED显示屏</h2><p>本次示例屏采用的是中景园的 0.96 寸 OLED 显示屏  SSD1306 驱动带字库</p>
<p><strong>如图所示</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIOLED.png" alt="SPIOLED"></p>
<blockquote>
<p>右图中左侧六个引脚的为字库芯片</p>
<p>右图中右侧三个引脚的为线性稳压器</p>
</blockquote>
<p><strong>引脚说明</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIyinjiaoshuom.png" alt="SPIyinjiaoshuom"></p>
<blockquote>
<p><strong>GND</strong>：逻辑电路的接地端。必须连接到地。</p>
<p><strong>VCC</strong>：OLED 的电源输入端。必须连接到电源。</p>
<p><strong>CLK &#x2F; SCL</strong>：串行时钟输入端。</p>
<p><strong>MOSI &#x2F; SDA</strong>：串行数据输入端。</p>
<p><strong>DC</strong>：数据&#x2F;命令控制引脚。当引脚拉高时，SDA输入作为显示数据处理；当引脚拉低时，SDA输入传递到命令寄存器。</p>
<p><strong>CS1</strong>：OLED 芯片选择引脚；低电平使能，高电平禁止。</p>
<p><strong>FSO</strong>：字库芯片的数据输出引脚。</p>
<p><strong>CS2</strong>：字库芯片选择引脚；低电平使能，高电平禁止。</p>
</blockquote>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIyuanlitu.png" alt="SPIyuanlitu"></p>
<blockquote>
<p>X096-2864KSWAG01：OLED 模块</p>
<p>8 * 2.54 ：8个引脚，引脚间距为 2.54</p>
<p>GT20L16S1Y：字库 IC</p>
<p>ME6206a33XG：线性稳压器</p>
</blockquote>
<p><strong>函数先根据你要展示的内容，去字库芯片中查找他的位置，然从指定位置中读出这些字，然后展示在 OLED 上</strong></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPISTC8Hyinjiaotu.png" alt="SPISTC8Hyinjiaotu"></p>
<p><strong>字库 IC 中地址计算方法，以 GB2313为例</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIICziku.png" alt="SPIICziku"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例里的函数讲解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.以写入 GB2313 字符集的汉字为例</span></span><br><span class="line"><span class="comment">// 以左上角为原点，显示：12864，带中文字库</span></span><br><span class="line">OLED_Display_GB2312_string(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;12864，带中文字库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.根据字库IC提供的计算方法算出该字符点阵在字库IC中的位置</span></span><br><span class="line">u32 fontaddr=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_GB2312_string</span><span class="params">(u8 x,u8 y,u8 *text)</span> &#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 addrHigh,addrMid,addrLow; </span><br><span class="line">	u8 fontbuf[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">while</span>(text[i]&gt;<span class="number">0x00</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((text[i]&gt;=<span class="number">0xb0</span>)&amp;&amp;(text[i]&lt;=<span class="number">0xf7</span>)&amp;&amp;(text[i+<span class="number">1</span>]&gt;=<span class="number">0xa1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//¹ú±ê¼òÌå£¨GB2312£©ºº×ÖÔÚ¾§ÁªÑ¶×Ö¿âICÖÐµÄµØÖ·ÓÉÒÔÏÂ¹«Ê½À´¼ÆËã£º</span></span><br><span class="line">			<span class="comment">//Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;BaseAdd=0</span></span><br><span class="line">			<span class="comment">//ÓÉÓÚµ£ÐÄ8Î»µ¥Æ¬»úÓÐ³Ë·¨Òç³öÎÊÌâ£¬ËùÒÔ·ÖÈý²¿È¡µØÖ·</span></span><br><span class="line">			fontaddr=(text[i]<span class="number">-0xb0</span>)*<span class="number">94</span>;</span><br><span class="line">			fontaddr+=(text[i+<span class="number">1</span>]<span class="number">-0xa1</span>)+<span class="number">846</span>;</span><br><span class="line">			fontaddr=fontaddr*<span class="number">32</span>;</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;   <span class="comment">//µØÖ·µÄ¸ß8Î»,¹²24Î»</span></span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;       <span class="comment">//µØÖ·µÄÖÐ8Î»,¹²24Î»</span></span><br><span class="line">			addrLow=(fontaddr&amp;<span class="number">0xff</span>);            <span class="comment">//µØÖ·µÄµÍ8Î»,¹²24Î»</span></span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">32</span>);</span><br><span class="line">			<span class="comment">//È¡32¸ö×Ö½ÚµÄÊý¾Ý£¬´æµ½&quot;fontbuf[32]&quot;</span></span><br><span class="line">			OLED_Display_16x16(x,y,fontbuf);</span><br><span class="line">			<span class="comment">//ÏÔÊ¾ºº×Öµ½LCDÉÏ£¬yÎªÒ³µØÖ·£¬xÎªÁÐµØÖ·£¬fontbuf[]ÎªÊý¾Ý</span></span><br><span class="line">			x+=<span class="number">16</span>;</span><br><span class="line">			i+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((text[i]&gt;=<span class="number">0xa1</span>)&amp;&amp;(text[i]&lt;=<span class="number">0xa3</span>)&amp;&amp;(text[i+<span class="number">1</span>]&gt;=<span class="number">0xa1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			fontaddr=(text[i]<span class="number">-0xa1</span>)*<span class="number">94</span>;</span><br><span class="line">			fontaddr+=(text[i+<span class="number">1</span>]<span class="number">-0xa1</span>);</span><br><span class="line">			fontaddr=fontaddr*<span class="number">32</span>;</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;</span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">			addrLow=(fontaddr&amp;<span class="number">0xff</span>);</span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">32</span>);</span><br><span class="line">			OLED_Display_16x16(x,y,fontbuf);</span><br><span class="line">			x+=<span class="number">16</span>;</span><br><span class="line">			i+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((text[i]&gt;=<span class="number">0x20</span>)&amp;&amp;(text[i]&lt;=<span class="number">0x7e</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> fontbuf[<span class="number">16</span>];</span><br><span class="line">			fontaddr=(text[i]<span class="number">-0x20</span>);</span><br><span class="line">			fontaddr=(<span class="type">unsigned</span> <span class="type">long</span>)(fontaddr*<span class="number">16</span>);</span><br><span class="line">			fontaddr=(<span class="type">unsigned</span> <span class="type">long</span>)(fontaddr+<span class="number">0x3cf80</span>);</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;</span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">			addrLow=fontaddr&amp;<span class="number">0xff</span>;</span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">16</span>);</span><br><span class="line">			OLED_Display_8x16(x,y,fontbuf);</span><br><span class="line">			x+=<span class="number">8</span>;</span><br><span class="line">			i+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向SSD1306写入一个字节。</span></span><br><span class="line"><span class="comment">//mode:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span> &#123;	</span><br><span class="line">	u8 i;	</span><br><span class="line">    <span class="comment">// 判断是命令（0）还是数据（1），将 DC 置 0/1</span></span><br><span class="line">	<span class="keyword">if</span>(cmd) &#123; </span><br><span class="line">	  OLED_DC_Set(); <span class="comment">// DC: 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  OLED_DC_Clr(); <span class="comment">// DC: 0	</span></span><br><span class="line">	&#125;	  </span><br><span class="line">    <span class="comment">// CS1 置 0，选择 OLED 芯片（SSD1306）</span></span><br><span class="line">    <span class="comment">// 表示要向 SSD1306 中写数据了</span></span><br><span class="line">	OLED_CS_Clr(); </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123; <span class="comment">// 写一个字节	8 位		  </span></span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 将 SCL(时钟) 置 0</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">// 从高位开始，依次判断 0 / 1</span></span><br><span class="line">		   OLED_SDA_Set(); <span class="comment">// 1 就将 SDA  置 1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		   OLED_SDA_Clr(); <span class="comment">// 0 就将 SDA 置 0</span></span><br><span class="line">		&#125;</span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 将 SCL 值 1，也就是上升沿</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">	&#125;				 		  </span><br><span class="line">	OLED_CS_Set(); <span class="comment">// 将 CS 置 1（不选择 OLED）</span></span><br><span class="line">	OLED_DC_Set(); <span class="comment">// 拉高作为数据  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从相关地址中：(计算出汉字在字库中的地址，然后将地址写入，然后从写入的地址中读出数据)</span></span><br><span class="line"><span class="comment">//（addrHigh：地址高字节,addrMid：地址中字节,addrLow：地址低字节）</span></span><br><span class="line"><span class="comment">// 中连续读出 DataLen 个字节的数据到 pbuff 的地址</span></span><br><span class="line"><span class="comment">// 连续读取</span></span><br><span class="line"><span class="comment">// 由于担心8位单片机有乘法溢出问题，所以分三部取地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_get_data_from_ROM</span><span class="params">(u8 addrHigh,u8 addrMid,u8 addrLow,u8 *pbuff,u8 DataLen)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	OLED_ROM_CS_Clr();</span><br><span class="line">    <span class="comment">// 0x03 通常是“读取数据”的命令</span></span><br><span class="line">    <span class="comment">// 表示准备从指定的地址开始读取数据。</span></span><br><span class="line">	Send_Command_to_ROM(<span class="number">0x03</span>);</span><br><span class="line">    <span class="comment">//送指令到晶联讯字库IC</span></span><br><span class="line">	Send_Command_to_ROM(addrHigh);</span><br><span class="line">	Send_Command_to_ROM(addrMid);</span><br><span class="line">	Send_Command_to_ROM(addrLow);</span><br><span class="line">    <span class="comment">// 从字库 IC 中读取出来 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DataLen;i++) &#123;</span><br><span class="line">		*(pbuff+i)=Get_data_from_ROM();</span><br><span class="line">  &#125;</span><br><span class="line">	OLED_ROM_CS_Set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从晶联讯字库IC中取汉字或字符数据（1个字节）</span></span><br><span class="line">u8 <span class="title function_">Get_data_from_ROM</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u8 i,read=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		OLED_SCL_Clr();</span><br><span class="line">		read&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// OLED_READ_FS0: 字库芯片的数据输出引脚。</span></span><br><span class="line">		<span class="keyword">if</span>(OLED_READ_FS0) &#123; </span><br><span class="line">			read++;</span><br><span class="line">    &#125;</span><br><span class="line">		OLED_SCL_Set();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数先根据你要展示的内容，去字库芯片中查找他的位置，然从指定位置中读出这些字，然后展示在 OLED 上</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>SPI 和 UART 的区别</strong></p>
<p>二、<strong>write 的代码也就是在控制数据点的高低，也没有显示的写入 OLED 的代码呀，为什么 OLED 可以保存并显示内容呢</strong></p>
<p>在 <code>OLED_WR_Byte()</code> 函数中，虽然没有显式写入 SSD1306 内存的代码，但实际的数据传输是通过 <strong>SPI 或 I2C</strong> 接口的硬件控制实现的。</p>
<p><strong>具体的写入过程</strong></p>
<ol>
<li><p><strong>数据传输过程</strong>：<br>每个字节通过 SDA 引脚按位传输。<code>OLED_SDA_Set()</code> 和 <code>OLED_SDA_Clr()</code> 控制数据线的电平状态（高或低），代表传输的每一位。每次时钟 <code>OLED_SCL_Set()</code> 上升沿时，SSD1306 会读取数据引脚上的电平，形成一个位数据。</p>
</li>
<li><p><strong>命令或数据的区分</strong>：<br><code>OLED_DC_Set()</code> 和 <code>OLED_DC_Clr()</code> 用于区分当前传输的是<strong>数据</strong>还是<strong>命令</strong>。高电平表示数据，低电平表示命令。这决定了 SSD1306 如何处理接收到的信息。</p>
</li>
<li><p>**芯片选择 (CS)**：<br><code>OLED_CS_Clr()</code> 拉低 CS 信号，告诉 SSD1306 开始通信。传输完成后，<code>OLED_CS_Set()</code> 结束通信。SSD1306 会根据传输的内容将数据存储到相应的显存地址中，并在下一个刷新周期内更新显示内容。</p>
</li>
</ol>
<p>三、<strong>时钟极性*CKP&#x2F;Clock Polarity）</strong></p>
<p>四、<strong>时钟相位</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/290620901">SPI协议详解（图文并茂+超详细） - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC时钟</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/RTC%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>RTC（Real-Time Clock，实时时钟）</strong>是一个重要的<strong>硬件</strong>模块，用来跟踪当前的时间和日期。与一般的系统时钟不同，RTC 具有独立的电源（通常为电池），即使系统断电或进入低功耗模式，RTC 仍然能够保持运行。</p>
<blockquote>
<p>这个当前时间与日期，指的是我的 RTC 中设置的时间和日期，一般不是 PC 的当前时间和日期；</p>
</blockquote>
<p><strong>RTC的基本特性</strong></p>
<ul>
<li><p><strong>独立性</strong>：RTC 时钟是<strong>独立于系统主处理器运行的</strong>，即使系统进入低功耗模式或关机，RTC 仍然能正常计时。这通常是通过一块<strong>备用电池</strong>（如纽扣电池）来供电实现的，如果没有电池，系统断电后 RTC 会停止工作，导致时间信息丢失。</p>
</li>
<li><p><strong>低功耗</strong>：RTC 的设计非常节能，因为它需要在设备断电或处于待机状态下保持时间。典型的 RTC 功耗极低，使得它能够在备用电池的支持下持续工作多年。</p>
</li>
<li><p><strong>精度</strong>：RTC 时钟的频率通常由一个外部的 <strong>32.768kHz晶振</strong> 提供，这种频率的晶振能够精确跟踪时间变化。之所以选择这个频率，是因为它可以通过二进制的除法很方便地分频为1秒。</p>
<p>32.768kHz 可以是默认，也可以是可设置的</p>
</li>
<li><p><strong>计时功能</strong>：除了记录当前时间，RTC 通常还能提供<strong>闹钟、定时</strong>等功能。例如，可以设定某个时间触发闹钟中断，唤醒处理器执行特定任务。</p>
</li>
</ul>
<p><strong>RTC时钟的组成部分</strong></p>
<ul>
<li><p><strong>晶振（Oscillator）</strong>：通常，RTC 时钟使用一个 <strong>32.768kHz</strong> 的石英晶体振荡器来提供计时参考。这种晶振因为频率较低，功耗小，且稳定性高，适合长时间精确计时。</p>
</li>
<li><p><strong>备用电池</strong>：为了确保系统断电后，RTC 仍能继续保持正确的时间，通常会有一个小型纽扣电池为其供电。即使系统关闭或断电，RTC 依然可以正常工作。</p>
</li>
<li><p><strong>寄存器</strong>：RTC 中包含用于存储当前时间、日期、以及闹钟设定的寄存器。操作系统或嵌入式程序可以通过访问这些寄存器来获取或设置时间信息。</p>
</li>
</ul>
<p><strong>RTC 与系统时钟的区别</strong></p>
<ul>
<li><p><strong>RTC（实时时钟）</strong>：RTC的主要任务是记录“实际时间”，即年、月、日、时、分、秒等。它不依赖系统的运行状态，即使在设备断电的情况下，它仍能通过备用电池继续运行。</p>
</li>
<li><p><strong>系统时钟</strong>：系统时钟（或CPU时钟）是提供处理器和系统运行时基的时钟信号。它的频率通常较高（以MHz或GHz为单位），主要用于协调系统中各个组件的工作。</p>
</li>
</ul>
<p><strong>RTC 中时间和日期的存储</strong></p>
<p>RTC 负责跟踪当前的时间和日期，这些信息通常以寄存器的形式存储在 <strong>RTC 芯片</strong>中。不同 RTC 芯片的实现略有不同，但一般来说，RTC 会将时间和日期以<strong>二进制编码的十进制（BCD）格式</strong>或直接的<strong>二进制格式</strong>存储。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>以 PCF8563 为例</strong></p>
<p>PCF8563：PCF8563 是一款低功耗的 I2C RTC 时钟芯片，能够以 <strong>BCD</strong> 格式存储时间和日期信息，并具有时钟报警、时钟输出等功能。它具有低功耗、集成度高、工作稳定等特点，适用于需要长时间运行且功耗要求较低的应用场景。</p>
<p>PCF8563 通过<strong>I2C总线</strong>与主控芯片（如微控制器）进行通信。</p>
<p><strong>存储格式</strong></p>
<blockquote>
<p>PCF8563 芯片使用 BCD 格式进行存储</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/Decimal2BCD.jpg" alt="Decimal2BCD"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/shijiyinjiao.jpg" alt="shijiyinjiao"></p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCshizhongyuanlitu.png" alt="RTCshizhongyuanlitu"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Cyuanlitu.png" alt="I2Cyuanlitu"></p>
<p>引脚说明：</p>
<ol>
<li>#INT： 中断引脚。当触发到定时任务时，会触发引脚高低电平变化。</li>
<li>SCL和SDA：为I2C通讯的两个引脚。用来保证MCU和RTC时钟芯片间进行通讯的。</li>
<li>OSCI：振荡器输入</li>
<li>OSCO：振荡器输出</li>
<li>Vss：地</li>
<li>SDA：串行数据 I&#x2F;O</li>
<li>SCL：串行时钟输入</li>
<li>CLKOUT：时钟输出（开漏）</li>
<li>VDD：正电源</li>
</ol>
<h3 id="实现时间的设置与读取"><a href="#实现时间的设置与读取" class="headerlink" title="实现时间的设置与读取"></a>实现时间的设置与读取</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> 	<span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UART_GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef UART_GPIO_init;</span><br><span class="line">	<span class="comment">//IO模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    UART_GPIO_init.Mode = GPIO_PullUp;		</span><br><span class="line">    UART_GPIO_init.Pin = GPIO_Pin_0 | GPIO_Pin_1; <span class="comment">//要设置的端口</span></span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;UART_GPIO_init);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 UART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    COMx_InitDefine UART_Init;   </span><br><span class="line">    <span class="comment">//模式,UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    <span class="comment">//使用波特率,   BRT_Timer1,BRT_Timer2,BRT_Timer3,BRT_Timer4</span></span><br><span class="line">    <span class="comment">//查看手册 UART 与 Timer 要对应起来</span></span><br><span class="line">	UART_Init.UART_BRT_Use = BRT_Timer1;		</span><br><span class="line">    <span class="comment">//波特率,一般 110 ~ 115200</span></span><br><span class="line">	UART_Init.UART_BaudRate = <span class="number">115200</span>;	</span><br><span class="line">    <span class="comment">//多机通讯允许, ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.Morecommunicate = DISABLE;	</span><br><span class="line">    <span class="comment">//允许接收,ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.UART_RxEnable = DISABLE;		</span><br><span class="line">    <span class="comment">//波特率加倍, ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.BaudRateDouble = DISABLE;	</span><br><span class="line">    </span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化一个显示函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RTC_Time</span> <span class="title">time</span> =</span> &#123;</span><br><span class="line">        <span class="comment">// 按照结构体定义顺序，年月日，时分秒，周</span></span><br><span class="line">        <span class="number">2024</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        <span class="number">24</span>,</span><br><span class="line">        <span class="number">3</span>        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">// 打开全局中断使能 UART 要用</span></span><br><span class="line">    </span><br><span class="line">    UART_Config();</span><br><span class="line">    RTC_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向 RTC 写入初始时间</span></span><br><span class="line">    RTC_WriteTime(&amp;time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读出 RTC 时间并 UART 打印</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取 RTC 时间</span></span><br><span class="line">        RTC_ReadTime(&amp;time);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d \n&quot;</span>,time.year, (<span class="type">int</span>)time.month, (<span class="type">int</span>)time.day, (<span class="type">int</span>)time.hour, (<span class="type">int</span>)time.minute, (<span class="type">int</span>)time.second);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;week=%d\n&quot;</span>, (<span class="type">int</span>)time.week);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1s间隔读一次时间</span></span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================================================================</span><br><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 零时存储时间的数组</span></span><br><span class="line">u8 timeDate[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转 BCD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Decimal2BCD(time) ((time / 10) &lt;&lt; 4 + (time %10) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BCD 转十进制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCB2Decima(i, b) (((timeDate[i] &amp; b) &gt;&gt; 4) * 10) + (timeDate[i] &amp; 0x0F)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_ADDR 0xA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEN_ADDR 0x02</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef RTC_GPIO_init;</span><br><span class="line">	<span class="comment">//IO模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    RTC_GPIO_init.Mode = GPIO_OUT_OD;		</span><br><span class="line">    RTC_GPIO_init.Pin = GPIO_Pin_2 | GPIO_Pin_3; <span class="comment">//要设置的端口</span></span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;RTC_GPIO_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_I2C_Config</span><span class="params">()</span> &#123;</span><br><span class="line">    I2C_InitTypeDef I2C_Init;</span><br><span class="line">    <span class="comment">//总线速度=Fosc/2/(Speed*2+4),0~63</span></span><br><span class="line">    <span class="comment">// 注意不要超过 PCF8563 的最大传输速度</span></span><br><span class="line">    I2C_Init.I2C_Speed = <span class="number">13</span>;				</span><br><span class="line">    <span class="comment">//I2C功能使能,ENABLE, DISABLE</span></span><br><span class="line">	I2C_Init.I2C_Enable = ENABLE;				</span><br><span class="line">    <span class="comment">//主从模式选择,  I2C_Mode_Master,I2C_Mode_Slave</span></span><br><span class="line">	I2C_Init.I2C_Mode = I2C_Mode_Master;		</span><br><span class="line">    <span class="comment">//主机使能自动发送,  ENABLE, DISABLE</span></span><br><span class="line">	I2C_Init.I2C_MS_WDTA = DISABLE;				</span><br><span class="line">	</span><br><span class="line">    I2C_Init(&amp;I2C_Init);</span><br><span class="line">	<span class="comment">//u8	I2C_SL_ADR; //从机设备地址,  0~127</span></span><br><span class="line">	<span class="comment">//u8	I2C_SL_MA; //从机设备地址比较使能,  ENABLE, DISABL</span></span><br><span class="line">    </span><br><span class="line">    I2C_SW(I2C_P33_P32);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    EAXSFR(); <span class="comment">// 开启特殊寄存器使能</span></span><br><span class="line">    </span><br><span class="line">    RTC_GPIO_Config();</span><br><span class="line">    RTC_I2C_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入 RTC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WriteTime</span><span class="params">(RTC_Time* time)</span> &#123;</span><br><span class="line">    <span class="comment">// 1,将时间存入数组，注意要转换为 BCD 码</span></span><br><span class="line">    <span class="comment">// 注意：在写入时，库函数是将数组按顺序存入 RTC 寄存器中的，</span></span><br><span class="line">    <span class="comment">// 所以此时要将数组的参数与 RTC 寄存器中时间的存储顺序对应</span></span><br><span class="line">    <span class="comment">// RTC 中存储的寄存器顺序为：</span></span><br><span class="line">    <span class="comment">// 秒、分钟、小时、日、星期、月/世纪、年</span></span><br><span class="line">    timeDate[<span class="number">0</span>] = Decima2BCD(time-&gt;RTC_Sec);</span><br><span class="line">    timeDate[<span class="number">1</span>] = Decima2BCD(time-&gt;RTC_Min);</span><br><span class="line">    timeDate[<span class="number">2</span>] = Decima2BCD(time-&gt;RTC_Hour);</span><br><span class="line">    timeDate[<span class="number">3</span>] = Decima2BCD(time-&gt;RTC_Day);</span><br><span class="line">    timeDate[<span class="number">4</span>] = (time-&gt;RTC_Week);</span><br><span class="line">    timeDate[<span class="number">5</span>] = Decima2BCD(time-&gt;RTC_Month);</span><br><span class="line">    timeDate[<span class="number">6</span>] = (((time-&gt;RTC_Year) % <span class="number">100</span> / <span class="number">10</span>) &lt;&lt; <span class="number">4</span>) + ((time-&gt;RTC_Year) % <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//世纪处理：</span></span><br><span class="line">    <span class="keyword">if</span>(time-&gt;RTC_Year &gt; <span class="number">2100</span>) &#123;</span><br><span class="line">        timeDate[<span class="number">5</span>] |= <span class="number">0x80</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        timeDate[<span class="number">5</span>] &amp;= <span class="number">0x80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时间</span></span><br><span class="line">    <span class="comment">//从设备地址、从设备寄存器地址、写入的数据、要写入数据多少</span></span><br><span class="line">    I2C_WriteNbyte(DEV_ADDR, MEN_ADDR, timeDate, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 RTC 中读取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ReadTime</span><span class="params">(RTC_Time* time)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    I2C_ReadNbyte(DEV_ADDR, MEN_ADDR, timeDate, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将读取的 BCD 转为十进制并存入结构体</span></span><br><span class="line">    <span class="comment">// 因为读取和写入都是按照顺序进行的，这里存放也要对应</span></span><br><span class="line">    <span class="comment">// 秒、分钟、小时、日、星期、月/世纪、年</span></span><br><span class="line">    time-&gt;RTC_Sec = DCB2Decima(<span class="number">0</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Min = DCB2Decima(<span class="number">1</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Hour = DCB2Decima(<span class="number">2</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Day = DCB2Decima(<span class="number">3</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Week = timeDate[<span class="number">4</span>];</span><br><span class="line">    time-&gt;RTC_Month = DCB2Decima(<span class="number">5</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Year = DCB2Decima(<span class="number">6</span>, <span class="number">0x70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeDate[<span class="number">5</span>] * <span class="number">0x80</span>) &#123;</span><br><span class="line">        time-&gt;RTC_Year += <span class="number">2100</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        time-&gt;RTC_Year += <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================================================================</span><br><span class="line"><span class="comment">//RTC.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RTC_H</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;type_def.h&quot;</span></span></span><br><span class="line"><span class="comment">// RTC 时间结构体    </span></span><br><span class="line">type <span class="keyword">struct</span> &#123;</span><br><span class="line">    u16	RTC_Year;  <span class="comment">//RTC 年, </span></span><br><span class="line">	u8	RTC_Month; <span class="comment">//RTC 月, 01~12</span></span><br><span class="line">	u8	RTC_Day;   <span class="comment">//RTC 日, 01~31</span></span><br><span class="line">	u8	RTC_Hour;  <span class="comment">//RTC 时, 00~23</span></span><br><span class="line">	u8	RTC_Min;   <span class="comment">//RTC 分, 00~59</span></span><br><span class="line">	u8	RTC_Sec;   <span class="comment">//RTC 秒</span></span><br><span class="line">    u8  RTC_Week;  <span class="comment">//RTC 周</span></span><br><span class="line">&#125;RTC_Time;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化RTC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">RTC_WriteTime(RTC_Time* time);</span><br><span class="line">RTC_ReadTime(RTC_Time* time);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="实现闹钟"><a href="#实现闹钟" class="headerlink" title="实现闹钟"></a>实现闹钟</h3><ul>
<li><p>闹钟是基于 RTC 提供的实际时间设置的。你需要指定一个绝对的触发时间，包括小时、分钟、甚至日期等。</p>
</li>
<li><p>一旦时间到达设定的时刻，闹钟触发一次。</p>
</li>
<li><p>闹钟不具备自动重设功能，需要手动重新设定。</p>
</li>
</ul>
<p>这里为了实现闹钟和定时器先介绍两个寄存器：</p>
<p><strong>控制 &#x2F; 状态寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCkongzhijicuncunqi.png" alt="RTCkongzhijicuncunqi"></p>
<blockquote>
<p>这里我们要关注下AF、TF、AIE、TIE</p>
<p>AF：报警标志位，当报警事件发生时，AF 标志位会被置为 1。需要我们手动软件置零。</p>
<p>TF：定时器标志位，当定时器事件触发时，TF 标志位会被置为 1。需要我们手动软件置零。</p>
<p>AIE：报警中断使能位，AIE 控制的是闹钟的中断使能。如果 AIE 置位为 1，AF 置位时将触发中断。</p>
<p>TIE：定时器中断使能位，TIE 控制的是定时器的中断使能。如果 TIE 置位为 1，TF 置位时将触发中断。</p>
</blockquote>
<p><strong>报警寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCnaozhongjicunqi.png" alt="RTCnaozhongjicunqi"></p>
<blockquote>
<p>这里可以看到我们想要设置某个闹钟时间，只需要将他的最高位置 0，余下的 7 位设置为具体的时间即可。</p>
</blockquote>
<p>这里要理解所谓的实现闹钟的功能，并不是说我们设定一个时间后，这个 RTC 到达指定时间后自己会发声，而是指他在达到我们设置顶的事件后他的中断输出引脚会产生一个低电平（或者是高电平），我们要去捕捉这个中断，然后通过蜂鸣器去实现这个闹钟的功能，定时器也是同理。 </p>
<p><strong>实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所谓的闹钟就是设定的时间到了，#INT 引脚会发出中断（也就是一个高电平或者低电平）</span></span><br><span class="line"><span class="comment">// 我们需要在这个中断中去进行闹钟功能的触发</span></span><br><span class="line"><span class="comment">// 1.将这个引脚初始化</span></span><br><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EXTI_Config</span><span class="params">()</span>&#123;</span><br><span class="line">	EXTI_InitTypeDef init;</span><br><span class="line">	<span class="comment">//中断模式,EXT_MODE_RiseFall 0 上升沿/下降沿中断</span></span><br><span class="line">    <span class="comment">// 		  EXT_MODE_Fall 1 下降沿中断</span></span><br><span class="line">	init.EXTI_Mode = EXT_MODE_RiseFall;			</span><br><span class="line">	</span><br><span class="line">	Ext_Inilize(EXT_INT3,&amp;init);</span><br><span class="line">	</span><br><span class="line">	NVIC_INT3_Init(ENABLE , Priority_0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.设置闹钟寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StartAlarm</span><span class="params">(RTC_Alarm * alarm)</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//一开始就设置了4个最高位都是1的数据</span></span><br><span class="line">    	<span class="comment">// 4 个 AE 默认 1 不可用</span></span><br><span class="line">    	<span class="comment">// 按寄存器的顺序分别是分钟、小时、天、星期</span></span><br><span class="line">		u8 arr[<span class="number">4</span>] = &#123;<span class="number">0x80</span> , <span class="number">0x80</span> , <span class="number">0x80</span> , <span class="number">0x80</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 配置闹钟开关 :: 允许启用闹钟</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">//1.1 先把控制寄存器的数据读取出来</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//1.2 修改第1位【AIE = 1】 --- 允许闹钟中断</span></span><br><span class="line">    	<span class="comment">// 闹钟中断使能位</span></span><br><span class="line">		rtc_dat |= <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.3 修改第3位【AF = 0】 ---- 表示闹钟还没有响过，</span></span><br><span class="line">        <span class="comment">// 将报警标志位置 0 表示没有闹钟发声</span></span><br><span class="line">		rtc_dat &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.4 再把修改好的数据写回去</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//再度一次，看看我的配置有没有写进去？</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//2. 到底配的是几点? 什么时间响闹钟?</span></span><br><span class="line">    	<span class="comment">// 配置闹钟多少点响，也就是什么时候触发中断	</span></span><br><span class="line">		<span class="comment">//判断分钟  0 ~ 59</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;minute != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的分</span></span><br><span class="line">            <span class="comment">// 因为是以 BCD 存储的所以要转为 BCD</span></span><br><span class="line">			arr[<span class="number">0</span>] = Decimal2BCD(alarm-&gt;minute );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">0</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断小时 0 ~ 23</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;hour != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">1</span>] = Decimal2BCD(alarm-&gt;hour );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">1</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断日期 1 ~ 31</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;day != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">2</span>] = Decimal2BCD(alarm-&gt;day );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">2</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断星期 0 ~ 6</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;week != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">3</span>] = Decimal2BCD(alarm-&gt;week );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">3</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="comment">// 回写到寄存器</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, ALA_ADD, arr, <span class="number">4</span>);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是闹钟中断还是定时器中断</span></span><br><span class="line">u8 <span class="title function_">RTC_ISAlarmINT</span><span class="params">()</span> &#123;</span><br><span class="line">	u8 dat;</span><br><span class="line">	I2C_ReadNbyte(<span class="number">0xA2</span>, <span class="number">0x01</span>, &amp;dat, <span class="number">1</span>);	</span><br><span class="line">	<span class="comment">//判断第3位 AF 是否是1，如果是1，即表示是闹钟引发的中断，否则就是其他引发的中断</span></span><br><span class="line">	<span class="keyword">return</span> dat &amp; <span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.接下来就是中断的配置，</span></span><br><span class="line"><span class="comment">// 当 RTC 的 #INT 引脚触发了高电平（低电平），我们需要指定 #INT 引脚所对应的中断发声</span></span><br><span class="line"><span class="comment">// 从 GPIO 配置中可以看到我们用的 EXIT3 也就是外部中3</span></span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">// Exti_lsr.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> handle_tit3_interrupte();    </span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: INT3_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: INT3中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT3_ISR_Handler</span> <span class="params">(<span class="type">void</span>)</span> interrupt INT3_VECTOR		<span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加用户代码</span></span><br><span class="line"><span class="comment">//	P03 = ~P03;</span></span><br><span class="line">	WakeUpSource = <span class="number">4</span>;</span><br><span class="line">	handle_tit3_interrupte(); <span class="comment">// 这就是我们自订的处理函数</span></span><br><span class="line">&#125;  </span><br><span class="line">=============================================================================</span><br><span class="line"><span class="comment">// 4.定义我们处理的逻辑，也就是我们要做的事情（发声）</span></span><br><span class="line"><span class="comment">// 这里又要思考一点事情</span></span><br><span class="line"><span class="comment">// 4.1 前面寄存器介绍中所过 AF / TF 要软件置 0</span></span><br><span class="line"><span class="comment">// 4.2 我们只有一个 #INT 口，却有两个可以触发中断的方法闹钟和定时器</span></span><br><span class="line"><span class="comment">//     这里需要判断下是闹钟还是定时器触发的中断</span></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">void</span> handle_tit3_interrupte() &#123;</span><br><span class="line">    <span class="keyword">if</span>(RTC_ISAlarmINT()) &#123;</span><br><span class="line">        os_create_task(TASK_BUZZER); <span class="comment">// 是闹钟就发声</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        os_create_task(TASK_LED); <span class="comment">// 不是闹钟就肯定是定时器，就做其他的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应的闹钟中断标志位置 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearAlarmFlag</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除闹钟控制寄存器配置。</span></span><br><span class="line">    <span class="comment">// 把AF置 0 【响过闹钟之后，这个AF会 置1 ，要手动清0，否则下一次闹钟到了之后，不会响了！】</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);	</span><br><span class="line">	<span class="comment">// 把第3位 置 0</span></span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x08</span>;	</span><br><span class="line">	<span class="comment">//再写回去</span></span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止（关闭）闹钟的逻辑，将闹钟的中断使能位置 0</span></span><br><span class="line"><span class="comment">// 如果不关闭，假设我设置 30min 时候发声，他会到每一个 30min 发声</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StopAlarm</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 设置控制寄存器里面的AIE = 0 ， 表示闹钟中断无效！</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x02</span>;</span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h3><ul>
<li><p>PCF8563 定时器是基于倒计时的，可以设定为倒计时模式。当倒计时时间到达 0 时，定时器触发一个事件，并可以选择重新倒计时或者停止。</p>
</li>
<li><p>定时器的时间间隔可以设定为秒、分钟等。</p>
</li>
<li><p>定时器一般是循环计时，可以周期性地执行任务，时间结束后重新开始计时。</p>
</li>
</ul>
<p><strong>倒计时定时器寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCdaojisjishijicunqi.png" alt="RTCdaojisjishijicunqi"></p>
<blockquote>
<p>大致与上面闹钟同理：区别在于两个参数：<br>TD1、TD0：用于设置定时器的时钟频率，</p>
<p>定时器倒计数数值寄存器位描述：具体倒计时要数的数，通过这两个可以设置倒计数的时长</p>
<p>以 64 Hz 为例，那么 设置寄存器值位 64 就是 1s</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"><span class="comment">// 1.中断引脚配置（引脚的配置和上面闹钟是一致的可以共用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置定时器配置寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StartTimer</span><span class="params">(RTC_Hz hz , u8 count)</span>&#123;</span><br><span class="line">		<span class="comment">//2.1 配置定时器开关.. </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.1 先把控制寄存器读取出来</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.2 把TIE 【第0位】置1</span></span><br><span class="line">		rtc_dat |= <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.3 把TF【第2位】 置0</span></span><br><span class="line">		rtc_dat &amp;= ~<span class="number">0x04</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.4 把配置再写回去！</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">						</span><br><span class="line">		<span class="comment">//2.2 配置定的是什么时间 【需要有两个寄存器来协同完成】...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.2.1 先配置定时器时钟频率，以及启用这种频率 00: 4096，01: 64，10:  1，11: 1/60</span></span><br><span class="line">		rtc_dat = <span class="number">0x80</span> | hz;</span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, TIM1_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.2.2 再配置定时器的时钟周期</span></span><br><span class="line">		rtc_dat = count; <span class="comment">// 结合上面看，就是1s钟触发一次定时操作！</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, TIM2_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StopTimer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 设置控制寄存器里面的TIE 【第0位】 = 0 ， 表示定时器中断无效！</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x01</span>;</span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearTimerFlag</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器来过之后，TF位就会置1，我们要手动置0，否则下一次定时器不来了</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把第2位置0</span></span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x04</span>;</span><br><span class="line"></span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在 PCF8563芯片中，晶振频率为32.768kHz，但我们为什么可以选择 32.768kHz、1024kHz、32Hz、1Hz，他不是只有个 32.768kHz 的晶振么</strong></p>
<p>在 <strong>PCF8563</strong> 实时时钟（RTC）芯片中，虽然它使用了<strong>32.768kHz</strong>的晶振作为基准频率，但通过内部的<strong>分频电路</strong>，可以将该基准频率分频为其他不同的频率输出，如<strong>1024Hz</strong>、<strong>32Hz</strong>、和<strong>1Hz</strong>。这意味着尽管晶振频率固定为32.768kHz，但通过硬件电路的分频机制，PCF8563芯片可以输出不同的时钟频率。</p>
<p>二、<strong>I2C 的总线到底如何配置</strong></p>
<p>I2C（Inter-Integrated Circuit）总线的速度是指主设备和从设备之间数据传输的速率。</p>
<p>公式为：总线速度 &#x3D; <strong>Fosc&#x2F;2&#x2F;(Speed*2+4),0~63</strong></p>
<p><strong>FOSC</strong>：这是系统的主时钟频率（通常是微控制器的晶振频率）。</p>
<p><strong>MSSPEED</strong>：用于控制 I2C 速度的一个寄存器值或配置参数。</p>
<p><strong>2 和 4</strong>：这是 I2C 控制器内部的<strong>定值</strong>，用于分频公式中的基准值。</p>
<blockquote>
<p>MSSPEED 是一个控制分频的参数，用于将主时钟（FOSC）分频成较低的频率，从而得到 I2C 总线所需的时钟频率（SCL）。</p>
<p>通常情况下，I2C 的速度取决于具体应用的要求、设备能力和电路布局。如果连接的设备需要高速传输，则可以选择快速模式或更高的模式；而在低功耗应用中，标准模式的 100 kbit&#x2F;s 速度可能就足够了。</p>
</blockquote>
<p>三、<strong>在开发文档中 MSSPEED 所对应的值为时钟数，那么这个是时钟数是什么？</strong></p>
<p>在开发文档中提到的 “时钟数” 是指 <strong>I2C 总线传输一个数据位所需的时钟周期数</strong>。具体来说，它是 I2C 通信中每发送或接收一位数据时，SCL（串行时钟线）所需要的时钟周期数。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>STC8H</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/STC8H/</url>
    <content><![CDATA[<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>Keil C51程序自动加载了一个名为”STARTUP.A51”的文件，在这个文件里面进行了一系列的初始化操作后进入用户编写的C语言程序入口main函数中，main函数执行完毕后，STARTUP.A51文件后有一句跳转到程序入口main函数的语句，所以会再次进入C语言主程序main函数中执行相关内容。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p><strong>中断</strong>（Interrupt）是一种机制，允许<strong>外部</strong>或<strong>内部</strong>事件在发生时<strong>打断</strong>处理器正在执行的任务，使处理器暂时转移去处理这些事件。</p>
<p>在嵌入式系统中，中断可以是由<strong>硬件外设产生的信号</strong>，也可以是<strong>处理器内部条件触发的事件</strong>。处理器在响应中断时，会暂停当前执行的程序，保存上下文，执行特定的中断服务程序（ISR，Interrupt Service Routine），并在处理完中断后恢复并继续执行原来的任务。</p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p><strong>中断源</strong> 是引发中断事件的硬件或软件模块。常见的中断源包括以下几类：</p>
<ul>
<li><strong>外部中断</strong>：来自外部设备的信号。例如，外部按键、定时器溢出、串口数据接收完成等。</li>
<li><strong>内部中断</strong>：由处理器内部的模块或条件触发的中断。例如，除法错误、非法指令等。</li>
<li><strong>软件中断</strong>：通过软件指令触发的中断（例如，系统调用）。</li>
</ul>
<p><strong>常见的硬件中断源：</strong></p>
<ol>
<li><strong>外部设备</strong>：如键盘、鼠标、按键等，通过物理事件引发中断。</li>
<li><strong>定时器</strong>：定时器溢出（或达到预定计数值）后触发中断，用于定时操作或延时。</li>
<li><strong>串口</strong>：如 UART 接收到数据后触发中断，以通知 MCU 读取数据。</li>
<li><strong>ADC</strong>（模数转换器）：当转换完成时，触发中断通知处理器读取转换结果。</li>
<li><strong>GPIO</strong>（通用输入&#x2F;输出）：输入引脚电平变化（上升沿&#x2F;下降沿）时触发中断。</li>
</ol>
<h3 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h3><p><strong>中断寄存器</strong> 是用于控制、管理和响应中断的寄存器。通过配置这些寄存器，开发者可以启用或屏蔽特定的中断、设置中断的优先级、读取中断标志等。每种处理器架构通常都有不同的中断控制寄存器，以下是常见的中断寄存器类型：</p>
<ol>
<li><strong>中断屏蔽寄存器（Interrupt Mask Register，IMR）</strong>：<ul>
<li>用于启用或禁用特定中断。当某个中断被屏蔽时，即使触发该中断源，也不会导致中断的产生。</li>
<li>通过设置相应的位，可以允许某个中断或屏蔽某个中断。</li>
</ul>
</li>
<li><strong>中断优先级寄存器（Interrupt Priority Register，IPR）</strong>：<ul>
<li>设置不同中断的优先级。通常一个处理器可以处理多个中断，如果多个中断同时触发，处理器会优先响应优先级更高的中断。</li>
</ul>
</li>
<li><strong>中断标志寄存器（Interrupt Flag Register，IFR）</strong>：<ul>
<li>当某个中断源产生中断时，会在中断标志寄存器中置位，用于标识中断的发生。中断服务程序需要清除这个标志位，以避免中断重复触发。</li>
</ul>
</li>
<li><strong>中断控制寄存器（Interrupt Control Register，ICR）</strong>：<ul>
<li>管理中断的使能、模式、边沿检测等功能。通过配置该寄存器，开发者可以控制中断触发的条件，如上升沿、下降沿或电平触发。</li>
</ul>
</li>
</ol>
<h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p><strong>中断函数</strong> 或 <strong>中断服务程序</strong>（ISR，Interrupt Service Routine）是响应中断时执行的代码。当中断发生时，处理器暂停当前执行的任务，跳转到 ISR 处理函数，处理完成后再返回继续执行原来的任务。</p>
<p>中断服务函数通常简洁高效，因为在处理中断的过程中，主程序是暂停的，所以 ISR 的执行时间应尽可能短。</p>
<p><strong>中断函数的特点：</strong></p>
<ul>
<li><strong>无需被显式调用</strong>：中断服务函数由硬件触发，不需要手动调用。</li>
<li><strong>执行时自动保存上下文</strong>：处理器进入中断函数时会自动保存当前上下文（寄存器、程序计数器等），退出时恢复。</li>
<li><strong>需要清除中断标志位</strong>：在某些平台上，中断服务函数需要<strong>手动清除中断标志位</strong>，否则该中断会一直重复触发。</li>
</ul>
<p>中断使系统可以及时响应外部或内部的变化，而不必通过轮询或定时检查的方式，提高了处理效率和系统的实时性。</p>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><p><strong>内部中断</strong> 是由微控制器或<strong>处理器内部</strong>的事件触发的中断，通常与<strong>内部的硬件模块或处理器状态有关</strong>。这类中断<strong>不</strong>会依赖于外部输入信号，而是依靠 MCU 内部的条件或外设的运行情况来触发。</p>
<p><strong>内部中断的触发方式：</strong></p>
<ul>
<li><strong>定时器溢出</strong>：当定时器达到预设值（如定时器计数溢出），会触发定时器中断。</li>
<li><strong>模数转换完成</strong>：在 ADC（模数转换器）完成数据采集并准备好转换结果时，触发中断通知处理器读取数据。</li>
<li><strong>看门狗定时器超时</strong>：看门狗定时器用于检测系统是否正常运行，如果看门狗定时器超时，系统会触发中断或复位。</li>
<li><strong>串口通信完成</strong>：当串口（UART、SPI、I2C）传输或接收数据完成时，触发中断来读取数据或处理错误。</li>
<li><strong>软件触发</strong>：处理器可以通过执行特定指令（如 ARM 架构中的 <code>SWI</code> 指令）来触发一个软件中断。</li>
</ul>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p><strong>外部中断</strong> 是一种<strong>硬件中断机制</strong>，用于处理外部设备或信号源的异步事件。由微控制器&#x2F;处理器<strong>外部</strong>的物理事件或信号触发的中断，通常由外部设备或电路的输入信号变化导致。</p>
<p><strong>外部中断的触发方式：</strong></p>
<ul>
<li><strong>引脚电平变化</strong>：外部设备通过微控制器的 <strong>GPIO</strong> 引脚发送信号。当某个输入引脚的电平发生变化（上升沿、下降沿、或高低电平），触发外部中断。例如，按钮按下或释放会改变引脚的电平状态，触发中断。</li>
<li><strong>外部传感器信号</strong>：一些外部传感器（如红外传感器、加速度计）在检测到环境变化时会向 MCU 发送信号，触发中断。</li>
<li><strong>外部计数器</strong>：某些外部设备会产生计数信号，MCU 可以通过外部中断捕获这些计数值进行处理。</li>
</ul>
<h3 id="STC8H-实现外部中断"><a href="#STC8H-实现外部中断" class="headerlink" title="STC8H 实现外部中断"></a>STC8H 实现外部中断</h3><p>查看数据手册了解中断的触发方式是什么(上升沿、下降沿、或高低电平)</p>
<p><strong>STC8H外部中断表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8Hwaibzhongduanbiao.png" alt="STC8Hwaibzhongduanbiao"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Exti.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** INT配置 ********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exti_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    EXTI_InitTypeDef Exti_Init; <span class="comment">//结构定义</span></span><br><span class="line"></span><br><span class="line">    Exti_Init.EXTI_Mode = EXT_MODE_RiseFall;<span class="comment">//中断模式,   EXT_MODE_RiseFall,EXT_MODE_Fall</span></span><br><span class="line">    Ext_Inilize(EXT_INT0,&amp;Exti_Init); <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    NVIC_INT0_Init(ENABLE,Priority_0); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_int0_call</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 当中断触发时的实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================================================================================</span><br><span class="line"><span class="comment">// Exit_lsr.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> ext_int0_call();</span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: INT0_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: INT0中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT0_ISR_Handler</span> <span class="params">(<span class="type">void</span>)</span> interrupt INT0_VECTOR <span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	ext_int0_call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>串口通信</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="什么是串口"><a href="#什么是串口" class="headerlink" title="什么是串口"></a>什么是串口</h2><p>串口是一个广义的概念，指的是用于<strong>串行通信的接口</strong>。在计算机和嵌入式设备上，串口通信是指<strong>数据一位一位地按顺序传输</strong>，而不是像并行接口那样同时传输多个位。串口通信是许多嵌入式系统和外部设备（如传感器、模块、其他计算机等）之间进行通信的常用方式之一。</p>
<blockquote>
<p>通过物理连接，将串口（如UART串行接口）的引脚与设备的USB端口或其他通信接口相连，以实现设备之间的数据传输或通信。</p>
</blockquote>
<h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><strong>UART</strong> (通用异步收发传输器 Universal Asynchronous Receiver&#x2F;Transmitter)，是一种具体实现<strong>全双工异步串行通信</strong>的<strong>硬件或电路</strong>（它本身也定义了一套简单的<strong>串口通信协议</strong>）。</p>
<p><strong>全双工:</strong> 全双工指的是通信的双方可以同时进行数据的发送和接收，彼此互不干扰。(也就是说需要至少两条线进行通信)</p>
<p><strong>异步:</strong> 数据的发送方和接收方<strong>不需要共享一个全局的时钟信号</strong>。发送方可以在任意时间发送数据，接收方通过特殊的<strong>起始位</strong>和<strong>停止位</strong>来判断数据的开始和结束。（不需要专门的时钟信号线）</p>
<p><strong>串行通信:</strong> 数据通过一条数据线<strong>依次一位一位</strong>的发送。</p>
<p>UART 通过定义起始位、数据位、校验位和停止位等传输格式，来实现数据的串行发送和接收；具有数据传输速度稳定、可靠性高、适用范围广等优点。在嵌入式系统中，串口常用于与外部设备进行通讯，如传感器、液晶显示屏、WiFi 模块、蓝牙模块等。</p>
<h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><strong>引脚连接</strong></p>
<p>UART 通道有两条数据线。每个设备上都有一个 RX 引脚和一个 TX 引脚（RX 用于接收，TX 用于发送）。每个设备的 RX 引脚都连接到另一个设备的 TX 引脚。请注意，没有共享时钟线！这是通用异步接收方发送方的“异步”方面。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTyingjianlianjie.png" alt="UARTyingjianlianjie"></p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p><strong>UART 通信的组成</strong></p>
<p>在 UART中，传输模式为数据包（字符）形式。数据包由起始位、数据帧、奇偶校验位和停止位组成。 </p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTtongxinxieyi.png" alt="UARTtongxinxieyi"></p>
<p><strong>数据的收发过程</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTshujushoufaguocheng.png" alt="UARTshujushoufaguocheng"></p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p><strong>TTL</strong>（Transistor-Transistor Logic）是一种使用双极型晶体管（BJT）来实现逻辑电路的<strong>逻辑电平标准</strong>。其广泛应用于单片机通信中，特别是在串行通信接口（如UART、SPI、I2C）等场景下。</p>
<p>严格来说，TTL不是一种通信协议，而是逻辑电平的定义标准，描述的是<strong>电气属性</strong>。</p>
<p>TTL的电平标准定义了“高”电平和“低”电平的电压范围，通常与电源电压（Vcc）有关。传统 TTL 逻辑电平以 5V 电源供电，常见的电平范围如下：</p>
<ul>
<li><strong>逻辑 1</strong>（高电平）：约为 2.0V 到 5V</li>
<li><strong>逻辑 0</strong>（低电平）：约为 0V 到 0.8V</li>
</ul>
<p>在串口通讯中 TTL 电平用于定义信号的电压范围：TX（发送引脚）、RX（接收引脚）</p>
<p><strong>TX</strong>（Transmit）：发送端通过 TX 引脚发送数据。当发送一个逻辑高电平（1）时，TX引脚输出一个接近 5V 的电压；当发送一个逻辑低电平（0）时，TX 引脚输出接近 0V 的电压。</p>
<p><strong>RX</strong>（Receive）：在接收端，RX 引脚检测输入电压是否在TTL电平的范围内。如果接收到的电压在高电平范围（通常是 2V 以上），则解码为逻辑 1；如果电压在低电平范围（通常是 0.8V 以下），则解码为逻辑 0。</p>
<h3 id="UART-与-TTL"><a href="#UART-与-TTL" class="headerlink" title="UART 与 TTL"></a>UART 与 TTL</h3><p><strong>既然已经有了 UART 或者 TTL 中的一个协议，为什么还需要另外一个？</strong></p>
<p>UART 负责<strong>数据的传输方式</strong>，即如何按位发送和接收数据。而 TTL 则规定了实际传输中<strong>电信号的高低</strong>电平。</p>
<p>它们的关系类似于计算机网络中的 <strong>TCP&#x2F;IP 协议和以太网物理层</strong>的关系。UART 是负责<strong>逻辑层面的数据传输协议</strong>，而 TTL 则是负责<strong>电信号层面的物理传输标准</strong>。没有 UART 协议，TTL 电平的信号就没有办法以串行数据的方式组织和传输。没有 TTL 电平或其他类似的物理层标准，UART 定义的信号则没有适当的电压来表示和传输。</p>
<h3 id="CH340N"><a href="#CH340N" class="headerlink" title="CH340N"></a>CH340N</h3><p><strong>CH340N</strong> 是一款常用的 USB 转 UART（串口）的桥接芯片，用于将 UART 串口数据转换为 USB 接口数据，进而实现串口设备与 USB 设备之间的通信。</p>
<p>CH340N 芯片主要用于将串行 UART 接口转换为 USB 接口，并且在系统中<strong>可以虚拟为标准的串口设备</strong>（COM 口）。这种功能使得我们可以在计算机没有串口的情况下，通过 USB 进行串行通信，方便调试、数据传输等应用。</p>
<p><strong>串口转换芯片的转换电路图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/chuankouzuanUSB.png" alt="chuankouzuanUSB"></p>
<p><strong>引脚图：</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/chuankouzuanUSByuanlitu.png" alt="chuankouzuanUSByuanlitu"></p>
<ul>
<li>D+ D-对应的 USB 口，和 PC 主机连接</li>
<li>P3.1 P3.0 对应的芯片引脚</li>
<li>采用 CH340 将串口和 USB 之间进行转换</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>以下是 STC8H 的芯片引脚介绍图</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8H8K64Uyinjiaotu.png" alt="STC8H8K64Uyinjiaotu"></p>
<p>其中有 4 组 Uart 通讯口:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTtongxinkou.png" alt="UARTtongxinkou"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过串口接受收据并原样返回</p>
<ol>
<li><p>新建项目。新建<code>main.c</code>文件</p>
</li>
<li><p>导入函数库。拷贝以下函数库文件到项目目录：</p>
</li>
<li><p><code>Config.h</code> <code>Type_def.h</code></p>
</li>
<li><p><code>GPIO.h``GPIO.c</code></p>
</li>
<li><p><code>Delay.h``Delay.c</code></p>
</li>
<li><p><code>UART.h``UART.c``UART_Isr.c</code></p>
</li>
<li><p><code>NVIC.c</code> <code>NVIC.h</code></p>
</li>
<li><p><code>Switch.h</code></p>
</li>
</ol>
<h4 id="配置代码"><a href="#配置代码" class="headerlink" title="配置代码"></a>配置代码</h4><h5 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************* IO配置函数 *******************/</span></span><br><span class="line"><span class="type">void</span>	<span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_Init; <span class="comment">//结构定义  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定IO的工作模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    <span class="comment">//指定要初始化的IO引脚, Px0, Px1</span></span><br><span class="line">    GPIO_Init.Pin  = GPIO_Pin_0 | GPIO_Pin_1; </span><br><span class="line">       </span><br><span class="line">    GPIO_Inilize(GPIO_P3,&amp;GPIO_Init);	<span class="comment">//初始P3端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UART-1"><a href="#UART-1" class="headerlink" title="UART"></a>UART</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    COMx_InitDefine UART_Init; <span class="comment">//结构定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工作模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    <span class="comment">// SCON = (SCON &amp; 0x3f) | COMx-&gt;UART_Mode; SCON 串口 1 的控制寄存器 </span></span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    <span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;			</span><br><span class="line">    UART_Init.UART_BaudRate  = <span class="number">115200ul</span>; <span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    <span class="comment">// 能够通过 UART 的 RX 引脚接收从其他设备发送过来的数据。</span></span><br><span class="line">    UART_Init.UART_RxEnable  = ENABLE; <span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE; <span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化串口: UART1,UART2,UART3,UART4</span></span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init); </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//UART1 中断初始化</span></span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定为UART1通信的TX（发送）和RX（接收）引脚到底是那一对</span></span><br><span class="line">    <span class="comment">//UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在单片机开发中，配置了UART（UART1_SW(UART1_SW_P30_P31);）后，通常还需要配置GPIO（GPIO_Pin_0 | GPIO_Pin_1）。这是因为UART本身只是一种通信协议和硬件外设模块，而 GPIO 管脚的配置则决定了UART功能的实际物理引脚映射和特性。</p>
</blockquote>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">on_uart1_recv</span><span class="params">()</span> &#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="comment">// RX_Cnt收到的数据个数（字节u8 - unsigned char）</span></span><br><span class="line">    <span class="comment">// 将收到的数据, 按字节逐个循环</span></span><br><span class="line">    <span class="comment">// u8 RX1_Buffer[120]</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;COM1.RX_Cnt; i++) &#123;</span><br><span class="line">        u8 dat = RX1_Buffer[i]; <span class="comment">//  1 1 1 1  0 0 0 0 -&gt; 0xF0</span></span><br><span class="line">        TX1_write2buff(dat);	<span class="comment">//收到的数据原样返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">开启串口调试，接收数据，把收到的数据原样返回</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化GPIO、UART</span></span><br><span class="line">    GPIO_config();</span><br><span class="line">    UART_config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启中断（全局）必须要写！</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个字节</span></span><br><span class="line">    TX1_write2buff(<span class="number">0x23</span>);</span><br><span class="line">	<span class="comment">// 通过PrintString1输出字符串</span></span><br><span class="line">    PrintString1(<span class="string">&quot;STC8H8K64U UART1 Test Programme!\r\n&quot;</span>);	<span class="comment">//UART1发送一个字符串</span></span><br><span class="line">    <span class="comment">// 通过printf输出字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STC8H8K64U UART1 Test Programme!\r\n&quot;</span>);	<span class="comment">//UART1发送一个字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 超时计数</span></span><br><span class="line">        <span class="comment">// 一旦收到了一个字节数据，RX_TimeOut会初始化一个值（例如：5）</span></span><br><span class="line">        <span class="keyword">if</span>((COM1.RX_TimeOut &gt; <span class="number">0</span>) &amp;&amp; (COM1.RX_TimeOut == <span class="number">0</span>)) &#123;            </span><br><span class="line">            <span class="keyword">if</span>(COM1.RX_Cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 收到数据了，on_uart1_recv();</span></span><br><span class="line">                on_uart1_recv();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完数据，将数据个数清零</span></span><br><span class="line">            COM1.RX_Cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 注意这里delay代码的位置，属于while</span></span><br><span class="line">        delay_ms(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>UART_Init.UART_BRT_Use = BRT_Timer1;</code> 这一句的作用是<strong>指定用哪个定时器来生成波特率</strong>，即通过哪个定时器为串口通信提供时钟信号。</p>
<p>在单片机中，多个定时器通常可以执行不同的任务，比如控制 PWM 信号、生成定时中断或产生串口波特率。如果某个定时器被用于其他任务，就需要选择另一个定时器来生成波特率。</p>
</blockquote>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>查看数据手册 UART 通信涉及中断，所以需要配置中断(开启中断)；</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用 STC-ISP 调试工具进行调试。切换好串口助手，选择正确的串口，设置和代码中相同的波特率。</p>
<p>通过发送区进行数据发送，通过接收区观察接收内容。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>为什么配置或者说使用 UART 时要指定定时器或者波特率发生器？</strong></p>
<p>在使用 <strong>UART</strong>（通用异步收发器）进行串行通信时，<strong>定时器</strong>或者<strong>波特率发生器</strong>的配置是必不可少的，因为串行通信是<strong>异步通信</strong>，没有时钟信号来同步发送端和接收端的数据传输。因此，波特率发生器和定时器的作用是保证双方能够在相同的时间窗口内正确地发送和接收数据。</p>
<blockquote>
<p><strong>异步通信</strong>（Asynchronous Communication）是一种数据传输方式，其中<strong>发送端和接收端之间没有共享的时钟信号</strong>，即没有全局时钟来同步数据的发送和接收。这种方式允许设备在不同的时间开始传输数据，但仍然能够通过某种机制正确解码接收到的数据。</p>
</blockquote>
<p>二、<strong>为什么要指定波特率?</strong></p>
<p>UART通信是异步的，这意味着通信双方没有共享的时钟信号。<strong>在没有时钟同步的情况下，双方必须依靠波特率来控制数据传输的速率</strong>。如果发送端和接收端的波特率不一致，数据将无法正确解码，导致通信错误。因此，指定波特率为了<strong>确保数据能够在预期的速率下传输和接收</strong>。</p>
<p>三、<strong>URAT 中使用了 定时器，但我们却没有配置定时器却能使用为什么？</strong></p>
<p>因为他内部自己配置了对于定时器的一系列操作；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(COMx-&gt;UART_BRT_Use == BRT_Timer1) &#123;       </span><br><span class="line">	TR1 = <span class="number">0</span>;</span><br><span class="line">	AUXR &amp;= ~<span class="number">0x01</span>;		<span class="comment">//S1 BRT Use Timer1;</span></span><br><span class="line">	TMOD &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);	<span class="comment">//Timer1 set As Timer</span></span><br><span class="line">	TMOD &amp;= ~<span class="number">0x30</span>;		<span class="comment">//Timer1_16bitAutoReload;</span></span><br><span class="line">	AUXR |=  (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);	<span class="comment">//Timer1 set as 1T mode</span></span><br><span class="line">	TH1 = (u8)(j&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	TL1 = (u8)j;</span><br><span class="line">	ET1 = <span class="number">0</span>;			<span class="comment">//禁止中断</span></span><br><span class="line">	TMOD &amp;= ~<span class="number">0x40</span>;		<span class="comment">//定时</span></span><br><span class="line">	INTCLKO &amp;= ~<span class="number">0x02</span>;	<span class="comment">//不输出时钟</span></span><br><span class="line">	TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、<strong>多机通信指的是什么？</strong></p>
<p>UART（Universal Asynchronous  Receiver&#x2F;Transmitter，通用异步收发器）串口通信中的多机通信，指的是一个 UART 设备（通常称为主设备或主机）同时与多个其他 UART 设备（称为从设备或从机）进行通信的模式。这种通信模式在需要集中控制多个设备或进行数据广播的场景中非常有用。</p>
<p>五、<strong>波特率发生器怎么选：</strong></p>
<p>看数据手册：比如 UART4 可以选择定时器 2、定时器 4，UART4 只能使用定时器 2 等。</p>
<p>这里的波特率发生器就是定时器，但我们只需选择不需要配置，因为它默认会给我们进行配置 ；</p>
<p>六、<strong>为什么 MCU 可以发送汉字而不可以接收汉字</strong></p>
<p>如果 PC 端读取到一个字节的高位在有效范围，接下来的字节会被解释为同一字符的一部分，而不是独立的字节。相反，如果接收到的字节在 ASCII 范围内（0x00 到 0x7F），接收方将其视为普通字符。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>数码管</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E6%95%B0%E7%A0%81%E7%AE%A1/</url>
    <content><![CDATA[<p>数码管是一种常用于嵌入式开发中的<strong>显示设备</strong>，能够显示数字或特定字符。它以多个 LED 段组成的形式显示信息，广泛应用于电子设备的数字显示，如电子钟、温度计、计数器等。</p>
<p>数码管通常由 <strong>7 段（七段显示器）</strong> 或 <strong>8 段（包括小数点）</strong> 的 LED 组成，每个段对应一个 LED。当相应段被点亮时，会形成数字0-9的形状。</p>
<p><strong>共阴与共阳</strong></p>
<p>数码管的驱动方式主要有两种：共阳极和共阴极。</p>
<ul>
<li><strong>共阳极</strong>：所有LED段的阳极（正极）连接在一起，通过控制各个LED段的阴极（负极）来控制其亮灭。</li>
<li><strong>共阴极</strong>：所有LED段的阴极（负极）连接在一起，通过控制各个LED段的阳极（正极）来控制其亮灭。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/gongyingongyangtu.png" alt="gongyingongyangtu"></p>
<blockquote>
<p>举例：</p>
<p>对于一个共阴数码管，要点亮某一段，比如“a段”，需要将“a段”的阳极引脚置高（电压为正），而阴极已经连接到地，所以电流会通过LED流向阴极，从而点亮LED。</p>
<p>对于一个共阳数码管，要点亮某一段，比如“a段”，需要将“a段”的阴极引脚置低（接地），而阳极已经连接到正电压（<code>+5V</code>），这样电流就会从阳极流向阴极，通过LED，从而点亮LED。</p>
</blockquote>
<p><strong>四位数码管原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/siweishumaguanyuanlitu.png" alt="siweishumaguanyuanlitu"></p>
<h2 id="74HC595位移寄存器"><a href="#74HC595位移寄存器" class="headerlink" title="74HC595位移寄存器"></a>74HC595位移寄存器</h2><p>为了解决数码管端口复用的问题引入了 74HC595 位移寄存器</p>
<p>74HC595 是一个 <strong>8 位移位寄存器</strong>，具备 <strong>串行数据输入</strong>（逐位输入）和 <strong>并行数据输出</strong>（一次输出 8 位）的功能。它可以通过控制输入的时钟脉冲将串行输入的数据位依次移入寄存器中，然后一次性输出 8 位数据。</p>
<blockquote>
<p>也是一个将二进制数据转换为高低电平的一个工具。</p>
</blockquote>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595yinjiaotu.png" alt="74HC595yinjiaotu"></p>
<p>74HC595 引脚：</p>
<ol>
<li>LATCH_CLOCK:  锁存时钟</li>
<li>SHIFT_CLOCK: 移位时钟</li>
<li>A:  数据输入信号管脚</li>
<li>QA~QH: 将二进制数据信号转化为高低电平输出给数码管</li>
<li>SQH: 串行数据输出管脚</li>
</ol>
<p><strong>管脚功能定义</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595guanjiaodingyi.png" alt="74HC595guanjiaodingyi"></p>
<p><strong>真值表</strong>（“↑”表示上升沿；“↓”表示下降沿）</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595zhenzhibiao.png" alt="74HC595zhenzhibiao"></p>
<p>真值表解释：</p>
<ol>
<li><strong>X</strong>：表示该引脚的状态无关，处于任意状态（高电平或低电平都无影响）。</li>
<li><strong>↑</strong>：表示上升沿，即时钟从低电平变为高电平的瞬间。</li>
<li><strong>SER</strong>：串行数据输入</li>
<li><strong>SRCLK</strong>：移位寄存器时钟</li>
<li><strong>SRCLR</strong>：移位寄存器清零</li>
<li><strong>RCLK</strong>：存储寄存器时钟信号</li>
<li><strong>OE</strong>：输出使能信号</li>
</ol>
<p>根据表中的不同情况，移位寄存器的行为如下：</p>
<ul>
<li><strong>X X X X H</strong>：当 <code>OE</code> 为高电平时，QA 到 QH 输出被禁用（输出处于高阻态）。</li>
<li><strong>X X X X L</strong>：当 <code>OE</code> 为低电平时，QA 到 QH 输出被启用，输出寄存器的数据可以通过并行输出引脚输出。</li>
<li><strong>X X L X X</strong>：当 <code>SRCLR</code> 为低电平时，移位寄存器的数据被清零，所有数据位变为 0。</li>
<li><strong>L ↑ H X X</strong>：当 <code>SER</code> 为低电平且 <code>SRCLK</code> 时钟上升沿到来时，移位寄存器的第一级存储数据变为 0，其它级别的数据顺序右移。</li>
<li><strong>H ↑ H X X</strong>：当 <code>SER</code> 为高电平且 <code>SRCLK</code> 时钟上升沿到来时，移位寄存器的第一级存储数据变为 1，其它级别的数据顺序右移。</li>
<li><strong>X X X ↑ X</strong>：当 <code>RCLK</code> 时钟上升沿到来时，移位寄存器中的数据存储到输出寄存器，并更新输出。</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>74HC595 原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595yuanlitu.png" alt="74HC595yuanlitu"></p>
<p><strong>数据输入与移位过程</strong></p>
<ul>
<li><strong>A（数据输入）</strong>：通过该引脚，74HC595 可以接收<strong>一个串行数据</strong>流。</li>
<li><strong>SHIFT_CLOCK（移位时钟）</strong>：每个时钟上升沿时，串行数据通过 A 进入移位寄存器，寄存器中已有的数据则向高位位移。</li>
<li><strong>LATCH_CLOCK（存储时钟&#x2F;锁存时钟）</strong>：该信号用于控制何时将移位寄存器中的内容输出到并行引脚 <code>QA</code> 到 <code>QH</code>。通常移位完成后，上升沿时触发锁存操作，将寄存器中的数据输出到 Qx 引脚(Qx 泛指 QA~QH 中任意一个)。</li>
</ul>
<p><strong>清除与输出控制</strong></p>
<ul>
<li><strong>RESET（复位引脚）</strong>：当该引脚为低电平时，移位寄存器中的所有数据将被清零。</li>
<li><strong>OE（输出使能）</strong>：该引脚为低电平时，输出引脚 <code>QA</code> 到 <code>QH</code> 才有效；为高电平时，输出引脚为高阻态（等效于禁用输出）。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><strong>SQ<sub>H</sub>（串行数据输出端）</strong>：用于<strong>级联</strong>多个 74HC595 芯片，使得可以串联多个寄存器扩展更多的 IO 端口。第一个寄存器中的数据将通过这个引脚输出串行输入到下一个 74HC595 的串行数据输入端。</li>
</ul>
<p><strong>串联多个 74HC595</strong></p>
<p>如果要控制超过 8 个输出，可以将多个 74HC595 级联。级联时，第一个 74HC595 的 <code>SQH</code>（串行输出引脚）连接到下一个 74HC595 的 <code>A</code>（数据输入引脚），以此类推。这样可以通过同一个数据和时钟输入同时控制多个 74HC595，实现扩展更多的并行输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595cuanlian.png" alt="74HC595cuanlian"></p>
<p>当 U1 八个被填满后，在传入数据就会通过 SQH 引脚被挤到 U2 中的 QA 然后依次向高位位移。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>以 74HC595 为例</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595STC8Hyuanlitu.png" alt="74HC595STC8Hyuanlitu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>八个数码管分别亮7、7、、7、7、7、7、7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NIXIE.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意，此处要反着来，因为共阳时低电平导通，最低为代表 a 段数码管</span></span><br><span class="line">    u8 dat = <span class="number">0xF8</span>; <span class="comment">// 要显示的数字 7 1111 1000</span></span><br><span class="line">    u8 num = <span class="number">0xFB</span>; <span class="comment">// 要显示哪几个数码管 1111 1011  </span></span><br><span class="line">    </span><br><span class="line">    NIXIE_Init();</span><br><span class="line">    </span><br><span class="line">    NIXIE_shwo(dat, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">====================================================================================</span><br><span class="line"><span class="comment">// NIXIE.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NIXIE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NIXIE_H__</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_DI  P44  <span class="comment">// 数据输入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_SCK P42  <span class="comment">// 移位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_RCK P43  <span class="comment">// 锁存寄存器</span></span></span><br><span class="line"><span class="comment">// 获取 byte 的第 pso 位    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_BIT_VAL(byte, pos)	(byte &amp; (1 &lt;&lt; pos))    </span></span><br><span class="line"><span class="comment">// 空操作    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP_TIME() NOP2()</span></span><br><span class="line"><span class="comment">// 锁存操作 上升沿有效</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCK_ACTION() 		\</span></span><br><span class="line"><span class="meta">		NIXIE_RCK = 0;		\</span></span><br><span class="line"><span class="meta">		NOP_TIME();			\</span></span><br><span class="line"><span class="meta">		NIXIE_RCK = 1;		\</span></span><br><span class="line"><span class="meta">		NOP_TIME();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> NIXIE_Init();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示操作</span></span><br><span class="line"><span class="comment">// dat 显示的数据，num 要显示那几个数码管</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_show</span><span class="params">(u8 dat, u8 num)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">======================================================================================</span><br><span class="line"><span class="comment">// NIXIE.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NIXIE.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> NIXIE_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    GPIO_InitTypeDef	GPIO_Init; <span class="comment">// 结构定义</span></span><br><span class="line">    <span class="comment">// 指定要初始化的IO,</span></span><br><span class="line">	GPIO_Init.Pin  = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;	</span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P4, &amp;GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NIXIE_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NIXIE_Write1Bit</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        NIXIE_DI = GET_BIT_VAL(dat, i);</span><br><span class="line">		<span class="comment">// 寄存器的移位操作</span></span><br><span class="line">		NIXIE_SCK = <span class="number">0</span>;</span><br><span class="line">		NOP_TIME(); <span class="comment">// 休眠一会儿</span></span><br><span class="line">		NIXIE_SCK = <span class="number">1</span>;</span><br><span class="line">		NOP_TIME(); <span class="comment">// 休眠一会儿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_show</span><span class="params">(u8 dat, u8 num)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示 7.</span></span><br><span class="line">	<span class="comment">// 0111 1000</span></span><br><span class="line">	<span class="comment">// 先发字母位 (控制显示的内容)	// 0点亮</span></span><br><span class="line">	<span class="comment">// 8bit，先发出去的会作为高位</span></span><br><span class="line">	NIXIE_out(dat);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 0,1,2,3....7</span></span><br><span class="line">	<span class="comment">// 再发数字位 （控制显示哪几个） // 只要不是0，就是高电平</span></span><br><span class="line">	<span class="comment">// 1111 1011</span></span><br><span class="line">	<span class="comment">// 7.7.空7. 7.7.7.7.  -------------------与二级制是反向</span></span><br><span class="line">	<span class="comment">// 8bit，先发出去的会作为高位</span></span><br><span class="line">	NIXIE_out(num);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 锁存操作</span></span><br><span class="line">	RCK_ACTION();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>定时器（Timer）是一种嵌入式系统中常见的<strong>外设</strong>（是<strong>集成在芯片内部</strong>的一组功能模块），通常由一个晶体<strong>振荡器</strong>提供时钟信号，可以计时一定的时间后执行相应的操作；它是基于<strong>硬件计数器</strong>的一种机制，通常集成在微控制器（MCU）或处理器中；定时器的基本功能是<strong>精确测量时间间隔</strong>，或者<strong>根据时间周期触发特定任务</strong>。</p>
<blockquote>
<p>在嵌入式系统中，被称为<strong>外设</strong>（Peripheral）是因为它相对于<strong>中央处理器（CPU）的核心执行逻辑来说，是一种辅助功能模块</strong>。</p>
</blockquote>
<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><ul>
<li><strong>时钟源</strong>：定时器依赖于外部时钟或内部时钟源（通常是微控制器的主时钟或分频时钟）来进行计时。</li>
<li><strong>计数器</strong>：定时器内部有一个计数器，它根据时钟源的频率进行递增或递减。计数器的大小可以是 8 位、16 位、32 位或其他大小，决定了它的计数范围。</li>
<li><strong>中断机制</strong>：定时器通常具有中断功能，当计数器达到设定的值或溢出时，定时器可以触发中断，通知处理器执行特定任务。</li>
</ul>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>嵌入式定时器一般有几种常见的工作模式：</p>
<ol>
<li><strong>计时&#x2F;定时模式（Timer Mode）</strong>：<ul>
<li>定时器以固定的频率计数，计数器的值随时间递增。当计数器<strong>达到预设值（或溢出）</strong>时，产生一个定时中断。这种模式用于周期性任务，例如定时任务、PWM 信号的产生、或周期性事件的触发。</li>
</ul>
</li>
<li><strong>计数模式（Counter Mode）</strong>：<ul>
<li>定时器可以用作事件计数器，它在某个外部信号（如 GPIO 脉冲输入）发生时进行计数。每检测到一个外部脉冲信号，计数器递增一次。这种模式适合<strong>对外部事件进行计数</strong>，比如脉冲信号的测量、转速计数等。</li>
</ul>
</li>
<li><strong>捕获模式（Capture Mode）</strong>：<ul>
<li>定时器在捕获模式下可以记录某个输入信号的变化时刻。比如，当一个外部信号到达时，定时器将当前的计数器值保存起来，从而记录信号发生时的精确时间。捕获模式常用于脉宽测量、外部信号的精确计时等。</li>
</ul>
</li>
<li><strong>比较模式（Compare Mode）</strong>：<ul>
<li>定时器在比较模式下，当计数器的值与预设的比较值相等时，定时器可以产生中断或者输出一个信号。该模式常用于生成 PWM（脉宽调制）信号或周期性输出信号。</li>
</ul>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>定时器启动后，根据配置的模式和速率进行计数。在定时模式下，定时器对内部系统时钟进行计数；在计数模式下，定时器对外部引脚输入的脉冲进行计数。</p>
<p>当定时器的计数值达到其容量上限（如16位定时器的上限为65535）时，会发生溢出。此时，定时器的溢出标志位（如TF0、TF1等）会被硬件置位，并向CPU发出中断请求（如果中断被允许）。</p>
<p>如果CPU允许中断，并且没有其他更高优先级的中断正在处理，那么CPU会响应定时器的中断请求，并跳转到对应的中断服务程序执行。</p>
<blockquote>
<p>单片机复位后，程序计数器(PC)从 0000H 单元开始执行程序。另外中断服务程序的入口地址(又称中断向量)也位于程序存储器单元。在程序存储器中，每个中断都有一个固定的入口地址，当中断发生并得到响应后，单片机就会自动跳转到相应的中断入口地址去执行程序。外部中断 0(INTO) 的中断服务程序的入口地址是 0003H，定时器&#x2F;计数器 0(TIMERO) 中断服务程序的入口地址是 000BH，外部中断 1(INT1) 的中断服务程序的入口地址是 0013H，定时器&#x2F;计数器 1(TIMER1) 的中断服务程序的入口地址是 001BH 等。</p>
<p>在 51 系列单片机中这些地址由 keil 编译器进行维护；</p>
</blockquote>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断被激活时，硬件会尝试跳转到我们提供的中断处理函数。而硬件怎么找到我们的中断处理函数呢？每种架构的 CPU 都会有一个固定的中断向量表，中断向量表按照中断号顺序存储中断处理函数的函数地址，当发生中断时，硬件会顺序查找对应的函数地址并跳转。</p>
<p>当程序被编译时，编译器会识别出中断服务函数的声明，并根据中断号在生成的代码中将中断服务函数的入口地址放置在中断向量表中对应的位置。中断向量表是一个特殊的存储区域，它记录了所有中断服务函数的入口地址，以便在中断发生时能够快速找到并跳转到相应的中断服务函数执行。</p>
<p>那么咱们写代码时在函数后加 interrupt n；Keil 编译后会将此函数首地址放入对应的寄存器中(<strong>中断向量</strong>)，请问这个中断号与中断向量的对应表在keil 中什么地方配置的呢，或者是在代码中如何实现的呢？这是由 keil 编译器所维护的一组对应关系表，写interrupt n，keil 会自动在中断向量处插入跳转到该函数入口点的 LJMP 单片机中断被允许且发生中断请求事件，CPU由硬件向PC写入中断向量实现中断跳转</p>
<blockquote>
<p>LJMP是一种远跳转指令，用于在保护模式或实地址模式下跳转到不同的代码段执行程序。</p>
<p>中断向量不是寄存器，是 FLASH 中的 code 区域靠前的一部分</p>
</blockquote>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H内置了5个16位定时器：T0，T1，T2，T3，T4；</p>
<p><strong>中断向量表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8Hzhongduanxiangliangbiao.png" alt="STC8Hzhongduanxiangliangbiao"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用定时器，控制板载LED高低电平输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	GPIO_InitTypeDef GPIO_Init; <span class="comment">//结构定义</span></span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_3; <span class="comment">//指定要初始化的IO,</span></span><br><span class="line">    <span class="comment">//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P5, &amp;GPIO_InitStructure);	<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	TIM_InitTypeDef Timer_Init <span class="comment">//结构定义</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定时器0做16位自动重装, 中断频率为100000HZ，中断函数从P6.7取反输出50KHZ方波信号.</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">//指定工作模式,TIM_16BitAutoReload, TIM_16Bit, TIM_8BitAutoReload, TIM_16BitAutoReloadNoMask        </span></span><br><span class="line">	Timer_Init.TIM_Mode = TIM_16BitAutoReload;	</span><br><span class="line">    <span class="comment">//指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext</span></span><br><span class="line">	Timer_Init.TIM_ClkSource = TIM_CLOCK_1T;	</span><br><span class="line">    <span class="comment">//是否输出高速脉冲, ENABLE或DISABLE，如果配置ENABLE，则P3.5端口会同步输出时钟脉冲</span></span><br><span class="line">	Timer_Init.TIM_ClkOut = DISABLE;		</span><br><span class="line">    <span class="comment">//初值,指定Timer频率 1000hz (每秒执行1000次，每次1ms（周期））</span></span><br><span class="line">    <span class="comment">//不要小于367hz (2.7ms周期)</span></span><br><span class="line">	<span class="comment">//不要大于1 000 000hz 一百万 （1us周期)</span></span><br><span class="line">	Timer_Init.TIM_Value     = <span class="number">65536UL</span> - (MAIN_Fosc / <span class="number">1000UL</span>);	</span><br><span class="line">	<span class="comment">//是否初始化后启动定时器, ENABLE或DISABLE																	</span></span><br><span class="line">	Timer_Init.TIM_Run       = ENABLE;	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化Timer0 Timer0,Timer1,Timer2,Timer3,Timer4</span></span><br><span class="line">	Timer_Inilize(Timer0,&amp;TIM_InitStructure);	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">	NVIC_Timer0_Init(ENABLE,Priority_0);			</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	GPIO_config();</span><br><span class="line">	TIMER_config();</span><br><span class="line">	<span class="comment">// 开启全局中断</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	P53 = <span class="number">0</span>;		<span class="comment">// 熄灯</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================================================= </span><br><span class="line"><span class="comment">// Timer_lsr.c</span></span><br><span class="line"><span class="comment">// 函数: Timer0_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: Timer0中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> Timer0_ISR_Handler (<span class="type">void</span>) interrupt TMR0_VECTOR <span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加用户代码</span></span><br><span class="line">   P53 = ~P53;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>工作模式</strong></p>
<p>工作模式指的是计数方式，timer的计数是在主频计数的基础上，来进行数数的。timer有16位的计数器，通过计数器来计数来确定定时器运行的时长，在关键位置触发定时中断。</p>
<ul>
<li><strong>16位自动重装载模式：</strong>可以被设置成定时或者计数两种模式，每当定时器溢出时就会触发中断或者输出信号。</li>
<li>16位不可重装载模式：计数值达到设定值后，定时器就会停止计数，需要重新初始化才能继续计数。</li>
<li>8位自动重装载模式：8位计数器溢出时触发中断或输出信号。</li>
<li>不可屏蔽中断的16位自动重装载模式：16位计数器溢出时触发中断或输出信号，并且可以通过软件或硬件方式清除定时器计数器的值。</li>
</ul>
<p>通常使用<strong>16位自动重装载模式.</strong></p>
<p><strong>时钟源</strong></p>
<p>可配置的是重要有两个：说白了就是如何去数数</p>
<ul>
<li>1T: 跟随主频：每个时钟频率加一，速度是传统 8051 单片机的 12 倍</li>
<li>12T: 进行12分频：每 12 个时钟频率加一，与传统 8051 单片机相同</li>
</ul>
<p><strong>初值</strong></p>
<p>从初值开始数数，数多久触发一次中断；</p>
<p><strong>中断使能</strong></p>
<p>中断配置是为了打开中断开关的，从而可以触发中断回调的，如果不配置，将无法触发中断回调。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在定时器计算中为什么是 65536ul 减一，而不是 16 位的最大值 65535 减一</strong></p>
<p><strong>定时器的溢出原理</strong>：定时器计数器的工作原理是从一个预设的初始值开始，递增至最大计数值后发生溢出，随即重新开始从 0 计数。对于一个 16 位定时器，其最大计数范围是 0 到 65535，共有 65536 个可能的计数值。</p>
<p>在设置定时器预加载值时，选择 65536 作为基准是基于以下原因：</p>
<ul>
<li><strong>从 0 计数</strong>：定时器从 0 开始计数，<strong>达到预设值后回到 0</strong>。如果定时器从预设值开始计数，并且计数到 65535 之后发生溢出回到 0，则整个周期实际上包含了 65536 个计数步骤。</li>
<li><strong>完整周期</strong>：使用 65536 作为基数，允许定时器完整地经历从预设值到 65535 的所有计数状态，确保溢出时计数周期的完整性。</li>
</ul>
<blockquote>
<p>从 0 开始计数到达 16 位计数器的最大值 65535 之后发生溢出回到 0 ，然后在开始重新计数；也就是说加到 65535 之后还要再加一，才是一个完整的周期，也就是 65536 个数；</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>热敏电阻</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<p>NTC（Negative Temperature Coefficient）即负温度系数，是一种描述材料或元器件<strong>电阻值随温度变化</strong>的特性。具体来说，NTC指的是那些电阻值随温度<strong>升高</strong>而<strong>降低</strong>的材料或元器件。</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/remdianzuyuanlitu.png" alt="remdianzuyuanlitu"></p>
<blockquote>
<p>R6 上标注的 <strong>10kΩ</strong> 通常是指 <strong>NTC 热敏电阻在某个特定温度下（25℃）的标称电阻值</strong></p>
</blockquote>
<h2 id="计算热敏电阻位置的电压值"><a href="#计算热敏电阻位置的电压值" class="headerlink" title="计算热敏电阻位置的电压值"></a>计算热敏电阻位置的电压值</h2><p><strong>电容器两端的电压</strong>与谁并联，就跟谁电压相等。</p>
<p>以上图为例：</p>
<p>vcc 处电压为 3.3V，NTC 处的电压为 ntc_V，那么 R20 处的电压就是 (3.3 - ntc_v)V，那么流过 R20 的电流 I &#x3D;  (3.3 - ntc_v) &#x2F; 10</p>
<p>假设 ntc-v 为 1.3 则 2 &#x2F; 10 000 &#x3D; 0.0002 安，也就是说 经过 R20 的电流为 0.0002 安</p>
<p>同理，热敏电阻的电流 I &#x3D; (ntc_V - 0) &#x2F; 热敏电阻</p>
<p>又因为串联电路电流处处相等：(ntc_V  &#x2F; 热敏电阻) &#x3D;  (3.3 - ntc_v) &#x2F; 10</p>
<p>所以：热敏电阻(KΩ) &#x3D; ntc_V  * 10 &#x2F; （3.3 - ntc_V  ）</p>
<p><strong>电路中明明有一条路是电容的支路，但为什么还是按照串联计算呢</strong></p>
<p>电容器在上电瞬间的行为表现为短路，因为当电容器刚刚连接到电源时，两个板之间的电势差为零，而电势的变化速度非常快。由于电容器的特性，当电压为零时，根据欧姆定律，电流会变为无限大，因此形成了短路的表象。</p>
<p>然而，这种短路现象并不会持续很久，电容器内的电荷和电势会很快建立起来，电流会逐渐降低直至稳定。那么此时就会形成断路的情况，那么也就可以当作这条路不存在了。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NTC.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	__NTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数声明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 热敏电阻初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应温度的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NTC_GetTemperature</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">// NTC.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NTC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 热敏电阻与温度对照表</span></span><br><span class="line">u16 code temp_table[]= &#123;</span><br><span class="line">	<span class="number">58354</span>, <span class="comment">// -55</span></span><br><span class="line">	<span class="number">55464</span>, <span class="comment">// -54</span></span><br><span class="line">	<span class="number">52698</span>, <span class="comment">// -53</span></span><br><span class="line">	<span class="number">50048</span>, <span class="comment">// -52</span></span><br><span class="line">	<span class="number">47515</span>, <span class="comment">// -51</span></span><br><span class="line">	<span class="number">45097</span>, <span class="comment">// -50</span></span><br><span class="line">	<span class="number">42789</span>, <span class="comment">// -49</span></span><br><span class="line">	<span class="number">40589</span>, <span class="comment">// -48</span></span><br><span class="line">	<span class="number">38492</span>, <span class="comment">// -47</span></span><br><span class="line">	<span class="number">36496</span>, <span class="comment">// -46</span></span><br><span class="line">	<span class="number">34597</span>, <span class="comment">// -45</span></span><br><span class="line">	<span class="number">32791</span>, <span class="comment">// -44</span></span><br><span class="line">	<span class="number">31075</span>, <span class="comment">// -43</span></span><br><span class="line">	<span class="number">29444</span>, <span class="comment">// -42</span></span><br><span class="line">	<span class="number">27896</span>, <span class="comment">// -41</span></span><br><span class="line">	<span class="number">26427</span>, <span class="comment">// -40</span></span><br><span class="line">	<span class="number">25034</span>, <span class="comment">// -39</span></span><br><span class="line">	<span class="number">23713</span>, <span class="comment">// -38</span></span><br><span class="line">	<span class="number">22460</span>, <span class="comment">// -37</span></span><br><span class="line">	<span class="number">21273</span>, <span class="comment">// -36</span></span><br><span class="line">	<span class="number">20148</span>, <span class="comment">// -35</span></span><br><span class="line">	<span class="number">19083</span>, <span class="comment">// -34</span></span><br><span class="line">	<span class="number">18075</span>, <span class="comment">// -33</span></span><br><span class="line">	<span class="number">17120</span>, <span class="comment">// -32</span></span><br><span class="line">	<span class="number">16216</span>, <span class="comment">// -31</span></span><br><span class="line">	<span class="number">15361</span>, <span class="comment">// -30</span></span><br><span class="line">	<span class="number">14551</span>, <span class="comment">// -29</span></span><br><span class="line">	<span class="number">13785</span>, <span class="comment">// -28</span></span><br><span class="line">	<span class="number">13061</span>, <span class="comment">// -27</span></span><br><span class="line">	<span class="number">12376</span>, <span class="comment">// -26</span></span><br><span class="line">	<span class="number">11728</span>, <span class="comment">// -25</span></span><br><span class="line">	<span class="number">11114</span>, <span class="comment">// -24</span></span><br><span class="line">	<span class="number">10535</span>, <span class="comment">// -23</span></span><br><span class="line">	<span class="number">9986</span>,  <span class="comment">// -22</span></span><br><span class="line">	<span class="number">9468</span>,  <span class="comment">// -21</span></span><br><span class="line">	<span class="number">8977</span>,  <span class="comment">// -20</span></span><br><span class="line">	<span class="number">8513</span>,  <span class="comment">// -19</span></span><br><span class="line">	<span class="number">8075</span>,  <span class="comment">// -18</span></span><br><span class="line">	<span class="number">7660</span>,  <span class="comment">// -17</span></span><br><span class="line">	<span class="number">7267</span>,  <span class="comment">// -16</span></span><br><span class="line">	<span class="number">6896</span>,  <span class="comment">// -15</span></span><br><span class="line">	<span class="number">6545</span>,  <span class="comment">// -14</span></span><br><span class="line">	<span class="number">6212</span>,  <span class="comment">// -13</span></span><br><span class="line">	<span class="number">5898</span>,  <span class="comment">// -12</span></span><br><span class="line">	<span class="number">5601</span>,  <span class="comment">// -11</span></span><br><span class="line">	<span class="number">5319</span>,  <span class="comment">// -10</span></span><br><span class="line">	<span class="number">5053</span>,  <span class="comment">// -9</span></span><br><span class="line">	<span class="number">4801</span>,  <span class="comment">// -8</span></span><br><span class="line">	<span class="number">4562</span>,  <span class="comment">// -7</span></span><br><span class="line">	<span class="number">4336</span>,  <span class="comment">// -6</span></span><br><span class="line">	<span class="number">4122</span>,  <span class="comment">// -5</span></span><br><span class="line">	<span class="number">3920</span>,  <span class="comment">// -4</span></span><br><span class="line">	<span class="number">3728</span>,  <span class="comment">// -3</span></span><br><span class="line">	<span class="number">3546</span>,  <span class="comment">// -2</span></span><br><span class="line">	<span class="number">3374</span>,  <span class="comment">// -1</span></span><br><span class="line">	<span class="number">3211</span>,  <span class="comment">// 0</span></span><br><span class="line">	<span class="number">3057</span>,  <span class="comment">// 1</span></span><br><span class="line">	<span class="number">2910</span>,  <span class="comment">// 2</span></span><br><span class="line">	<span class="number">2771</span>,  <span class="comment">// 3</span></span><br><span class="line">	<span class="number">2639</span>,  <span class="comment">// 4</span></span><br><span class="line">	<span class="number">2515</span>,  <span class="comment">// 5</span></span><br><span class="line">	<span class="number">2396</span>,  <span class="comment">// 6</span></span><br><span class="line">	<span class="number">2284</span>,  <span class="comment">// 7</span></span><br><span class="line">	<span class="number">2177</span>,  <span class="comment">// 8</span></span><br><span class="line">	<span class="number">2076</span>,  <span class="comment">// 9</span></span><br><span class="line">	<span class="number">1978</span>,  <span class="comment">// 10</span></span><br><span class="line">	<span class="number">1889</span>,  <span class="comment">// 11</span></span><br><span class="line">	<span class="number">1802</span>,  <span class="comment">// 12</span></span><br><span class="line">	<span class="number">1720</span>,  <span class="comment">// 13</span></span><br><span class="line">	<span class="number">1642</span>,  <span class="comment">// 14</span></span><br><span class="line">	<span class="number">1568</span>,  <span class="comment">// 15</span></span><br><span class="line">	<span class="number">1497</span>,  <span class="comment">// 16</span></span><br><span class="line">	<span class="number">1430</span>,  <span class="comment">// 17</span></span><br><span class="line">	<span class="number">1366</span>,  <span class="comment">// 18</span></span><br><span class="line">	<span class="number">1306</span>,  <span class="comment">// 19</span></span><br><span class="line">	<span class="number">1248</span>,  <span class="comment">// 20</span></span><br><span class="line">	<span class="number">1193</span>,  <span class="comment">// 21</span></span><br><span class="line">	<span class="number">1141</span>,  <span class="comment">// 22</span></span><br><span class="line">	<span class="number">1092</span>,  <span class="comment">// 23</span></span><br><span class="line">	<span class="number">1044</span>,  <span class="comment">// 24</span></span><br><span class="line">	<span class="number">1000</span>,  <span class="comment">// 25</span></span><br><span class="line">	<span class="number">957</span>,   <span class="comment">// 26</span></span><br><span class="line">	<span class="number">916</span>,   <span class="comment">// 27</span></span><br><span class="line">	<span class="number">877</span>,   <span class="comment">// 28</span></span><br><span class="line">	<span class="number">840</span>,   <span class="comment">// 29</span></span><br><span class="line">	<span class="number">805</span>,   <span class="comment">// 30</span></span><br><span class="line">	<span class="number">771</span>,   <span class="comment">// 31</span></span><br><span class="line">	<span class="number">739</span>,   <span class="comment">// 32</span></span><br><span class="line">	<span class="number">709</span>,   <span class="comment">// 33</span></span><br><span class="line">	<span class="number">679</span>,   <span class="comment">// 34</span></span><br><span class="line">	<span class="number">652</span>,   <span class="comment">// 35</span></span><br><span class="line">	<span class="number">625</span>,   <span class="comment">// 36</span></span><br><span class="line">	<span class="number">600</span>,   <span class="comment">// 37</span></span><br><span class="line">	<span class="number">576</span>,   <span class="comment">// 38</span></span><br><span class="line">	<span class="number">552</span>,   <span class="comment">// 39</span></span><br><span class="line">	<span class="number">530</span>,   <span class="comment">// 40</span></span><br><span class="line">	<span class="number">509</span>,   <span class="comment">// 41</span></span><br><span class="line">	<span class="number">489</span>,   <span class="comment">// 42</span></span><br><span class="line">	<span class="number">470</span>,   <span class="comment">// 43</span></span><br><span class="line">	<span class="number">452</span>,   <span class="comment">// 44</span></span><br><span class="line">	<span class="number">434</span>,   <span class="comment">// 45</span></span><br><span class="line">	<span class="number">417</span>,   <span class="comment">// 46</span></span><br><span class="line">	<span class="number">401</span>,   <span class="comment">// 47</span></span><br><span class="line">	<span class="number">386</span>,   <span class="comment">// 48</span></span><br><span class="line">	<span class="number">371</span>,   <span class="comment">// 49</span></span><br><span class="line">	<span class="number">358</span>,   <span class="comment">// 50</span></span><br><span class="line">	<span class="number">344</span>,   <span class="comment">// 51</span></span><br><span class="line">	<span class="number">331</span>,   <span class="comment">// 52</span></span><br><span class="line">	<span class="number">318</span>,   <span class="comment">// 53</span></span><br><span class="line">	<span class="number">306</span>,   <span class="comment">// 54</span></span><br><span class="line">	<span class="number">295</span>,   <span class="comment">// 55</span></span><br><span class="line">	<span class="number">284</span>,   <span class="comment">// 56</span></span><br><span class="line">	<span class="number">274</span>,   <span class="comment">// 57</span></span><br><span class="line">	<span class="number">264</span>,   <span class="comment">// 58</span></span><br><span class="line">	<span class="number">254</span>,   <span class="comment">// 59</span></span><br><span class="line">	<span class="number">245</span>,   <span class="comment">// 60</span></span><br><span class="line">	<span class="number">236</span>,   <span class="comment">// 61</span></span><br><span class="line">	<span class="number">228</span>,   <span class="comment">// 62</span></span><br><span class="line">	<span class="number">220</span>,   <span class="comment">// 63</span></span><br><span class="line">	<span class="number">212</span>,   <span class="comment">// 64</span></span><br><span class="line">	<span class="number">205</span>,   <span class="comment">// 65</span></span><br><span class="line">	<span class="number">198</span>,   <span class="comment">// 66</span></span><br><span class="line">	<span class="number">191</span>,   <span class="comment">// 67</span></span><br><span class="line">	<span class="number">184</span>,   <span class="comment">// 68</span></span><br><span class="line">	<span class="number">178</span>,   <span class="comment">// 69</span></span><br><span class="line">	<span class="number">172</span>,   <span class="comment">// 70</span></span><br><span class="line">	<span class="number">166</span>,   <span class="comment">// 71</span></span><br><span class="line">	<span class="number">160</span>,   <span class="comment">// 72</span></span><br><span class="line">	<span class="number">155</span>,   <span class="comment">// 73</span></span><br><span class="line">	<span class="number">150</span>,   <span class="comment">// 74</span></span><br><span class="line">	<span class="number">145</span>,   <span class="comment">// 75</span></span><br><span class="line">	<span class="number">140</span>,   <span class="comment">// 76</span></span><br><span class="line">	<span class="number">135</span>,   <span class="comment">// 77</span></span><br><span class="line">	<span class="number">131</span>,   <span class="comment">// 78</span></span><br><span class="line">	<span class="number">126</span>,   <span class="comment">// 79</span></span><br><span class="line">	<span class="number">122</span>,   <span class="comment">// 80</span></span><br><span class="line">	<span class="number">118</span>,   <span class="comment">// 81</span></span><br><span class="line">	<span class="number">115</span>,   <span class="comment">// 82</span></span><br><span class="line">	<span class="number">111</span>,   <span class="comment">// 83</span></span><br><span class="line">	<span class="number">107</span>,   <span class="comment">// 84</span></span><br><span class="line">	<span class="number">104</span>,   <span class="comment">// 85</span></span><br><span class="line">	<span class="number">101</span>,   <span class="comment">// 86</span></span><br><span class="line">	<span class="number">97</span>,    <span class="comment">// 87</span></span><br><span class="line">	<span class="number">94</span>,    <span class="comment">// 88</span></span><br><span class="line">	<span class="number">91</span>,    <span class="comment">// 89</span></span><br><span class="line">	<span class="number">89</span>,    <span class="comment">// 90</span></span><br><span class="line">	<span class="number">86</span>,    <span class="comment">// 91</span></span><br><span class="line">	<span class="number">83</span>,    <span class="comment">// 92</span></span><br><span class="line">	<span class="number">81</span>,    <span class="comment">// 93</span></span><br><span class="line">	<span class="number">78</span>,    <span class="comment">// 94</span></span><br><span class="line">	<span class="number">76</span>,    <span class="comment">// 95</span></span><br><span class="line">	<span class="number">74</span>,    <span class="comment">// 96</span></span><br><span class="line">	<span class="number">71</span>,    <span class="comment">// 97</span></span><br><span class="line">	<span class="number">69</span>,    <span class="comment">// 98</span></span><br><span class="line">	<span class="number">67</span>,    <span class="comment">// 99</span></span><br><span class="line">	<span class="number">65</span>,    <span class="comment">// 100</span></span><br><span class="line">	<span class="number">63</span>,    <span class="comment">// 101</span></span><br><span class="line">	<span class="number">61</span>,    <span class="comment">// 102</span></span><br><span class="line">	<span class="number">60</span>,    <span class="comment">// 103</span></span><br><span class="line">	<span class="number">58</span>,    <span class="comment">// 104</span></span><br><span class="line">	<span class="number">56</span>,    <span class="comment">// 105</span></span><br><span class="line">	<span class="number">55</span>,    <span class="comment">// 106</span></span><br><span class="line">	<span class="number">53</span>,    <span class="comment">// 107</span></span><br><span class="line">	<span class="number">52</span>,    <span class="comment">// 108</span></span><br><span class="line">	<span class="number">50</span>,    <span class="comment">// 109</span></span><br><span class="line">	<span class="number">49</span>,    <span class="comment">// 110</span></span><br><span class="line">	<span class="number">47</span>,    <span class="comment">// 111</span></span><br><span class="line">	<span class="number">46</span>,    <span class="comment">// 112</span></span><br><span class="line">	<span class="number">45</span>,    <span class="comment">// 113</span></span><br><span class="line">	<span class="number">43</span>,    <span class="comment">// 114</span></span><br><span class="line">	<span class="number">42</span>,    <span class="comment">// 115</span></span><br><span class="line">	<span class="number">41</span>,    <span class="comment">// 116</span></span><br><span class="line">	<span class="number">40</span>,    <span class="comment">// 117</span></span><br><span class="line">	<span class="number">39</span>,    <span class="comment">// 118</span></span><br><span class="line">	<span class="number">38</span>,    <span class="comment">// 119</span></span><br><span class="line">	<span class="number">37</span>,    <span class="comment">// 120</span></span><br><span class="line">	<span class="number">36</span>,    <span class="comment">// 121</span></span><br><span class="line">	<span class="number">35</span>,    <span class="comment">// 122</span></span><br><span class="line">	<span class="number">34</span>,    <span class="comment">// 123</span></span><br><span class="line">	<span class="number">33</span>,    <span class="comment">// 124</span></span><br><span class="line">	<span class="number">32</span>,    <span class="comment">// 125</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置热敏电阻要用到的引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIC_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef NIC_GPIO_Init; <span class="comment">//结构定义</span></span><br><span class="line">	NIC_GPIO_Init.Pin  = GPIO_Pin_4; <span class="comment">//指定要初始化的IO,</span></span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	NIC_GPIO_Init.Mode = GPIO_HighZ;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;NIC_GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC 转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIC_ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC_InitTypeDef NIC_ADC_init;</span><br><span class="line">	<span class="comment">// ADC 模拟信号采样时间控制, 0~31（注意： SMPDUTY 一定不能设置小于 10）</span></span><br><span class="line">	NIC_ADC_init.ADC_SMPduty = <span class="number">31</span>;	</span><br><span class="line">    <span class="comment">// 设置 ADC 工作时钟频率	ADC_SPEED_2X1T~ADC_SPEED_2X16T</span></span><br><span class="line">	NIC_ADC_init.ADC_Speed = ADC_SPEED_2X1T;	</span><br><span class="line">    <span class="comment">// ADC结果调整,	ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIFIED</span></span><br><span class="line">	NIC_ADC_init.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;	</span><br><span class="line">	NIC_ADC_init.ADC_CsSetup = <span class="number">0</span>; <span class="comment">//ADC 通道选择时间控制 0(默认),1</span></span><br><span class="line">	NIC_ADC_init.ADC_CsHold = <span class="number">1</span>; <span class="comment">//ADC 通道选择保持时间控制 0,1(默认),2,3</span></span><br><span class="line">	</span><br><span class="line">	ADC_Inilize(&amp;NIC_ADC_init);</span><br><span class="line">	</span><br><span class="line">	ADC_PowerControl(ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热敏电阻初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NTC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NIC_GPIO_Config();</span><br><span class="line">    NIC_ADC_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取温度值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NTC_GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> ntc_V; <span class="comment">// ADC 处的电压</span></span><br><span class="line">    <span class="type">float</span> ntc_R; <span class="comment">// ADC 处的电阻值</span></span><br><span class="line">    <span class="type">float</span> ntc_100R; <span class="comment">// 热敏电阻的电阻值 * 100</span></span><br><span class="line">    <span class="type">float</span> diff; <span class="comment">// 差值</span></span><br><span class="line">    <span class="type">float</span> min <span class="comment">// 最小差值</span></span><br><span class="line">    <span class="type">int</span> i, index;</span><br><span class="line">    <span class="comment">// 获取 ADC 采样数值</span></span><br><span class="line">    u16 adc_result = Get_ADCResult(ADC_CH12);	<span class="comment">//channel = 0~15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将采样的数值转换为电压值</span></span><br><span class="line">    ntc_V = adc_result * <span class="number">2.5</span> / <span class="number">4096</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据电压求出电阻 电阻 = 电压 / 电流</span></span><br><span class="line">    <span class="comment">// 串联电路电流处处相等下</span></span><br><span class="line">    ntc_R = ntc_V * <span class="number">10</span> / ( <span class="number">3.3</span> - ntc_V );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用热敏电阻处的电阻与对照表中的数据进行比对进而得出温度值</span></span><br><span class="line">    ntc_100R = <span class="number">100</span> * ntc_R;</span><br><span class="line">    <span class="comment">// 遍历数组，比较差值最小的，就是当前的温度</span></span><br><span class="line">    <span class="comment">// 默认第一个元素插值最小</span></span><br><span class="line">    index = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 数组中存放是是（阻值 x 100)</span></span><br><span class="line">    <span class="comment">// 默认数组中第一个元素的差值最小</span></span><br><span class="line">    min = temp_table[<span class="number">0</span>] - ntc_100R &gt; <span class="number">0</span>? temp_table[<span class="number">0</span>] - ntc_100R : -(temp_table[<span class="number">0</span>] - ntc_100R);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(temp_table) / <span class="keyword">sizeof</span>(u16); i++) &#123;</span><br><span class="line">        <span class="comment">// 得出当前阻值与对照表中阻止的差</span></span><br><span class="line">        diff = temp_table[i] - ntc_100R &gt; <span class="number">0</span>? temp_table[i] - ntc_100R: -(temp_table[i] - ntc_100R);</span><br><span class="line">        <span class="comment">// 获取差值最小的下标</span></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; min) &#123;</span><br><span class="line">        	min = diff;</span><br><span class="line">            index = i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="comment">// &amp;gt;&amp;gt;&amp;gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &amp;lt;&amp;lt;&amp;lt;</span></span><br><span class="line">    COMx_InitDefine COMx_Init; <span class="comment">//结构定义</span></span><br><span class="line">    <span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_Init.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    <span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_Init.UART_BRT_Use = BRT_Timer1;			</span><br><span class="line">    COMx_Init.UART_BaudRate = <span class="number">115200ul</span>; <span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_Init.UART_RxEnable = ENABLE; <span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_Init.BaudRateDouble = DISABLE; <span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    <span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line">    UART_Configuration(UART1, &amp;amp;COMx_InitStructure);		</span><br><span class="line">	<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line">    <span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="comment">// 温度</span></span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    NTC_Init();</span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 得到温度值</span></span><br><span class="line">        t = NTC_GetTemperature();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;温度:%d\n&quot;</span>, t);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>NTC.h 中的头尾是什么作用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>‌#ifndef 在 C 语言中是“if not defined”的简写，属于宏定义的一种，用于条件编译。</p>
<ol>
<li><code>#ifndef __NTC_H</code>：这是预处理指令 <code>#ifndef</code>（If Not Defined的缩写），用于检查宏 <code>__NTC_H</code> 是否尚未定义。如果 <code>__NTC_H</code> 没有被定义，那么编译器会执行 <code>#ifndef</code> 和紧接着的 <code>#endif</code> 之间的代码。这种机制用于确保头文件的内容只被包含一次。</li>
<li><code>#define __NTC_H</code>：这行代码定义了宏 <code>__NTC_H</code>。一旦这个宏被定义，后续的 <code>#ifndef __NTC_H</code> 检查就会失败，因为 <code>__NTC_H</code> 已经被定义了。这防止了头文件内容的重复包含。</li>
<li><code>#endif</code>：这表示 <code>#ifndef</code> 和 <code>#endif</code> 之间的代码块的结束。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>温湿度传感器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>温湿度传感器</strong>是一类用于测量环境<strong>温度</strong>和<strong>湿度</strong>的<strong>设备</strong>，广泛应用于气候监测、家用电器、物联网（IoT）设备、工业自动化等领域。它们能够感知环境中的温度和湿度变化，并将这些信息以<strong>电信号</strong>（0 和 1）的形式传递给微控制器（MCU）或处理单元。</p>
<h3 id="温湿度传感器的工作原理"><a href="#温湿度传感器的工作原理" class="headerlink" title="温湿度传感器的工作原理"></a><strong>温湿度传感器的工作原理</strong></h3><p>温湿度传感器通常将温度和湿度这两个参数集成在一个<strong>传感器芯片</strong>上，它们的工作原理如下：</p>
<h4 id="温度传感器部分"><a href="#温度传感器部分" class="headerlink" title="温度传感器部分"></a>温度传感器部分</h4><ul>
<li>温度测量常使用热敏电阻、热电偶、或半导体温度传感器来感知温度。<ul>
<li><strong>热敏电阻</strong>：通过材料电阻值随温度变化而变化的特性来测量温度。</li>
<li><strong>半导体温度传感器</strong>：基于 PN 结的电压特性，随着温度变化产生可测量的电压变化。</li>
<li><strong>热电偶</strong>：由两种不同金属连接形成，当温度变化时产生电势差。</li>
</ul>
</li>
</ul>
<h4 id="湿度传感器部分"><a href="#湿度传感器部分" class="headerlink" title="湿度传感器部分"></a>湿度传感器部分</h4><ul>
<li>湿度测量一般通过电容式湿度传感器或电阻式湿度传感器来完成。<ul>
<li><strong>电容式湿度传感器</strong>：由一层吸湿性介质组成，介质吸收空气中的水分导致电容变化，从而测量湿度。</li>
<li><strong>电阻式湿度传感器</strong>：感湿材料的电阻随空气湿度变化而变化，电阻值的变化反映空气中的湿度。</li>
</ul>
</li>
</ul>
<h3 id="常见的温湿度传感器种类"><a href="#常见的温湿度传感器种类" class="headerlink" title="常见的温湿度传感器种类"></a><strong>常见的温湿度传感器种类</strong></h3><p>嵌入式开发中，使用最广泛的温湿度传感器主要有以下几类：</p>
<h4 id="DHT-系列传感器"><a href="#DHT-系列传感器" class="headerlink" title="DHT 系列传感器"></a><strong>DHT 系列传感器</strong></h4><ul>
<li>DHT11 和 DHT22 是常见的低成本温湿度传感器，具有数字输出，易于与微控制器连接。<ul>
<li><strong>DHT11</strong>：精度较低，温度测量范围为 0<del>50℃，湿度测量范围为 20%</del>90%RH（相对湿度）。</li>
<li><strong>DHT22</strong>：精度较高，温度测量范围为 -40<del>80℃，湿度测量范围为 0%</del>100%RH。</li>
<li><strong>通信方式</strong>：单总线协议，通常用一根数据线来传输温度和湿度数据，简单易用。</li>
</ul>
</li>
</ul>
<h4 id="SHT-系列传感器"><a href="#SHT-系列传感器" class="headerlink" title="SHT 系列传感器"></a><strong>SHT 系列传感器</strong></h4><ul>
<li>SHT3x、SHT4x 系列是 Sensirion 公司生产的高精度温湿度传感器，广泛用于工业和高精度应用。<ul>
<li><strong>精度</strong>：温度测量精度高达 ±0.1℃，湿度测量精度 ±1.5%RH。</li>
<li><strong>通信方式</strong>：采用 I2C 或 SPI 接口，数据传输速度快，适合对精度要求较高的应用。</li>
</ul>
</li>
</ul>
<h4 id="AM2302（DHT22-的改进版）"><a href="#AM2302（DHT22-的改进版）" class="headerlink" title="AM2302（DHT22 的改进版）"></a><strong>AM2302（DHT22 的改进版）</strong></h4><ul>
<li>与 DHT22 类似，AM2302 是精度更高的温湿度传感器。<ul>
<li><strong>温度测量范围</strong>：-40~80℃。</li>
<li><strong>湿度测量范围</strong>：0~100%RH。</li>
</ul>
</li>
</ul>
<h3 id="DHT11"><a href="#DHT11" class="headerlink" title="DHT11"></a>DHT11</h3><p><strong>DHT11</strong> 是一种常用的低成本<strong>温湿度传感器</strong>，广泛用于简单的环境监测应用。它可以<strong>同时测量环境的温度和湿度</strong>，并通过<strong>单线数字接口</strong>与微控制器通信，易于使用。</p>
<p><strong>温度测量：</strong>DHT11 使用一个 <strong>NTC 热敏电阻</strong>作为温度感应器，感知周围环境的温度变化。热敏电阻的电阻值会随着温度变化而变化，传感器内部将此电阻变化转换为温度数据。</p>
<p><strong>湿度测量：</strong>DHT11 使用<strong>电容式湿度传感器</strong>来检测湿度。传感器内有一个吸湿性聚合物层，这一层的电容会随着空气中水分含量（湿度）的变化而变化。传感器通过测量这一电容变化来计算空气湿度。</p>
<p><strong>通信协议</strong></p>
<p>DHT11 使用<strong>单线数字通信协议</strong>来与微控制器通信，这意味着它只需<strong>一个数据线即可传输温湿度数据</strong>。通信流程通常如下：</p>
<ol>
<li><p><strong>初始化</strong>：微控制器向传感器发送一个低电平启动信号（至少 18ms），然后释放数据线（至少 10us）。</p>
</li>
<li><p><strong>响应信号</strong>：DHT11 传感器发送一个响应信号（响应低高电平，低电平至少 78us，高电平至少 80us），告诉微控制器它已经准备好数据。</p>
</li>
<li><p><strong>数据传输</strong>：DHT11 以位（bit）的形式将温度和湿度数据（共 40 位）传给微控制器。数据传输分为两个部分：</p>
<ul>
<li><p><strong>湿度数据</strong>（16 位）：包含湿度的整数和小数部分。</p>
</li>
<li><p><strong>温度数据</strong>（16 位）：包含温度的整数和小数部分。</p>
</li>
</ul>
</li>
<li><p><strong>校验位</strong>：最后传感器发送一个 8 位的校验码，用于确认数据是否传输正确。</p>
</li>
</ol>
<p><strong>DHT11 温湿度传感器的通信时序参数</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shixucanshu.png" alt="DHT11shixucanshu"></p>
<p><strong>数据时序图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shjushixu.png" alt="DHT11shjushixu"></p>
<p><strong>信息格式说明</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11geshishuom.png" alt="DHT11geshishuom"></p>
<p><strong>接收到的 40 位数据示例</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shili.png" alt="DHT11shili"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>使用 DHT11 模块</p>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11yinjiao.png" alt="DHT11yinjiao"></p>
<blockquote>
<p>NG 通常表示<strong>没有接地</strong>或<strong>没有连接</strong>。在具体电路中，建议结合设计者的注释或相关文档进一步确认它的确切含义。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DHT11.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typedef</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> humidity;    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="type">float</span> temperature; <span class="comment">// 温度</span></span><br><span class="line">    u8 is_ok;		   <span class="comment">// 校验位：0 数据异常，1 数据正确</span></span><br><span class="line">    </span><br><span class="line">&#125;DHT11_TRH;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_GetTRH</span><span class="params">()</span>;</span><br><span class="line">===============================================================================</span><br><span class="line"><span class="comment">// DHT11.c    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DHT11.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11 P46 <span class="comment">// 温湿度传感器数据引脚    </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGH 1    <span class="comment">// 高电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOW 0    <span class="comment">// 低电平</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 计算从设备输出的高低电平是否正确 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> calc_time(level, min, max, ErrMsg); count = 0;								\</span></span><br><span class="line"><span class="meta">                                            do &#123;									\				</span></span><br><span class="line">                                                count++;							\</span><br><span class="line">                                                NOP16();<span class="comment">//(1us) 不同设备可能时间不同 	 \ </span></span><br><span class="line">                                            &#125; <span class="keyword">while</span>(DHT11 == level);				\</span><br><span class="line">                                            <span class="keyword">if</span>(count &lt; main || count &gt; max) &#123;		\</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, ErrMsg, count);	\</span><br><span class="line">                                                <span class="keyword">return</span> trh;							\</span><br><span class="line">                                            &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay20ms</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">// @24.000MHz</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line">    </span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    j = <span class="number">112</span>;</span><br><span class="line">    k = <span class="number">91</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(--k);</span><br><span class="line">        &#125; <span class="keyword">while</span>(--j);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span>(--i);  </span><br><span class="line">&#125;    </span><br><span class="line">      </span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DHT11_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_DHT11_Init;</span><br><span class="line">    GPIO_DHT11_Init.Mode = GPIO_PullUp; <span class="comment">//IO模式, GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_DHT11_Init.Pin = GPIO_Pin_6;   <span class="comment">//要设置的端口</span></span><br><span class="line">    </span><br><span class="line">    GPIO_Inilize(GPIO_P4, &amp;GPIO_DHT11_Init);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_DHT11_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DHT11_TRH <span class="title function_">DhT11_GetTRH</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    DHT11_TRH trh;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    u8 dat[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    trh.is_ok = <span class="number">0</span>; <span class="comment">// 默认数据不准确</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主机起始信号拉低时间</span></span><br><span class="line">    DHT11 = <span class="number">0</span>;</span><br><span class="line">    Delay20ms();</span><br><span class="line">    DHT11 = <span class="number">1</span>; <span class="comment">// 拉高后 10~35us 内温湿度传感觉会进行相应；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主机释放总线时间,高电平持续 10~35 us</span></span><br><span class="line">    calc_time(HIGH, <span class="number">10</span>, <span class="number">35</span>, <span class="string">&quot;主机释放时间有误&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应低电平时间，低电平持续时间 78~88 us</span></span><br><span class="line">    calc_time(LOW, <span class="number">78</span>, <span class="number">88</span>, <span class="string">&quot;响应低电平时间有误&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应高电平时间，高电平持续 80~92 us</span></span><br><span class="line">    calc_time(HIGH, <span class="number">80</span>, <span class="number">92</span>, <span class="string">&quot;响应高电平时间有无&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始接收数据并校验是否正确（40 位）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 五个字节</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 每个字节八位</span></span><br><span class="line">            <span class="comment">// 判断低电平是否有误</span></span><br><span class="line">            calc_time(LOW, <span class="number">50</span>, <span class="number">58</span>, <span class="string">&quot;信号 0|1 低电平时间有误&quot;</span>);</span><br><span class="line">            <span class="comment">// 判断高电平是否有误</span></span><br><span class="line">            calc_time(LOW, <span class="number">23</span>, <span class="number">74</span>, <span class="string">&quot;信号 0|1 低电平时间有误&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">48</span>) &#123; <span class="comment">// 48 是 0|1 高电平的中间值</span></span><br><span class="line">                <span class="comment">// 数组默认为 0，所以这里只需要根据位置修改为 1 即可</span></span><br><span class="line">                dat[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 校验数据是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(dat[<span class="number">4</span>] == dat[<span class="number">0</span>] + dat[<span class="number">1</span>] + dat[<span class="number">2</span>] + dat[<span class="number">3</span>]) &#123;</span><br><span class="line">        trh.is_ok = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 组装温湿度</span></span><br><span class="line">       trh.humidity = dat[<span class="number">0</span>] + dat[<span class="number">1</span>] * <span class="number">0.1</span>;</span><br><span class="line">       <span class="comment">// 温度小数位的最高位为标志位不参与运算 </span></span><br><span class="line">       trh.humidity = dat[<span class="number">2</span>] + (dat[<span class="number">3</span>] &amp; <span class="number">0x7F</span>) * <span class="number">0.1</span>; </span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(dat[<span class="number">3</span>] &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">           trh.humidity = -trh.humidity;</span><br><span class="line">       &#125; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> trh;</span><br><span class="line">&#125;                           </span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;STC8G_H_Delay.h&quot;</span>   </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;STC8G_H_UART.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;DHTll.h.h&quot;</span>   </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    DHT11_TRH DHT11_trh;</span><br><span class="line">      </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    DHT11_Init();</span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        trh = DHT11_GetTRH();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(trh.is_ok) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;温度：%.2f\n&quot;</span>, trh.temperature);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;湿度：%.2f\n&quot;</span>, trh.humidity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;数据有误，请重新获取~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵键盘</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>矩阵键盘通常由<strong>行（Row）和列（Column）组成，按键排列在行和列的交叉点处。例如，一个 4x4 矩阵键盘</strong>有 4 行 4 列，共 16 个按键。每个按键位于行和列的交点处，按下按键时会将该行和该列连接在一起。</p>
<p><strong>工作原理</strong></p>
<p>矩阵键盘的工作原理是通过<strong>扫描行和列来检测哪个按键被按下</strong>。每按下一个按键，就会将对应的行和列连接，使微控制器能够识别按键的具体位置。为了实现这一点，矩阵键盘的检测通常分为两部分：</p>
<ul>
<li><strong>行扫描</strong>：微控制器将行设置为输出，逐行输出高或低电平信号。</li>
<li><strong>列检测</strong>：微控制器将列设置为输入，检查列引脚是否检测到电平的变化（即按键被按下）。</li>
</ul>
<p><strong>去抖处理</strong></p>
<p>按键按下和释放时，电路中可能会出现抖动现象，导致信号不稳定。在嵌入式系统中，通常需要进行<strong>按键去抖动处理</strong>。常见的去抖动方法包括：</p>
<ul>
<li><strong>软件去抖动</strong>：在检测到按键按下后，延时数毫秒后再次检测按键状态（或者通过额外的标志位，在检测到按下后立即置 0），以确保信号稳定。</li>
<li><strong>硬件去抖动</strong>：在按键电路中增加电容或使用专门的去抖动芯片来滤除噪声信号。</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/juzhenjpanyinjiaotu.png" alt="juzhenjpanyinjiaotu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MatrixKey.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MATRIXKEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MATRIXKEY_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Scan</span><span class="params">(<span class="type">void</span>(*key_down) (u8, u8), <span class="type">void</span>(*key_up) (u8, u8))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// MatrixKey.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义行列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL1 P03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL2 P06    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL3 P07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL4 P17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW1 P34    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW2 P35 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW3 P40    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW4 P41   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测按键上一个状态是否为弹起</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_up(status, row, col)   ((status &amp; (1 <span class="string">&lt;&lt; 4 * row + col)) &gt;</span> 0)</span></span><br><span class="line"><span class="comment">// 检测按键上一个状态是否为按下    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_down(status, row, col) ((status &amp; (1 &lt;&lt; 4 * row + col)) == 0)      </span></span><br><span class="line"><span class="comment">// 设置按键状态为弹起</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_up(status, row, col)   (status |= (1 &lt;&lt; 4 * row + col))</span></span><br><span class="line"><span class="comment">// 设置按键状态为按下  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_down(status, row, col) (status &amp;= (1 &lt;&lt; 4 * row + col))    </span></span><br><span class="line">    </span><br><span class="line">u16 status = <span class="number">0xFFFF</span>; <span class="comment">//默认 4x4 的按键状态都是弹起    </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config_MatrixKey</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;    </span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    </span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;    </span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_7;</span><br><span class="line">    GPIO_Inilize(GPIO_P1, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P4, &amp;GPIO_Init);</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_Config_MatrixKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(u8 row)</span> &#123;</span><br><span class="line">    ROW1 = row == <span class="number">0</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW2 = row == <span class="number">1</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW3 = row == <span class="number">2</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW4 = row == <span class="number">3</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">get_col</span><span class="params">(u8 col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(col == <span class="number">0</span>) <span class="keyword">return</span> COL1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">1</span>) <span class="keyword">return</span> COL2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">2</span>) <span class="keyword">return</span> COL3;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">3</span>) <span class="keyword">return</span> COL4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="comment">// 扫描按键，如果需要感知按下或者弹起的状态，那么就传递进来按下和弹起的处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Scan</span><span class="params">(<span class="type">void</span>(*key_down) (u8, u8), <span class="type">void</span>(*key_up) (u8, u8))</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 4行</span></span><br><span class="line">        set_row(i);			  <span class="comment">// 逐行扫描</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123; <span class="comment">// 逐列判定</span></span><br><span class="line">            <span class="comment">// 判断按键是否被按下，且按下之前的上一个状态时弹起（防抖）</span></span><br><span class="line">            <span class="keyword">if</span>(get_col(j) == <span class="number">0</span> &amp;&amp; is_up(status, i, j)) &#123;</span><br><span class="line">                set_down(status, i, j);</span><br><span class="line">                <span class="keyword">if</span> (key_down != null) key_down(i j);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(get_col(j) == <span class="number">1</span> &amp;&amp; is_down(status, i, j)) &#123;</span><br><span class="line">                set_up(status, i, j);</span><br><span class="line">                <span class="keyword">if</span> (key_up != null) key_down(i j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">	UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">	UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">	UART_Init.Morecommunicate = DISABLE;</span><br><span class="line">	UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">	UART_Init.BaudRateDouble = DISABLE;</span><br><span class="line">    </span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line">    </span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    </span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下：%d-%d\n&quot;</span>, (<span class="type">int</span>)row, (<span class="type">int</span>)col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹起：%d-%d\n&quot;</span>, (<span class="type">int</span>)row, (<span class="type">int</span>)col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    UART_Config();</span><br><span class="line">    MK_Init();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;        </span><br><span class="line">        MK_Scan(down, <span class="literal">NULL</span>);</span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>独立按键</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p>查看原理图，看独立按键分别接的是那些引脚</p>
<h2 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h2><ol>
<li>软件延时法：在按键按下时，使用软件延时一段时间，例如10毫秒，然后再检测按键是否还处于按下状态，如果是，则认为按键有效。这种方法简单易行，但会浪费一定的处理器时间，同时需要根据实际情况调整延时时间。</li>
<li>硬件滤波法：在按键输入引脚上添加RC滤波电路，可以有效地去除按键信号上的瞬间噪声。这种方法对于高频噪声的去除效果较好，但需要一定的电路设计能力。</li>
<li>程序消抖法：在程序中记录按键前后两次的状态，如果两次状态不同，则认为按键有效。这种方法可以根据需要调整检测时间，消抖效果较好，但需要额外的程序设计。</li>
</ol>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>当用户按下，或者松开按键时，捕获到这个事件。将事件通过串口发出来</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立按键</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 P51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2 P52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3 P53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4 P54</span></span><br><span class="line"></span><br><span class="line">u8 state = <span class="number">0x0f</span>; <span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下/回弹  软件消抖</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UP(state, i) = ((a &amp; (1 <span class="string">&lt;&lt; i)) &gt;</span> 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOWM(state, i) = ((a &amp; (1 &lt;&lt; i)) &lt;= 0)</span></span><br><span class="line"><span class="comment">// 设置控制变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_UP(state, i) = state |= (1 &lt;&lt; i) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_DOWN(state, i) = state &amp;= ~(1 &lt;&lt; i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询四个按键 1~4</span></span><br><span class="line">u8 <span class="title function_">get_kay</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> KAY1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> KAY2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) <span class="keyword">return</span> KAY3;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">return</span> KAY4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Comfig</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;</span><br><span class="line">    </span><br><span class="line">    GPIO_Inilize(GPIO_P5, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">    UART_Init.Morecommunicate = DISABLE; <span class="comment">// 多机通讯</span></span><br><span class="line">    <span class="comment">// 是否允许接收来自发送端的数据</span></span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE; <span class="comment">// 波特率加倍      </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">          </span><br><span class="line">   	<span class="type">int</span> i; <span class="comment">// 四个灯循环遍历</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 全局中断</span></span><br><span class="line">    EA = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    UART_Config();</span><br><span class="line">    GPIO_Comfig();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断四个按键是否按下抬起</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (get_kay() == <span class="number">0</span>) &amp;&amp; (IS_UP(state, i))) &#123;</span><br><span class="line">                <span class="comment">// 将用于消抖的控制位置 0</span></span><br><span class="line">                SET_DOWN(state, i)</span><br><span class="line">                PrintString1(<span class="string">&quot;按钮%d被按下了\n&quot;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((get_kay() == <span class="number">0</span>) &amp;&amp; (IS_DOWM(stat, i))) &#123;</span><br><span class="line">                <span class="comment">// 将用于消抖的控制位置 1</span></span><br><span class="line">                SET_UP(state, i)</span><br><span class="line">                PrintString1(<span class="string">&quot;按钮%d被松开了\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>系统时钟</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<h2 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h2><p>主频指CPU内核工作时的<strong>时钟频率</strong>，它表示CPU内数字脉冲信号震荡的速度。主频的高低在很大程度上反映了CPU速度的快慢，但与CPU实际的运算能力并没有直接的线性关系。</p>
<p>主频的产生主要依赖于CPU内部的时钟发生器（也称为时钟振荡器）。时钟发生器通过不断振荡产生稳定的电信号，这些电信号以固定的频率传递给CPU内部的计数器。计数器每接收一个信号就表示一个时钟周期的发生，而CPU则在每个时钟周期内执行一条指令或进行一步操作。</p>
<p>11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz   2.80 GHz；</p>
<p>其中 2.80 GHz 就是主频，即 CPU 的时钟频率，它表示CPU内部的时钟振荡器每秒能够产生2.8亿个时钟周期，每个时钟周期 CPU可 以执行一条或多条指令（这取决于CPU的架构和指令集）。</p>
<h2 id="系统时钟-时钟频率"><a href="#系统时钟-时钟频率" class="headerlink" title="系统时钟 &#x2F; 时钟频率"></a>系统时钟 &#x2F; 时钟频率</h2><p>系统时钟频率是指同步电路中时钟的基础频率，即单位时间内（如1秒）时钟信号发生的次数。这个频率是由系统时钟振荡器产生的，它提供了一个稳定且精确的脉冲信号，用于控制计算机内部各个部件的同步工作。</p>
<blockquote>
<p>可以将系统时钟理解为主频，因为二者除了概念，在数值上是一致的；</p>
</blockquote>
<h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>时钟周期，也称为振荡周期或节拍周期，是<strong>时钟频率的倒数</strong>。它表示了CPU完成一个最基本动作所需的时间。时钟周期是计算机中最基本的、最小的时间单位。</p>
<p>振荡周期指任何振动（振荡）现象重复出现的时间间隔，也就是完成一次振动所需要的时间。</p>
<p>例如，STC8H的时钟频率为<code>24MHz</code>，那么每个时钟周期的时间就是<code>1/24MHz=41.67ns</code>。</p>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>指令周期是指<strong>计算机执行一条指令所需的全部时间。</strong>它包括了从取出指令、对指令进行译码、执行指令以及处理指令执行结果等一系列步骤。指令周期的长度取决于指令的复杂性和所需的操作数等因素。</p>
<p>指令周期包括了从指令的获取、译码、操作数寻址、执行到结果写回的整个过程。</p>
<p>指令周期可以被认为是计算机执行一条指令所经历的时钟周期数量。</p>
<h2 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h2><p><strong>机器周期则是实现指令周期的基本单位</strong>，一个指令周期通常包含若干个机器周期（比如加法操作）。换句话说，一条指令的执行过程（即指令周期）可能涉及多个机器周期，每个机器周期完成指令执行过程中的一个或多个基本操作。</p>
<blockquote>
<p>早期的 STC8H 单片机的机器周期为 12 个时钟周期。现在的 STC8H 可以有两种配置，一个是 1T，一个是 12 T。这分别是什么意思呢？</p>
<p> 1T 则说明是<strong>单时钟&#x2F;机器周期(1T)的单片机</strong>，指的是该单片机在执行指令时，每个机器周期仅需要一个时钟周期的时间。</p>
<p>标准的 8051 单片机是 12T 的，即一个机器周期包含 12 个时钟周期</p>
<p>传统的单片机（如8051）通常需要多个机器周期来完成一条指令的执行，但在 1T 单片机中，设计的目的是使每条指令在一个时钟周期内完成，因此<strong>指令周期和机器周期相等</strong>。</p>
</blockquote>
<ul>
<li>12T也就是早期的配置，假设当系统时钟为24MHz时，每个机器周期的时间就是<code>12 * 41.67ns = 500ns</code>。</li>
<li>1T是芯片架构升级后的，每个机器周期的时间为 <code>1 * 41.67ns = 41.67ns.</code>。</li>
</ul>
<h2 id="NOP-指令"><a href="#NOP-指令" class="headerlink" title="NOP 指令"></a>NOP 指令</h2><p>NOP指令是一种汇编指令，表示“no operation”（不执行任何操作）。它不会改变寄存器的值，也不会修改存储器中的数据，只消耗一个指令周期。在程序中插入NOP指令可以用于延时或调整代码的执行顺序。</p>
<p>NOP指令在某些情况下也被用于填充一些未使用的空间，使程序的大小达到特定的大小或对齐要求。在编写汇编代码时，程序员可以在代码中插入NOP指令来占用空间，使得代码和数据能够对齐在内存中的特定地址上，以提高程序的执行效率。</p>
<p>在STC8H单片机中，NOP指令被翻译成一条长度为1个字节的指令，不做任何操作。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙通信</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>蜂鸣器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E8%9C%82%E9%B8%A3%E5%99%A8/</url>
    <content><![CDATA[<p>蜂鸣器（Buzzer）是一种能够<strong>将电信号转化为声音信号的电子设备</strong>，常用于嵌入式系统中发出提示音或警报声。</p>
<p>蜂鸣器是一种利用直流电或交流电驱动，发出特定频率的声音的器件。它通常由外壳、振动膜片、电磁线圈或压电元件组成；根据工作原理的不同，可以分为电磁式和压电式两类；按驱动方式分类可分为有源蜂鸣器和无源蜂鸣器</p>
<p><strong>有源蜂鸣器</strong>：内部集成了振荡器，直接接通电源即可发声。使用方便，只需给定直流电压即可驱动。</p>
<p><strong>无源蜂鸣器</strong>：没有内置振荡器，需要通过外部信号（如PWM信号）驱动产生振荡。声音频率、节奏可以通过外部控制。</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/fengmingqiyuanlitu.png" alt="fengmingqiyuanlitu"></p>
<h2 id="赫兹与周期的换算"><a href="#赫兹与周期的换算" class="headerlink" title="赫兹与周期的换算"></a>赫兹与周期的换算</h2><p><strong>频率是指在单位时间内(1s)发生重复事件的次数,通常用赫兹(Hz)表示;周期时间则指完成一次所需时间</strong></p>
<p>频率和周期的关系为：f&#x3D;1&#x2F;T。即频率等于周期的倒数，二者成反比。假设频率为 f &#x3D; 2Hz，那么其周期 T &#x3D; 1 &#x2F; f &#x3D; 1 &#x2F; 2 &#x3D; 0.5 秒（高低电平各0.25）。那么就是定时器的计数时间就应该是：</p>
<p>65535 - （MAIN_Fosc &#x2F; (2 * 2));</p>
<p>那么 1047 的频率也就是一秒内要发生 1047 个重复的周期，也就是 1047 个高电平 + 1047 个低电平，那么也就是说在 1 秒内高低电平一共要被触发 1047 + 1047 &#x3D; 2097 次，也就是定时器在一秒内要被触发 2097 次，所以触发时间就是：</p>
<p>65536 - (MAIN_Fosc &#x2F; (2 * 1047));</p>
<p>再捋一下，此时 (MAIN_Fosc &#x2F; (2 * 1047)) 这个时间就是一次高电平或者低电平的时间，那么 60036 减去这个时间就表示，每次数这么长的时间就触发一次定时中断去改变他的高低电平，这样就达到了触发 1047 这个频率的目的；</p>
<p>再仔细说下为什么这里是主频除以后面的频率，给我一个确定的时间 1ms 我会算，但是给频率就反应不过来怎么办？</p>
<p>这里可以这么想，以上面的 2097 为例，一秒内要执行 2097 次高低电平的转换，那么每次的时间就是 1 &#x2F; 2097s；那么我们将这个 1 &#x2F; 2097 换成主频的时钟周期数，不就是 (主频 * 1&#x2F;2097)，即 MAIN_Fosc &#x2F; 2097 了么；2097 个这么长的时间就是 1ms(24MHz);</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>通过定时器控制播放哆来咪发唆拉西哆</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蜂鸣器引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZER P00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小字二组 哆来咪发唆拉西哆 对应的频率</span></span><br><span class="line"><span class="comment">//			      C`	D`     E`   F`	  G`	A`	  B`    C``</span></span><br><span class="line">u16 hz_note[] = &#123;<span class="number">1047</span>, <span class="number">1175</span>, <span class="number">1319</span>, <span class="number">1397</span>, <span class="number">1568</span>, <span class="number">1760</span>, <span class="number">1976</span>, <span class="number">2093</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引脚初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">	GPIO_Init.Pin  = GPIO_Pin_0;</span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_OUT_PP;</span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Config</span><span class="params">(u16 hz_buzzer)</span> &#123;</span><br><span class="line">    TIM_InitTypeDef Timer_init;</span><br><span class="line">    </span><br><span class="line">    Timer_init.TIM_Mode = TIM_16BitAutoReload;</span><br><span class="line">    <span class="comment">// 时钟源 TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext</span></span><br><span class="line">	Timer_init.TIM_ClkSource = TIM_CLOCK_1T;</span><br><span class="line">    <span class="comment">// 可编程时钟输出,如果配置ENABLE，则 P3.5 端口会同步输出时钟脉冲</span></span><br><span class="line">	Timer_init.TIM_ClkOut = DISABLE	;	</span><br><span class="line">    <span class="comment">// 装载初值</span></span><br><span class="line">    Timer_init.TIM_Value = <span class="number">65536</span> - (MAIN_Fosc / (<span class="number">2</span> * hz_buzzer));		</span><br><span class="line">    <span class="comment">// 是否运行 ENABLE,DISABLE</span></span><br><span class="line">	Timer_init.TIM_Run = ENABLE;		</span><br><span class="line">	<span class="comment">// 选择定时器，并且进行配置</span></span><br><span class="line">	Timer_Inilize(Timer0, &amp;Timer_init);</span><br><span class="line">    <span class="comment">//打开中断使能</span></span><br><span class="line">	NVIC_Timer0_Init(ENABLE, Priority_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 0 中断函数中执行的代码</span></span><br><span class="line">handle_timer0_interrupt() &#123;</span><br><span class="line">    BUZZER = ~BUZZER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 中断总控制</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(hz_note) / siezeof(hz_note[<span class="number">0</span>]; i++))&#123;</span><br><span class="line">            Timer_Config(hz_note[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每播放一个轮次，就停三秒钟不要出声，再继续播放；</span></span><br><span class="line">        stop();</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>定时器的效果是如何作用于蜂鸣器的</strong></p>
<p>定时器的效果作用于蜂鸣器，主要是通过控制蜂鸣器电源的开关状态（即高电平或低电平）来实现的；定时周期决定了蜂鸣器发声的频率，因为频率是单位时间内周期性事件的次数。</p>
<p>也就是说，在一秒内，以不同的频率给蜂鸣器发送高低电平就可以控制它发出不同的声音。</p>
<p>二、<strong>为什么高低电平各占一半呢，高低电平的占比不是和占空比有关么</strong></p>
<p>这样做可以简化控制逻辑，同时确保蜂鸣器发出的声音具有稳定的频率和音色。他可能并不是真的各占一半。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑分析仪</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/</url>
    <content><![CDATA[<p><strong>逻辑分析仪</strong>（Logic Analyzer）是一种用于调试和分析<strong>数字电路</strong>信号的<strong>电子仪器</strong>。它能够捕获并显示数字电路中的多个信号（通常是并行信号），帮助工程师分析和理解电路的工作情况。与示波器不同，逻辑分析仪侧重于监<strong>测数字信号</strong>的时序和逻辑状态，而不是模拟信号的波形。</p>
<p>以<a href="https://www.saleae.com/zh-hans">Saleae 逻辑分析仪</a>为例</p>
<p>你使用那些个引脚，用杜邦线连接到那些引脚就好了，然后打开软件，选择频率就可以查看了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>震动马达</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E9%9C%87%E5%8A%A8%E9%A9%AC%E8%BE%BE/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过P0.1引脚控制马达震动。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR P01</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	GPIO_InitTypeDef	GPIO_InitStructure;		<span class="comment">//结构定义</span></span><br><span class="line">	GPIO_InitStructure.Pin  = GPIO_Pin_1;		<span class="comment">//指定要初始化的IO,</span></span><br><span class="line">	GPIO_InitStructure.Mode = GPIO_OUT_PP;	<span class="comment">//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	GPIO_config();</span><br><span class="line">	</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		MOTOR = <span class="number">1</span>;</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		MOTOR = <span class="number">0</span>;</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>RTX51系统</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/OS/RTOS/RTX51/RTX51%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>RTX51 是 KEIL 公司开发的针对 8051 系列单片机的多任务实时操作系统（RTOS）。它提供了<strong>多任务处理</strong>能力，允许程序以<strong>并行</strong>方式执行，适用于对时间要求严格的嵌入式应用。RTX51 具有简单的 API 和任务调度机制，使开发者能够更方便地管理任务和资源，确保系统的响应性和稳定性。RTX51 系统提供了任务管理、任务调度、任务通讯、定时器、信号量、邮箱等实时操作系统的基本功能，并与 Keil 公司的 C51 编译器紧密集成，从而方便开发人员进行开发和调试。</p>
<blockquote>
<p>RTX51 的多任务处理能力指的是系统能够同时管理和执行多个任务或进程的能力。多个任务看似同时运行，实际上是通过快速切换来实现的。这种切换由操作系统的调度器控制。</p>
</blockquote>
<p><strong>多核和多 CPU</strong></p>
<ul>
<li><p><strong>单核与多核</strong>：</p>
<ul>
<li><p><strong>单核</strong>：系统只有一个处理核心，所有任务都由这一核心处理。虽然能够完成基本的计算任务，但在同时执行多个任务时效率较低。</p>
</li>
<li><p><strong>多核</strong>：系统有多个处理核心（如双核、四核等），每个核心可以独立执行任务。这种架构可以提高并行处理能力，允许多个任务同时进行，从而提升整体性能。</p>
</li>
</ul>
</li>
<li><p><strong>单 CPU 与多 CPU</strong>：</p>
<ul>
<li><p><strong>单 CPU</strong>：系统只配备一个中央处理单元（CPU），类似于单核，但可以是一个复杂的多核处理器。</p>
</li>
<li><p><strong>多 CPU</strong>：系统配备多个 CPU，每个 CPU 可以独立处理任务，通常用于需要极高性能和处理能力的服务器</p>
</li>
<li><p>或高性能计算机。多 CPU 系统通过并行处理可以显著提高计算能力。</p>
</li>
</ul>
</li>
</ul>
<p><strong>RTX51 包含两个版本：</strong></p>
<p>RTX51 Tiny</p>
<ul>
<li>RTX51 Tiny是一个非常小型的实时操作系统，具有基本的任务调度功能，包括任务优先级和时间片轮转等RTX51 Tiny适用于基于51系列单片机的应用程序，特别是对于小型和简单的应用程序，因为它不需要太多的RAM和ROM资源。</li>
<li>相对于 RTX51 Full 不具备如下功能：<ul>
<li>由循环多任务处理和信号实现任务切换</li>
<li>不支持优先任务切换</li>
<li>不包含信息子程序</li>
<li>无存储器库分配子程序</li>
</ul>
</li>
</ul>
<p>RTX51 Full</p>
<ul>
<li>RTX51 Full则是一个功能更为强大的实时操作系统，它不仅支持基本的任务调度功能，还提供了更多的RTOS特性，例如信号量、邮箱、消息队列、事件标志和互斥量等，使得它更加适合于需要更高级RTOS特性的应用程序。</li>
</ul>
<p>RTX51 Tiny是一个轻量级的RTOS，适用于简单的应用程序，而RTX51 Full则提供了更多的RTOS特性，适用于更为复杂的应用程序。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="RTX51-Tiny-环境搭建"><a href="#RTX51-Tiny-环境搭建" class="headerlink" title="RTX51 Tiny 环境搭建"></a>RTX51 Tiny 环境搭建</h3><ol>
<li>新建一个项目</li>
<li>打开keil安装目录，来到<code>C51\RtxTiny2\SourceCode</code>目录，拷贝<code>Conf_tny.A51</code>和<code>RTX51TNY.LIB</code>到项目中。</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51bin.png" alt="RTX51bin"></p>
<ol start="3">
<li>打开配置，来到<code>Target</code>中，将<code>Operating system</code>修改为<code>RTX-51 Tny</code></li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51IDE.png" alt="RTX51IDE"></p>
<ol start="4">
<li>新建好<code>main.c</code>, 代码如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTX51TNY.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P5.3 闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_init</span><span class="params">()</span> &#123;</span><br><span class="line">	P5M1 &amp;= ~<span class="number">0x08</span>; P5M0 &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数名可随意, 建议不要使用start, 会和I2C.h里的Start冲突</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_start</span><span class="params">()</span> _task_ 0 &#123;</span><br><span class="line">	sys_init();</span><br><span class="line">	<span class="comment">// 创建任务 1</span></span><br><span class="line">	os_create_task(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 结束任务 0</span></span><br><span class="line">	os_delete_task(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_1</span><span class="params">()</span> _task_ 1 &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P53 = <span class="number">1</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">		</span><br><span class="line">		P53 = <span class="number">0</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不再有main函数</li>
<li>代码入口为标记为 <code>_task_ 0</code>的函数。</li>
<li><code>_task_</code>标记的函数，表示这个是独立的任务，多个task可以同时执行。</li>
</ul>
<h3 id="RTX51-注意事项"><a href="#RTX51-注意事项" class="headerlink" title="RTX51 注意事项"></a>RTX51 注意事项</h3><p>一、<strong>RTX51 对于系统硬件的要求</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51renwu.png" alt="RTX51renwu"></p>
<p>二、<strong>RTX51 任务的状态及定义</strong></p>
<p>RTX51 区分 2 类任务: <strong>快速任务</strong>和<strong>标准任务</strong>。快速任务有很快的响应速度，每个快速任务使用 8051 一个单独的寄存器组，并且有自己的堆栈区域。RTX51 支持最大同时有 3 个快速任务。标准任务需要多一点的时间来进行任务切换，因此使用的内部 RAM 相对快速任务要少，所有的标准任务共用 1 个寄存器组和堆栈。当任务切换的时候，当前任务的寄存器状态和堆栈内容转移到外部存储器中。</p>
<p>在 RTX51 Full 中，可以通过特定的 API 或函数来创建任务，并在创建时指定任务的类型（快速或标准）。<strong>RTX51 Tiny 则不支持快速任务。</strong></p>
<p>RTX51 FULL 支持任务最多达 64 个，但一般 RTX51 TINY 支持最大 16 个标准任务。</p>
<p>三、<strong>RTX51 自带延迟与 delay_ms() 延时的区别</strong></p>
<p>在 RTX51 Tiny 中 共有三个等待延时函数分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait</span>            <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ, </span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> dummy)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait1</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait2</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks)</span>;</span><br><span class="line"><span class="comment">// 参数如下：</span></span><br><span class="line"><span class="comment">/* constants for os_wait function：也就是等待函数的 typ */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_SIG 0x01 <span class="comment">/* 等待一个信号。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_TMO 0x02 <span class="comment">/* 等待由 ticks 指定的超时时间。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_IVL 0x80 <span class="comment">/* 等待由 ticks 指定的时间间隔。*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数中：K_TMO、K_IVL 看解释十分相似，但其实区别很大：</span></span><br><span class="line"><span class="comment">当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。</span></span><br><span class="line"><span class="comment">当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>os_wait</strong></p>
<p>暂停当前任务，等待一个或多个事件；例如一个时间间隔、超时或来自其他任务或中断的信号。typ 参数指定要等待的事件或事件组合，可以是上述参数中的常量之一：</p>
<p>typ 可以通过竖线（|）字符进行逻辑或操作。例如，K_TMO | K_SIG 表示任务等待超时或信号。</p>
<ul>
<li>**<code>typ</code>**：这是一个指定等待类型的参数。RTX51 中可能定义了多种等待类型，如等待事件、消息、信号量等。具体的类型值取决于 RTX51 的具体实现和文档。</li>
<li>**<code>ticks</code>**：这是等待的时间长度，以操作系统的“tick”为单位。一个 tick 的长度取决于 RTX51 的配置，通常与系统的时钟频率有关。</li>
<li>**<code>dummy</code>**：这个参数在大多数实现中可能并不真正使用，而是为了保持函数签名的兼容性或预留未来的扩展。在一些版本中，这个参数可能已经被移除或替换为更有用的参数。</li>
</ul>
<p><strong>os_wait1</strong></p>
<p>暂停当前任务并等待事件发生。os_wait1 函数是 os_wait 函数的一个子集，只支持 K_SIG 这个值，表示等待一个信号。</p>
<p><strong>os_wait2</strong></p>
<p>同 os_wait 基本一致</p>
<blockquote>
<p>当 K_SIG 和 K_IVL 组合使用时，必须使用 <code>os_reset_interval</code> 函数来消除定时器延迟问题。</p>
</blockquote>
<p><strong>以 os_wait2 为例 与 delay_ms() 区别在：</strong></p>
<p>在 RTOS 中，如果 delay_ms() 被用于多个任务，它可能会导致任务调度的不公平或不可预测性，因为<strong>任务在等待期间会阻塞其他任务的执行</strong>。</p>
<p>如果多个任务都使用 delay_ms() 等待 100ms，那么每个任务都会独立地进入延时状态，并阻塞其他任务的执行（除非RTOS有特别的机制来处理这种情况）。</p>
<p>举个例子：</p>
<ol>
<li><p>假设我有 三个任务分别为 func1、func2、func3，三个任务都设置 delay_ms 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 3 &#x3D; 450ms、300ms、150ms，因为他们</p>
</li>
<li><p>假设我有 三个任务分别为 func1、func2、func3三个任务，其中 func1 设置 delay_ms，其他都设置 K_TMO 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 2 &#x3D; 300ms、200ms、100ms，因为他们</p>
</li>
</ol>
<blockquote>
<p>在 RTX51 Tiny 中，当多个任务处于休眠状态时，它们会共享同一个时间片。这意味着，当系统调度时，如果所有处于休眠状态的任务都没有被唤醒，调度器不会为它们分配不同的时间片。实际上，只有在任务被唤醒并准备好执行时，调度器才会考虑这些任务。</p>
<p>因此，在多个任务休眠的情况下，系统不会为每个休眠任务分配独立的时间片。它们会在系统处于闲置状态时共用资源，直到有任务需要执行或有事件发生以唤醒其中的某个任务。</p>
</blockquote>
<p>四、<strong>K_TMO 与 K_IVL 的区别</strong></p>
<p>当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。<br>当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</p>
<p><strong>K_SIG 信号等待</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、报错：<strong>WARNING L7: MODULE NAME NOT UNIQUE MODULE:  .\Objects\Conf_tny.obj (?RTX51_TINY_KERNAL)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51Bug1.png" alt="RTX51Bug1"></p>
<p>将 Conf_tny.A51 放在 RTX51TNY.LIB 前面即可</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RTX51系统</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/OS/RTOS/RTX51/RTX51%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>RTX51 是 KEIL 公司开发的针对 8051 系列单片机的多任务实时操作系统（RTOS）。它提供了<strong>多任务处理</strong>能力，允许程序以<strong>并行</strong>方式执行，适用于对时间要求严格的嵌入式应用。RTX51 具有简单的 API 和任务调度机制，使开发者能够更方便地管理任务和资源，确保系统的响应性和稳定性。RTX51 系统提供了任务管理、任务调度、任务通讯、定时器、信号量、邮箱等实时操作系统的基本功能，并与 Keil 公司的 C51 编译器紧密集成，从而方便开发人员进行开发和调试。</p>
<blockquote>
<p>RTX51 的多任务处理能力指的是系统能够同时管理和执行多个任务或进程的能力。多个任务看似同时运行，实际上是通过快速切换来实现的。这种切换由操作系统的调度器控制。</p>
</blockquote>
<p><strong>多核和多 CPU</strong></p>
<ul>
<li><p><strong>单核与多核</strong>：</p>
<ul>
<li><p><strong>单核</strong>：系统只有一个处理核心，所有任务都由这一核心处理。虽然能够完成基本的计算任务，但在同时执行多个任务时效率较低。</p>
</li>
<li><p><strong>多核</strong>：系统有多个处理核心（如双核、四核等），每个核心可以独立执行任务。这种架构可以提高并行处理能力，允许多个任务同时进行，从而提升整体性能。</p>
</li>
</ul>
</li>
<li><p><strong>单 CPU 与多 CPU</strong>：</p>
<ul>
<li><p><strong>单 CPU</strong>：系统只配备一个中央处理单元（CPU），类似于单核，但可以是一个复杂的多核处理器。</p>
</li>
<li><p><strong>多 CPU</strong>：系统配备多个 CPU，每个 CPU 可以独立处理任务，通常用于需要极高性能和处理能力的服务器</p>
</li>
<li><p>或高性能计算机。多 CPU 系统通过并行处理可以显著提高计算能力。</p>
</li>
</ul>
</li>
</ul>
<p><strong>RTX51 包含两个版本：</strong></p>
<p>RTX51 Tiny</p>
<ul>
<li>RTX51 Tiny是一个非常小型的实时操作系统，具有基本的任务调度功能，包括任务优先级和时间片轮转等RTX51 Tiny适用于基于51系列单片机的应用程序，特别是对于小型和简单的应用程序，因为它不需要太多的RAM和ROM资源。</li>
<li>相对于 RTX51 Full 不具备如下功能：<ul>
<li>由循环多任务处理和信号实现任务切换</li>
<li>不支持优先任务切换</li>
<li>不包含信息子程序</li>
<li>无存储器库分配子程序</li>
</ul>
</li>
</ul>
<p>RTX51 Full</p>
<ul>
<li>RTX51 Full则是一个功能更为强大的实时操作系统，它不仅支持基本的任务调度功能，还提供了更多的RTOS特性，例如信号量、邮箱、消息队列、事件标志和互斥量等，使得它更加适合于需要更高级RTOS特性的应用程序。</li>
</ul>
<p>RTX51 Tiny是一个轻量级的RTOS，适用于简单的应用程序，而RTX51 Full则提供了更多的RTOS特性，适用于更为复杂的应用程序。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="RTX51-Tiny-环境搭建"><a href="#RTX51-Tiny-环境搭建" class="headerlink" title="RTX51 Tiny 环境搭建"></a>RTX51 Tiny 环境搭建</h3><ol>
<li>新建一个项目</li>
<li>打开keil安装目录，来到<code>C51\RtxTiny2\SourceCode</code>目录，拷贝<code>Conf_tny.A51</code>和<code>RTX51TNY.LIB</code>到项目中。</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51bin.png" alt="RTX51bin"></p>
<ol start="3">
<li>打开配置，来到<code>Target</code>中，将<code>Operating system</code>修改为<code>RTX-51 Tny</code></li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51IDE.png" alt="RTX51IDE"></p>
<ol start="4">
<li>新建好<code>main.c</code>, 代码如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTX51TNY.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P5.3 闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_init</span><span class="params">()</span> &#123;</span><br><span class="line">	P5M1 &amp;= ~<span class="number">0x08</span>; P5M0 &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数名可随意, 建议不要使用start, 会和I2C.h里的Start冲突</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_start</span><span class="params">()</span> _task_ 0 &#123;</span><br><span class="line">	sys_init();</span><br><span class="line">	<span class="comment">// 创建任务 1</span></span><br><span class="line">	os_create_task(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 结束任务 0</span></span><br><span class="line">	os_delete_task(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_1</span><span class="params">()</span> _task_ 1 &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P53 = <span class="number">1</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">		</span><br><span class="line">		P53 = <span class="number">0</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不再有main函数</li>
<li>代码入口为标记为 <code>_task_ 0</code>的函数。</li>
<li><code>_task_</code>标记的函数，表示这个是独立的任务，多个task可以同时执行。</li>
</ul>
<h3 id="RTX51-注意事项"><a href="#RTX51-注意事项" class="headerlink" title="RTX51 注意事项"></a>RTX51 注意事项</h3><p>一、<strong>RTX51 对于系统硬件的要求</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51renwu.png" alt="RTX51renwu"></p>
<p>二、<strong>RTX51 任务的状态及定义</strong></p>
<p>RTX51 区分 2 类任务: <strong>快速任务</strong>和<strong>标准任务</strong>。快速任务有很快的响应速度，每个快速任务使用 8051 一个单独的寄存器组，并且有自己的堆栈区域。RTX51 支持最大同时有 3 个快速任务。标准任务需要多一点的时间来进行任务切换，因此使用的内部 RAM 相对快速任务要少，所有的标准任务共用 1 个寄存器组和堆栈。当任务切换的时候，当前任务的寄存器状态和堆栈内容转移到外部存储器中。</p>
<p>在 RTX51 Full 中，可以通过特定的 API 或函数来创建任务，并在创建时指定任务的类型（快速或标准）。<strong>RTX51 Tiny 则不支持快速任务。</strong></p>
<p>RTX51 FULL 支持任务最多达 64 个，但一般 RTX51 TINY 支持最大 16 个标准任务。</p>
<p>三、<strong>RTX51 自带延迟与 delay_ms() 延时的区别</strong></p>
<p>在 RTX51 Tiny 中 共有三个等待延时函数分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait</span>            <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ, </span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> dummy)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait1</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait2</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks)</span>;</span><br><span class="line"><span class="comment">// 参数如下：</span></span><br><span class="line"><span class="comment">/* constants for os_wait function：也就是等待函数的 typ */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_SIG 0x01 <span class="comment">/* 等待一个信号。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_TMO 0x02 <span class="comment">/* 等待由 ticks 指定的超时时间。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_IVL 0x80 <span class="comment">/* 等待由 ticks 指定的时间间隔。*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数中：K_TMO、K_IVL 看解释十分相似，但其实区别很大：</span></span><br><span class="line"><span class="comment">当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。</span></span><br><span class="line"><span class="comment">当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>os_wait</strong></p>
<p>暂停当前任务，等待一个或多个事件；例如一个时间间隔、超时或来自其他任务或中断的信号。typ 参数指定要等待的事件或事件组合，可以是上述参数中的常量之一：</p>
<p>typ 可以通过竖线（|）字符进行逻辑或操作。例如，K_TMO | K_SIG 表示任务等待超时或信号。</p>
<ul>
<li>**<code>typ</code>**：这是一个指定等待类型的参数。RTX51 中可能定义了多种等待类型，如等待事件、消息、信号量等。具体的类型值取决于 RTX51 的具体实现和文档。</li>
<li>**<code>ticks</code>**：这是等待的时间长度，以操作系统的“tick”为单位。一个 tick 的长度取决于 RTX51 的配置，通常与系统的时钟频率有关。</li>
<li>**<code>dummy</code>**：这个参数在大多数实现中可能并不真正使用，而是为了保持函数签名的兼容性或预留未来的扩展。在一些版本中，这个参数可能已经被移除或替换为更有用的参数。</li>
</ul>
<p><strong>os_wait1</strong></p>
<p>暂停当前任务并等待事件发生。os_wait1 函数是 os_wait 函数的一个子集，只支持 K_SIG 这个值，表示等待一个信号。</p>
<p><strong>os_wait2</strong></p>
<p>同 os_wait 基本一致</p>
<blockquote>
<p>当 K_SIG 和 K_IVL 组合使用时，必须使用 <code>os_reset_interval</code> 函数来消除定时器延迟问题。</p>
</blockquote>
<p><strong>以 os_wait2 为例 与 delay_ms() 区别在：</strong></p>
<p>在 RTOS 中，如果 delay_ms() 被用于多个任务，它可能会导致任务调度的不公平或不可预测性，因为<strong>任务在等待期间会阻塞其他任务的执行</strong>。</p>
<p>如果多个任务都使用 delay_ms() 等待 100ms，那么每个任务都会独立地进入延时状态，并阻塞其他任务的执行（除非RTOS有特别的机制来处理这种情况）。</p>
<p>举个例子：</p>
<ol>
<li><p>假设我有 三个任务分别为 func1、func2、func3，三个任务都设置 delay_ms 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 3 &#x3D; 450ms、300ms、150ms，因为他们</p>
</li>
<li><p>假设我有 三个任务分别为 func1、func2、func3三个任务，其中 func1 设置 delay_ms，其他都设置 K_TMO 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 2 &#x3D; 300ms、200ms、100ms，因为他们</p>
</li>
</ol>
<blockquote>
<p>在 RTX51 Tiny 中，当多个任务处于休眠状态时，它们会共享同一个时间片。这意味着，当系统调度时，如果所有处于休眠状态的任务都没有被唤醒，调度器不会为它们分配不同的时间片。实际上，只有在任务被唤醒并准备好执行时，调度器才会考虑这些任务。</p>
<p>因此，在多个任务休眠的情况下，系统不会为每个休眠任务分配独立的时间片。它们会在系统处于闲置状态时共用资源，直到有任务需要执行或有事件发生以唤醒其中的某个任务。</p>
</blockquote>
<p>四、<strong>K_TMO 与 K_IVL 的区别</strong></p>
<p>当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。<br>当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</p>
<p><strong>K_SIG 信号等待</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、报错：<strong>WARNING L7: MODULE NAME NOT UNIQUE MODULE:  .\Objects\Conf_tny.obj (?RTX51_TINY_KERNAL)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/OS/RTX51/RTX51Bug1.png" alt="RTX51Bug1"></p>
<p>将 Conf_tny.A51 放在 RTX51TNY.LIB 前面即可</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
</search>
